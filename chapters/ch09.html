<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Improving the Write Ahead Log</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_improving_the_write_ahead_log">Improving the Write Ahead Log</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the pervious chapter, we built a Write Ahead Log and made sure that it is written to the disk in a durable manner. We implemented recovery on startup as well
as a checkpoint process, clearing the WAL when we know that old transactions are safely stored in the data file. The implementation we have in the previous chapter
<em>works</em>, but it was meant primarily to provide you with the <em>concept</em> of the Write Ahead Log and how it perform its role.</p>
</div>
<div class="paragraph">
<p>There is a <em>lot</em> that is still missing from the implementation and I intend to make this chapter a journey into completing those holes in the WAL.</p>
</div>
<div class="sect2">
<h3 id="_verifying_transaction_integrity">Verifying transaction integrity</h3>
<div class="paragraph">
<p>A transaction is considered committed if it was written to the WAL successfully. On startup, we&#8217;ll recover any change that were made in this transaction and ensure
that we have no data loss. What will happen if the write to the WAL ended prematurely? Let&#8217;s say that we have a transaction that modified 10 pages, in our current
implementation, we&#8217;ll need 88KB in the log to record the transaction (8KB for the transaction header, which is page aligned and then 80KB for the modified pages).
If we crashed midway through the way, and only the first 40KB made it into the WAL, what will happen?</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What guarantees we require from the hardware?</div>
<div class="paragraph">
<p>The SQLite project has <a href="https://www.sqlite.org/atomiccommit.html">excellent documentation</a> on their assumptions of what will be the minimum behavior of the hardware
they need in order to run. Gavran has slightly different requirements, however:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We assume that a write to the disk on page boundary will only impact the page or pages that it is touching. In other words, a write to a page cannot have any
effect on the data on another page.</p>
</li>
<li>
<p>We assume that a write to the disk is non atomic and may fail midway, including when we are using <code>O_DIRECT | O_DSYNC</code> or any equivalent. Such failures, however,
are constrained in their behavior. After a failed write, each byte in the page that was written to will be either:</p>
<div class="ulist">
<ul>
<li>
<p>The value of that byte <em>before</em> the write.</p>
</li>
<li>
<p>The value of that byte <em>after</em> the write.</p>
</li>
<li>
<p>There is no requirement that a range of bytes will change in an atomic manner, each byte may be set to its previous or new value and Gavran will operate correctly.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In particular, we assume that a write to a page doesn&#8217;t have to modify all the bytes, but any byte in the page must be either the old value or the new value. There
is no scenario where the bytes on the page are zeroed or set to random values because of a failed write.</p>
</li>
<li>
<p>A <em>successful</em> write to the disk with <code>O_DIRECT | O_DSYNC</code> will ensure that the data is stored in a persistent medium, resilient to power failures.</p>
</li>
<li>
<p>A <em>successful</em> call to <code>fsync()</code> will ensure that all the writes made to the file reside in a persistent medium, resilient to power failures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These assumptions are actually <em>weaker</em> than those made by SQLite, if you&#8217;ll note. There is no assumption of atomic writes on a sector or a particular order imposed on
the write order to the disk. To my knowledge, all the disks that you are likely to encounter will behave according to these assumptions. The only exceptions of some
cheap consumer disks that don&#8217;t implement <code>fsync()</code> or FUA (Force Unit Access, what <code>O_DIRECT | O_DSYNC</code> is translated into) properly.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Right now, if we have a failed write, it is very likely copy empty or random pages into the data file, causing data corruption. This is because we aren&#8217;t verifying the <em>integrity</em> of the
transactions. In order to handle that, we&#8217;ll need to compute a hash of the transaction before writing it and validate it during recovery. In the previous chapter
I mentioned that the choices I have are between <code>xxHash64</code> (a non cryptographic fast hash) and <code>BLAKE2b</code> (a cryptographic hash). The <code>xxHash64</code> is much faster, but
I&#8217;m going to use <code>Blake2B</code> for now.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Why <code>BLAKE2b</code> over <code>xxHash64</code>?</div>
<div class="paragraph">
<p>Either one will serve us well. The <code>BLAKE2b</code> requires 32 bytes compared to 8 bytes for <code>xxHash64</code>, but I&#8217;m not concerned about the size. We have plenty of space
in the transaction header. So why <code>BLAKE2b</code>? I could argue about safety, but I have no threat model that require me to handle attackers that can modify the data
on disk.</p>
</div>
<div class="paragraph">
<p>We are trying to protect ourselves either from partial writes or corruption on disk. Either option will be detected just as well by <code>xxHash64</code>. The answer is
simple, until I have a performance trace that says that <code>BLAKE2b</code> is causing performance issues, it is easier for me to just use it rather than <code>xxHash64</code>.
The <code>libsodium</code> package, which I used to get the <code>BLAKE2b</code> implementation is easy to setup and consume. For <code>xxHash64</code> I had to include some headers and modify
the build process. We are also going to need <code>libsodium</code> anyway in chapter 11, so we might as well use it now.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first step along the way to verifying the transaction integrity is to add hashing in the <code>wal_append</code>. You can the changes required in <a href="#wal_append_09"><code>wal.c</code> - Hashing the transaction&#8217;s data using <code>crypto_generichash()</code> (which uses <code>BLAKE2b</code>).</a>.</p>
</div>
<div id="wal_append_09" class="listingblock">
<div class="title"><code>wal.c</code> - Hashing the transaction&#8217;s data using <code>crypto_generichash()</code> (which uses <code>BLAKE2b</code>).</div>
<div class="content">
<pre class="highlight"><code>result_t wal_append(txn_state_t *tx) {
  wal_txn_t *txn_buffer;
  ensure(wal_prepare_txn_buffer(tx, &amp;txn_buffer));
  defer(free, txn_buffer);

  // <b class="conum">(1)</b>
  const size_t size = crypto_generichash_BYTES;
  ensure(!crypto_generichash(txn_buffer-&gt;hash_blake2b, size,
             (uint8_t *)txn_buffer + size,
             txn_buffer-&gt;page_aligned_tx_size - size, 0, 0),
      msg("Unable to compute hash for transaction"),
      with(txn_buffer-&gt;tx_id, "%lu"));

  wal_state_t *wal = &amp;tx-&gt;db-&gt;wal_state;

  wal_file_state_t *cur_file = &amp;wal-&gt;files[0];
  ensure(pal_write_file(cur_file-&gt;handle, cur_file-&gt;last_write_pos,
      (char *)txn_buffer, txn_buffer-&gt;page_aligned_tx_size));
  cur_file-&gt;last_write_pos += txn_buffer-&gt;page_aligned_tx_size;
  cur_file-&gt;last_tx_id = tx-&gt;tx_id;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The new code, hashing the data in the transaction and using the <code>hash_blake2b</code> field at the beginning of the transaction to store it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>hash_blake2b</code> field is the first field in the <code>wal_txn_t</code> structure. This is done using the <code>crypto_generichash()</code> function from <code>libsodium</code> and will
run over the entire transaction buffer (sans the first 32 bytes, where the hash value is written to).</p>
</div>
<div class="paragraph">
<p>You can see that the actual amount of code we need to compute the hash is minimal, this is because the entire transaction is a single continuous buffer. You&#8217;ll
recall that avoided using the <code>pwritev()</code> in the previous chapter, even though it allows us to save on copying of the data. One of the reasons we skipped on the
vectored writes is the simplicity for operations such as hashing of the transaction buffer. We could compute the hash on the separate pages, but it takes more code
and is somewhat more complex. We&#8217;ll see more reasons for why we want to use a single buffer shortly.</p>
</div>
<div class="paragraph">
<p>Validation of the transaction integrity is done by <code>wal_validate_transaction()</code>, shown in <a href="#wal_validate_transaction"><code>wal.c</code> - Verifying the integrity of the transaction has as part of the database recovery</a>.</p>
</div>
<div id="wal_validate_transaction" class="listingblock">
<div class="title"><code>wal.c</code> - Verifying the integrity of the transaction has as part of the database recovery</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_validate_transaction(reusable_buffer_t *buffer,
    void *start, void *end, wal_txn_t **txn_p) {
  *txn_p        = 0;
  wal_txn_t *tx = start;
  if (!tx-&gt;tx_id || tx-&gt;page_aligned_tx_size + start &gt; end) {
    *txn_p = 0;
    return success();
  }
  uint8_t hash[crypto_generichash_BYTES];
  const size_t size = crypto_generichash_BYTES;
  ensure(!crypto_generichash(hash, size, (uint8_t *)tx + size,
             tx-&gt;page_aligned_tx_size - size, 0, 0),
      msg("Unable to compute hash for transaction on recover"),
      with(tx-&gt;tx_id, "%lu"));

  if (memcmp(hash, tx-&gt;hash_blake2b, size) != 0) {
    *txn_p = 0;  // not a match on the hash, failed
    return success();
  }
  // we got a valid hash, can go forward with this
  ensure(wal_decompress_transaction(buffer, tx, txn_p));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Validating the transaction is as easy as computing the initial hash. If we fail to validate the hash, we consider this to be a broken transaction and abort the recovery process.
That means that a partial write will be consider as noop and will have no effect, exactly as we want it to be. If you&#8217;ll recall, the fact that we reuse the file after we
reset it means that we may read a valid transaction, only to have the next page come from the middle of a previous transaction. Now we can rest assured that such a case will
not be an issue for us. We validate using a cryptographic hash function, so there is no chance to get a value that would accidentally validate as a valid transaction.</p>
</div>
<div class="paragraph">
<p>Note that we have a call here to <code>wal_decompress_transaction()</code>, we&#8217;ll look at that in more details later in this chapter. For now, you can assume that this just sets the
<code>txn_p</code> pointer to the <code>tx</code> value.</p>
</div>
<div class="paragraph">
<p>With those two modifications, we have proper validation of transaction written to the disk. That wasn&#8217;t bad at <em>all</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_validating_future_transactions">Validating future transactions</h3>
<div class="paragraph">
<p>Now that we can verify the transaction integrity, we need to consider an interesting scenario. What happen if we fail to verify a transaction, but there
are valid transactions <em>beyond</em> that invalid transaction? Consider the scenario shown in <a href="#wal-corruption">Invalid transaction (tx 5) followed by a valid transaction (tx 6)</a>.</p>
</div>
<div id="wal-corruption" class="imageblock">
<div class="content">
<img src="../imgs/wal-corruption.png" alt="wal corruption">
</div>
<div class="title">Figure 1. Invalid transaction (tx 5) followed by a valid transaction (tx 6)</div>
</div>
<div class="paragraph">
<p>In <a href="#wal-corruption">Invalid transaction (tx 5) followed by a valid transaction (tx 6)</a> we have transaction 5, which has a bad hash value. Notice that its size (the surrounding rectangle) goes into the next transaction. In our current code,
we&#8217;ll run through the WAL, find that transaction 5 cannot pass verification and stop. That is fine, if this was an uncommitted transaction. However, the
situation in <a href="#wal-corruption">Invalid transaction (tx 5) followed by a valid transaction (tx 6)</a> is not an uncommitted transaction, partially written to disk. It is a data corruption error in the middle of the WAL. It corrupted
transaction 5, but transaction 6 is still there.</p>
</div>
<div class="paragraph">
<p>There isn&#8217;t much that we can <em>do</em> about such a scenario, mind. If we can&#8217;t verify the hash, it is not possible to copy the pages and move on. We need to
<em>report</em> this scenario, however, and not allow the system to proceed and erase committed transactions.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Is failing recovery a viable options? It is the <em>only</em> option!</div>
<div class="paragraph">
<p>In a case such as <a href="#wal-corruption">Invalid transaction (tx 5) followed by a valid transaction (tx 6)</a>, we have three options. We can attempt to write the transaction pages to the disk and hope for the best. That is likely going
to cause us data corruption and <em>strange</em> errors down the line. Let&#8217;s avoid that. We can abort the recovery process on the first transaction that failed
to verify.</p>
</div>
<div class="paragraph">
<p>That sounds like a good idea, but it has two separate problems. The first is that we have transactions committed after the corrupted transaction that will
now be (hopefully) rolled back. That is actually the best case scenario. Remember that recovery isn&#8217;t the only thing that writes to the data file. We are
also writing to the data file on an ongoing basis. It is entirely possible that some of the pages from the corrupted transaction (or later ones) were saved
to the data file, while other haven&#8217;t. That leads back to data corruption and&#8230;&#8203; <em>challenging</em> debugging sessions.</p>
</div>
<div class="paragraph">
<p>If we detect such an issue and abort, we can at least have the user do something meaningful. Like restore from backup, which is probably the only safe option
that is left, after we found that we have disk corruption on the WAL.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We verify that the WAL has no valid transactions in the end in <code>wal_next_valid_transaction()</code>, you can see the changes in <a href="#wal_next_valid_transaction_09"><code>wal.c</code> - After we get an invalid transaction, error if we have <em>valid</em> transactions that we are going to have to skip</a>.</p>
</div>
<div id="wal_next_valid_transaction_09" class="listingblock">
<div class="title"><code>wal.c</code> - After we get an invalid transaction, error if we have <em>valid</em> transactions that we are going to have to skip</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_next_valid_transaction(
    struct wal_recovery_operation *state, wal_txn_t **txp) {
  if (state-&gt;start &gt;= state-&gt;end ||
      !wal_validate_transaction(
          &amp;state-&gt;tmp_buffer, state-&gt;start, state-&gt;end, txp) ||
      !*txp || state-&gt;last_recovered_tx_id &gt;= (*txp)-&gt;tx_id) {
    *txp = 0;
    // <b class="conum">(1)</b>
    ensure(wal_validate_after_end_of_transactions(state));
  } else {
    state-&gt;last_recovered_tx_id = (*txp)-&gt;tx_id;
    state-&gt;start = state-&gt;start + (*txp)-&gt;page_aligned_tx_size;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The new code, call <code>wal_validate_after_end_of_transactions()</code> to ensure that there are no more valid transactions in the WAL.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We start scanning the WAL after the last valid transaction one page at a time. Transactions are always on a page boundary, so that makes things easier for us. If
we find something that looks like a transaction, we will see if it is valid. A valid transaction that is lower than the <code>last_tx_id</code> on the database is fine, we a
already have this data in the data file. That can happen after the WAL has been reset. You can see the full details in <a href="#wal_validate_after_end_of_transactions"><code>wal.c</code> - Validating that no further transactions in the WAL are valid</a>.</p>
</div>
<div class="paragraph">
<p>If the transaction is valid and come <em>after</em> the last known transaction, we found an error and need to fail the recovery. If we found data that we can&#8217;t validate
we need to go over the rest of the WAL file one page at a time, trying to see if there is a transaction there.</p>
</div>
<div id="wal_validate_after_end_of_transactions" class="listingblock">
<div class="title"><code>wal.c</code> - Validating that no further transactions in the WAL are valid</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_ensure_last_tx_id_is_set(
    wal_recovery_operation_t *s) {
  if (s-&gt;last_recovered_tx_id) return success();
  txn_t rtx;  // nothing from WAL, load the db's last_tx_id
  ensure(txn_create(s-&gt;db, TX_READ, &amp;rtx));
  defer(txn_close, rtx);
  page_t page = {.page_num = 0};  // maybe new db, have to use raw API
  ensure(txn_raw_get_page(&amp;rtx, &amp;page));
  page_metadata_t *metadata = page.address;
  s-&gt;last_recovered_tx_id   = metadata-&gt;file_header.last_tx_id;
  return success();
}
static result_t wal_validate_after_end_of_transactions(
    wal_recovery_operation_t *s) {
  ensure(wal_ensure_last_tx_id_is_set(s));
  while (true) {
    void *cur, *end;
    ensure(wal_get_next_range(s, &amp;cur, &amp;end));
    if (!cur) break;
    wal_txn_t *tx;
    if (flopped(wal_validate_transaction(
            &amp;s-&gt;tmp_buffer, cur, end, &amp;tx)) ||
        !tx) {
      errors_clear();  // errors are expected here
      wal_increment_next_range_start(s, PAGE_SIZE);
      continue;
    }
    if (s-&gt;last_recovered_tx_id &gt; tx-&gt;tx_id) {
      break;  // valid old tx, we had a WAL reset and can stop
    }
    ssize_t corrupted_pos   = cur - s-&gt;files[0]-&gt;span.address;
    wal_txn_t *corrupted_tx = cur;
    failed(ENODATA, msg("Valid TX after invalid TX"),
        with(corrupted_pos, "%zd"), with(tx-&gt;tx_id, "%lu"),
        with(corrupted_tx-&gt;tx_id, "%lu"),
        with(s-&gt;db-&gt;state-&gt;last_tx_id, "%lu"));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The point in <code>wal_validate_after_end_of_transaction()</code> is that we&#8217;ll run through the WAL and any corruption will cause us to skip the transaction. We&#8217;ll then scan for
more valid transactions and if there are any, we can detect that there was an error. Note that a corruption on the <em>last</em> transaction isn&#8217;t something that we can detect.
There is no way to separate that from a transaction that wasn&#8217;t committed properly to the disk and we&#8217;ll have to consider that as rolled back.</p>
</div>
<div class="paragraph">
<p>Startup time of the database matters, and we&#8217;ll usually find the next valid transaction (with an old transaction id) in the WAL. When we get to that point, we know that we
are good and that we don&#8217;t need to scan the rest of the WAL.</p>
</div>
<div class="paragraph">
<p>In <a href="#wal_validate_after_end_of_transactions"><code>wal.c</code> - Validating that no further transactions in the WAL are valid</a> we are using a few utility functions, you can see them in <a href="#wal_range"><code>wal.c</code> - Utility functions to make iterating over the WAL contents easier</a>.</p>
</div>
<div id="wal_range" class="listingblock">
<div class="title"><code>wal.c</code> - Utility functions to make iterating over the WAL contents easier</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_get_next_range(
    wal_recovery_operation_t *state, void **current, void **end) {
  *end = state-&gt;end;
  if (state-&gt;start &gt;= state-&gt;end) {
    *current = 0;
    return success();
  }
  *current = state-&gt;start;
  return success();
}

static void wal_increment_next_range_start(
    wal_recovery_operation_t *state, size_t amount) {
  state-&gt;start += amount;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#wal_range"><code>wal.c</code> - Utility functions to make iterating over the WAL contents easier</a> shows some trivial functions, but we&#8217;ll add more meaning to them in the future.</p>
</div>
</div>
<div class="sect2">
<h3 id="_remembering_the_transaction_id">Remembering the transaction id</h3>
<div class="paragraph">
<p>The transaction id is incremented by Gavran on any successful commit. It is very important for us during the WAL recovery, to know what is the latest transaction
that we recovered and make sure that there aren&#8217;t any future valid transactions that are in the WAL after we stopped the recovery. That leads to an interesting
question, how can we remember the transaction id if we reset the WAL and perform no recovery on startup?</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">Do we have to worry about overflowing <code>tx_id</code>?</div>
<div class="paragraph">
<p>The <code>tx_id</code> is a <code>uint64_t</code> value, its maximum value is <code>18,446,744,073,709,551,616</code>. If we run 100,000 transactions per second, it will take us over
<em>5.8 million</em> years to get <em>near</em> the top values of <code>uint64_t</code>. For all intents and purposes, that is big enough range that can consider it infinite.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two ways we can handle that. When we reset the WAL, instead of writing a page of zeroes, we can write an empty transaction that will hold the last
transaction id. Alternatively, we can store the value in the data file directly. I chose the later option, and this happens in <code>txn_commit()</code>. You can see
the behavior in <a href="#txn_commit_09"><code>txn.c</code> - Saving the transaction id on commit in the file header</a>.</p>
</div>
<div id="txn_commit_09" class="listingblock">
<div class="title"><code>txn.c</code> - Saving the transaction id on commit in the file header</div>
<div class="content">
<pre class="highlight"><code>result_t txn_commit(txn_t *tx) {
  errors_assert_empty();

  // no modification, no work to do
  if (!tx-&gt;state-&gt;modified_pages-&gt;count) return success();
  // <b class="conum">(1)</b>
  page_metadata_t *header;
  ensure(txn_modify_metadata(tx, 0, &amp;header));
  header-&gt;file_header.last_tx_id = tx-&gt;state-&gt;tx_id;

  ensure(wal_append(tx-&gt;state));

  tx-&gt;state-&gt;flags  = TX_COMMITED;
  tx-&gt;state-&gt;usages = 1;

  tx-&gt;state-&gt;db-&gt;last_write_tx-&gt;next_tx = tx-&gt;state;
  tx-&gt;state-&gt;db-&gt;last_write_tx          = tx-&gt;state;
  tx-&gt;state-&gt;db-&gt;last_tx_id             = tx-&gt;state-&gt;tx_id;

  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New code, storing the transaction id in the file&#8217;s header.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that in <a href="#txn_commit_09"><code>txn.c</code> - Saving the transaction id on commit in the file header</a> we are actually modifying the metadata of the first page using the <code>txn_modify_metadata()</code>, so any committed transaction will
have modification to the first page of the data file.</p>
</div>
<div class="paragraph">
<p>The advantage of putting the last transaction id in the header is that after recovery, we can verify (again) that the numbers match and we know that we can
simply increment it again on the next write transaction.</p>
</div>
<div class="paragraph">
<p>Right now, the only <em>use</em> we have for the transaction id is for the WAL but it is actually quite useful to be able to track transactions. Features such as
incremental backups can rely on this to make such features much easier. The transaction id also make it <em>much</em> easier to debug certain things, because you
can easily track the changes over multiple transactions and can refer to them explicitly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_optimizing_fsync_calls">Optimizing <code>fsync</code> calls</h3>
<div class="paragraph">
<p>I mentioned a few times that <code>fsync()</code> is expensive, but it bears repeating. Yes, <code>fsync()</code> is that expensive. Our current system will cause us to call <code>fsync()</code>
whenever there are no active transactions. That means that if we have a set of write transactions that run sequentially, we&#8217;ll have an <code>fsync()</code> after every
transaction. That is going to be <em>expensive</em>. We actually saw that in the last chapter, when we analyzed the <code>strace</code> output of a unit test. Right now, if we
have no active transactions when we close a transaction, we&#8217;ll trigger a checkpoint and will call <code>fsync()</code>.</p>
</div>
<div class="paragraph">
<p>We can delay that cost very simply. Instead of running a checkpoint whenever there are no active transactions, we&#8217;ll do so only when there are no active
transactions <em>and</em> the WAL is over half full.  That gives us the option to delay the <code>fsync()</code> calls significantly and the user can use the <code>wal_size</code> to
decide how often the checkpoint process should run.</p>
</div>
<div id="wal_will_checkpoint_09" class="listingblock">
<div class="title"><code>wal.c</code> -  Deciding to checkpoint only when the WAL is over half full, to delay expensive <code>fsync()</code> calls.</div>
<div class="content">
<pre class="highlight"><code>bool wal_will_checkpoint(db_state_t *db, uint64_t tx_id) {
  if (!db) return false;

  bool full = db-&gt;wal_state.files[0].last_write_pos &gt;
              db-&gt;options.wal_size / 2;
  bool at_end = tx_id &gt;= db-&gt;wal_state.files[0].last_tx_id;

  return full &amp;&amp; at_end;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is minimal, but the implications are profound. We&#8217;ll now do a checkpoint (and the relevant <code>fsync()</code>) only when the WAL if over half full, which
in most cases means that we can call <code>fsync()</code> on the changes of <em>many</em> transactions and ameliorate the cost significantly. There is also a good chance that this
delay will allow the operating system to already write some of the data we wrote to the data file on its own, further reducing our costs.</p>
</div>
<div class="paragraph">
<p>It is important to distinguish between writing to the data file and a checkpoint. We&#8217;ll always write to the data file as soon as we are able, but we do that using
buffered I/O and we aren&#8217;t going to trust that until <code>fsync()</code> is called. A checkpoint is exactly that, an <code>fsync()</code> called on the data file followed by trimming of
the data on the WAL.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reducing_the_cost_of_writing_to_the_wal">Reducing the cost of writing to the WAL</h3>
<div class="paragraph">
<p>Our current WAL solution requires that we&#8217;ll write any modified page to the WAL, regardless of what changed inside the page.  Consider a call to <code>txn_allocate_page()</code>,
which will also modify the metadata page. we are only touching 64 bytes in the metadata, but we have to write the whole metadata page. Or the fact that any <code>txn_commit()</code>
call will update the <code>last_tx_id</code> on the file header. In this case, that is only an 8 bytes change, but we modify the whole page.
There are many more cases where the changes you are actually making to the modified page are smaller than the full page. Instead of writing the full page to the WAL, we
can write the <em>difference</em> between the modified page and the original version.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Writing the modified data, one transaction at a time&#8230;&#8203;</div>
<div class="paragraph">
<p>In <code>wal_recover()</code>, we are scanning through the transactions in the WAL and write the pages in them to the data file, one transaction at a time. When we do the
same using <code>txn_gc()</code> during live database operations, we call <code>txn_merge_unique_pages()</code> first, to make sure that we are only writing a page a single time and
not however many times it has changed in the set of transactions that we are currently writing to disk.</p>
</div>
<div class="paragraph">
<p>Why the difference between the two modes? We <em>could</em> scan through the WAL and gather a list of pages to write to the disk, keeping only the latest version for
each one of them. I didn&#8217;t go with this route because we are going to implement diffed writes, which reduce the amount we write to the disk
<em>significantly</em>, but require us to modify the page for each transaction.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There are many binary diff algorithms, VCDiff and XDelta both come to mind as general purpose binary diff systems. I looked into them to manage the diffs we&#8217;ll
write to the WAL, but they are <em>generic</em> algorithms. They do a lot more than what I need, and they come with baggage that I don&#8217;t really want to deal with.</p>
</div>
<div class="paragraph">
<p>I have a <em>lot</em> of advantages when writing a diff function like that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The size of the <code>origin</code> and <code>modified</code> buffers match.</p>
</li>
<li>
<p>Both are some multiple of PAGE_SIZE and are 8KB aligned.</p>
</li>
<li>
<p>Most of the data changes will be 8 bytes aligned and I don&#8217;t need byte level granularity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When we call <code>txn_raw_modify_page()</code>, we do a Copy on Write from the previous instance of the page. If we keep track of that page, we can easily do the diff.
The <code>previous</code> field in <code>page_t</code> is set  <code>original.address</code> in <code>txn_raw_modify_page()</code> for this exact purpose. There is one caveat to the <code>previous</code> usage, if
we allocate a page that is in memory with a different size. This is an edge case that we treat as if we had no previous value. This can happen if we allocate
a page, freed it and then reused the space for an allocation of a different size.
We&#8217;ll need to change the implementation of <code>wal_setup_transaction_data()</code>, where we copy the actual pages from the transaction to the WAL. You can see what
needs to be done in <a href="#wal_setup_transaction_data_09"><code>wal.c</code> - The WAL will now write diffed versions of the modified pages, if possible</a>.</p>
</div>
<div id="wal_setup_transaction_data_09" class="listingblock">
<div class="title"><code>wal.c</code> - The WAL will now write diffed versions of the modified pages, if possible</div>
<div class="content">
<pre class="highlight"><code>static void *wal_setup_transaction_data(
    txn_state_t *tx, wal_txn_t *wt, void *output) {
  size_t iter_state = 0;
  page_t *entry;
  size_t index = 0;

  while (pagesmap_get_next(tx-&gt;modified_pages, &amp;iter_state, &amp;entry)) {
    wt-&gt;pages[index].number_of_pages = entry-&gt;number_of_pages;
    wt-&gt;pages[index].page_num        = entry-&gt;page_num;
    size_t size = wt-&gt;pages[index].number_of_pages * PAGE_SIZE;
    // <b class="conum">(1)</b>
    void *end = wal_diff_page(entry-&gt;previous, entry-&gt;address,
        size / sizeof(uint64_t), output);
    wt-&gt;pages[index].flags = (size == (size_t)(end - output))
                                 ? wal_txn_page_flags_none
                                 : wal_txn_page_flags_diff;
    wt-&gt;pages[index].offset = (uint64_t)(output - (void *)wt);
    output                  = end;
    index++;
  }
  return output;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New code, instead of calling <code>memcpy()</code>, we&#8217;ll use <code>wal_diff_page()</code> to write to the <code>output</code> buffer. The page&#8217;s flag are set based on the <code>output</code> size.
If we wrote less than the size of the modified page, we wrote a diff, and we indicate as such.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The idea is that <code>wal_diff_page()</code> is going to be able to write just the <em>differences</em> between pages. In the case of the <code>last_tx_id</code> change on the file header,
we have an 8 bytes change in an 8KB page. In the previous chapter, we&#8217;ll need to write the full 8KB page to the WAL, but <code>wal_diff_page()</code> allows us to write a lot
less.</p>
</div>
<div class="paragraph">
<p>The <code>wal_diff_page()</code> is passed three buffers. The previous version of the page, the current version and the output. The input buffers (previous &amp; current versions)
must have the same size and the function will write up to that size to the <code>output</code>. If it can&#8217;t find a diff that is smaller than the data size, it will simply copy
the current version to the <code>output</code> and use that.</p>
</div>
<div class="paragraph">
<p>In the common case, we expect to be able to reduce the size we write to disk by a lot, but we have to be prepared to the option that we can&#8217;t do any diffing whatsoever.
That means that we still have to allocate as much memory as we have modified pages in the transaction. Another important thing to remember is that because <code>wal_diff_page()</code>
will hopefully write less than its input, the <em>output</em> of each page is no longer going to be page aligned.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Taking advantage of Linux&#8217;s memory allocation behavior</div>
<div class="paragraph">
<p>Linux uses lazy memory allocation scheme. When you ask for memory from the operating system, what you&#8217;ll actually get is <em>memory reservation</em>, without
allocating the physical memory required for this. Using <code>glibc</code>, we can assume that allocations greater than 128Kb (16 pages) will go directly to the
operating system, which will exhibit this behavior.</p>
</div>
<div class="paragraph">
<p>Our diff algorithm is going to produce output that is up to the size of the diffed pages, so the worse case scenario is that we run the diff and
we have to write the same amount of data as the pages that were modified. More commonly, we&#8217;ll be able to see substantial reduction in size and so
even though we allocated a large buffer, we aren&#8217;t actually paying for that in terms of memory usage.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The interesting work happens inside the <code>wal_diff_page()</code>, where we scan both versions of the page and figure out what is the minimum output we&#8217;ll need to write to recover
the data. You can see the implementation in <a href="#wal_diff_page"><code>wal.c</code> - Diffing two versions of a page and produce a list of changes between them</a>.</p>
</div>
<div id="wal_diff_page" class="listingblock">
<div class="title"><code>wal.c</code> - Diffing two versions of a page and produce a list of changes between them</div>
<div class="content">
<pre class="highlight"><code>static void *wal_diff_page(uint64_t *restrict origin,
    uint64_t *restrict modified, size_t size, void *output) {
  if (!origin) {  // no previous definition
    memcpy(output, modified, size * sizeof(uint64_t));
    return output + (size * sizeof(uint64_t));
  }
  void *current = output;
  void *end     = output + size * sizeof(uint64_t);
  for (size_t i = 0; i &lt; size; i++) {
    if (origin[i] == modified[i]) {
      continue;
    }
    bool zeroes       = true;
    size_t diff_start = i;
    for (; i &lt; size &amp;&amp; (i - diff_start) &lt; (1024 * 1024); i++) {
      zeroes &amp;= modified[i] == 0;  // single diff size limited to 8MB
      if (origin[i] == modified[i]) {
        if (zeroes)
          continue;  // we'll try to extend zero filled ranges
        break;
      }
    }
    if (i == size) i--;  // reached the end of the buffer, go back
    void *required_write = current + sizeof(wal_page_diff_t);
    wal_page_diff_t diff = {
        .offset = (uint32_t)(diff_start * sizeof(uint64_t)),
        .length = (int32_t)((i - diff_start) * sizeof(uint64_t))};
    if (zeroes) {
      diff.length = -diff.length;  // indicates zero fill
    } else {
      required_write += diff.length;
    }
    if (required_write &gt;= end) {
      memcpy(output, modified, size * sizeof(uint64_t));
      return end;
    }
    memcpy(current, &amp;diff, sizeof(wal_page_diff_t));
    current += sizeof(wal_page_diff_t);
    if (diff.length &gt; 0) {
      memcpy(current, modified + diff_start, (size_t)diff.length);
      current += diff.length;
    }
  }

  return current;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <code>wal_diff_page()</code> operates in over 8 bytes at a time (<code>uint64_t</code>) and try to find the first index where the two versions of the page are
different. Once a difference is found, it tries to find how big that range of different values are. We then write a <code>wal_page_diff_t</code> header that
tells us where to place the diff and what is the length of the range that we need to copy. The actual buffer we copy for each range are stored
immediately following the <code>wal_page_diff_t</code> value.</p>
</div>
<div class="paragraph">
<p>There is a small optimization for zero filled ranges. Those are common enough (for example, zeroing a page) that I deemed it advisable to handle it
directly. In the case of zero range, we&#8217;ll store a <em>negative</em> length in <code>wal_page_diff_t</code>, without storing a range of zeros afterward. You&#8217;ll note that
each different range costs us the size of <code>wal_page_diff_t</code>, which is 8 bytes in size. We could probably reduce it further, but there is little need.</p>
</div>
<div class="paragraph">
<p>If we see that there are a lot of differences in the file, the diffed output will exceed the size of the page and we&#8217;ll just write the page as is to
the WAL. That means that we can predict what is the maximum amount of memory that we need to utilize in advance.</p>
</div>
<div class="paragraph">
<p>Note that if we have <em>no</em> previous value it means that the previous version of this page is actually either a partial page (a large allocation that was
broken into multiple pieces) or merged pages (multiple small allocations that were merged). These tend to be rare, so we aren&#8217;t going to try to optimize
for them. We&#8217;ll just threat these as impossible to diff and copy them as is to the output buffer.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">I&#8217;m saying page, but I mean pages, plural</div>
<div class="paragraph">
<p>I&#8217;m using the term page to talk about <code>wal_page_diff_t</code>, but it will operate on multiple pages just as well. If we have a value that is big enough to
use multiple pages, we&#8217;ll treat it as a single long page, and not as a series of consecutive pages.</p>
</div>
<div class="paragraph">
<p>This is also important because the same page may have different sizes in different transactions. Imagine that we allocate page 6 as a single page in
transaction 17. Then we free the page in transaction 18 and allocate 3 pages in transaction 19. When we recover, we need to be able to handle all
kind of permutations like that.</p>
</div>
<div class="paragraph">
<p>For that reason, in <code>wal_recover()</code> we are operating at the lowest level, directly on the pages on disk, instead of utilizing higher level concepts such
as transactions or buffering.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We now write diffed records to the WAL, but we need to also handle the other side, recovery. In the last chapter, we looked at <code>wal_recover_page()</code> which
simply copied the data from the WAL to the recovery buffer. Now that we have diffs, we need to have more sophisticated behavior to manage that. You can
see the changes to <code>wal_recover_page()</code> in <a href="#wal_recover_page_09"><code>wal.c</code> - Recovering pages using either full writes or applying a diff from the previous version.</a>.</p>
</div>
<div id="wal_recover_page_09" class="listingblock">
<div class="title"><code>wal.c</code> - Recovering pages using either full writes or applying a diff from the previous version.</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_recover_page(db_t *db, pages_map_t **pages,
    wal_txn_page_t *page, void *end, const void *src, void **input) {
  size_t size  = page-&gt;number_of_pages * PAGE_SIZE;
  page_t final = {.page_num = page-&gt;page_num,
      .number_of_pages      = page-&gt;number_of_pages};
  ensure(mem_alloc_page_aligned((void *)&amp;final.address, size));
  size_t done = 0;
  try_defer(free, final.address, done);
  if (page-&gt;flags == wal_txn_page_flags_diff) {
    txn_t tx;
    ensure(txn_create(db, TX_READ, &amp;tx));
    page_t before = {.page_num = page-&gt;page_num,
        .number_of_pages       = page-&gt;number_of_pages};
    ensure(pages_get(&amp;tx, &amp;before));
    memcpy(final.address, before.address,
        page-&gt;number_of_pages * PAGE_SIZE);
    *input = wal_apply_diff(*input, end, &amp;final);
  } else {
    memcpy(final.address, src + page-&gt;offset, size);
    *input += size;
  }

  ensure(pagesmap_put_new(pages, &amp;final));
  done = 1;

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are substantial changes to <code>wal_recover_page()</code>, we now decide how to recover a page based on what kind of data we have in the WAL. If we have the
full page data (<code>wal_txn_page_flags_none</code>) we&#8217;ll use the old behavior and simply copy the data verbatim from the WAL to the new page buffer. However, if
we have a diff (<code>wal_txn_page_flags_diff</code>) we&#8217;ll create a temporary transaction and get the current data from the disk using <code>pages_get()</code>. We copy that
value to an in memory buffer and the call <code>wal_apply_diff()</code> on that buffer.
It is the <em>result</em> of the diff application on the data we copied from the disk that will be eventually written back to the disk.</p>
</div>
<div class="paragraph">
<p>There is negligible cost of opening a read transaction, as we previously saw, and that allows us to get the data from the disk easily. Even here, we use
the Copy on Write technique to avoid writing directly to the disk. We first read the data, then we modify it using <code>wal_apply_diff</code> and then we register
the modified buffer in the <code>pages</code> hash table. In <code>wal_recover_tx()</code> we&#8217;ll write all those buffers to the disk after all pages have been processed.</p>
</div>
<div class="paragraph">
<p>The fact that we are writing to the data file on each transaction means that we don&#8217;t have to deal with the in memory pages mapping that we usually have
to deal with when using transactions. During recovery, there can <em>be</em> no other work in the database, so we are free to write to the data file immediately.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Not syncing the database changes after recovery allows reasonable startup times with slow I/O.</div>
<div class="paragraph">
<p>IOPS means I/O Operations Per Second. And they are something that I constantly think about as a database developer.</p>
</div>
<div class="paragraph">
<p>Why shouldn&#8217;t we call <code>fsync()</code> after we complete all the writes to the database file? That would save us the need to run recovery again the next time, no?</p>
</div>
<div class="paragraph">
<p>That may be <em>desirable</em>, but at the database startup, we cannot afford the cost. Consider Gavran running on a HDD volume. Or
using a cloud drive with low amount of IOPS. The recovery process uses buffered memory mapped I/O <em>intentionally</em>. If we have a large WAL to go through we
may be modifying a <em>lot</em> of pages in the data file. Which will result in a <em>lot</em> of IOPS. Because we are using buffered I/O, the number of actual disk
writes is going to be minimal. But calling <code>fsync()</code> would force us to flush everything to the file&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>I have seen this exact scenario running on a 7,200 RPM hard disk where you can expect to get under 100 IOPS for random writes. And in the cloud
the situation isn&#8217;t much better. Assume that we have a 16MB WAL file and that have changes to 3,000 pages in it (you&#8217;ll likely get <em>many</em> more).
That means that it will take 30 seconds with 100 IOPS to call <code>fsync()</code>.</p>
</div>
<div class="paragraph">
<p>However, with buffered I/O and no <code>fsync()</code>, we can start the database up much faster. We&#8217;ll still need to do a checkpoint, but we can do that
at the background. In fact, that is exactly what will happen automatically the next time we&#8217;ll do a write in our current code. Later on in this book we&#8217;ll
see how we can move the checkpoint costs from the performance-critical write path.</p>
</div>
<div class="paragraph">
<p>Startup time tends to be very expensive and we need to avoid doing things that we can do later during the startup phase. Otherwise you may end up with a database
that appears to hang during load. The reasonable administrator response in this case would be to kill the process and start again, which will simply cause us to
do another expensive <code>fsync()</code> and for all intents and purposes we have a database that cannot be opened.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we understand how the changes to <code>wal_recover_page()</code> work, let&#8217;s look at how we process the diffed pages. You can see the implementation of <code>wal_apply_diff()</code>
in <a href="#wal_apply_diff"><code>wal.c</code> - Applying a binary diff on the page to recover the final state.</a>.</p>
</div>
<div id="wal_apply_diff" class="listingblock">
<div class="title"><code>wal.c</code> - Applying a binary diff on the page to recover the final state.</div>
<div class="content">
<pre class="highlight"><code>static void *wal_apply_diff(
    void *input, void *input_end, page_t *page) {
  wal_page_diff_t diff;
  while (input &lt; input_end) {
    memcpy(&amp;diff, input, sizeof(wal_page_diff_t));
    input += sizeof(wal_page_diff_t);
    if (diff.length &lt; 0) {
      memset(page-&gt;address + diff.offset, 0, (size_t)(-diff.length));
    } else {
      memcpy(page-&gt;address + diff.offset, input, (size_t)diff.length);
      input += diff.length;
    }
  }
  return input;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <a href="#wal_apply_diff"><code>wal.c</code> - Applying a binary diff on the page to recover the final state.</a> is <em>really</em> simple. Run over the <code>input</code> and either zero the memory or copy from the buffer. I&#8217;m really proud of how simple the code ended
up being. This is interesting because both <code>wal_apply_diff()</code> and <code>wal_diff_page()</code> together fits in a couple of pages. Admittedly, <code>wal_diff_page()</code> is pretty dense, but
what they bring to the table is pretty important.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">The diff is idempotent</div>
<div class="paragraph">
<p>The diff format Gavran uses has almost no requirements from the underlying system. As long as we apply the diffs in order, we can start from any state of the page since the
last checkpoint and we&#8217;ll get to the right value in the end. This is also the basis of Gavran&#8217;s requirement that the underlying storage can store either the previous version
of a write or the current one, but no random data. In practice, I know of no storage system that violate this requirement, as that is a pretty low bar to manage.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Gavran&#8217;s diff format has an important optimization for zeroed sections, but beyond that, I didn&#8217;t try to get too deep into space reduction. The diff output usually
gets rid of all the data that didn&#8217;t change, but we can do better and reduce the amount we write to disk even further.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The process of recovery must proceed to the end</div>
<div class="paragraph">
<p>During the recovery process, Gavran will run over the WAL and apply each transaction in order. When using diffed writes, we may get into some interesting situations. Let&#8217;s
consider a scenario where we have a page with the following values (each 8 bytes in size, aligned on 8 bytes, to match the diff format): <code>[0,0,0,0]</code>. We have a sequence
of transactions with the following modifications to this page:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tx no. 7 - <code>[7,0,7,0]</code> - the diff is <code>7 . . 7</code></p>
</li>
<li>
<p>Tx no. 8 - <code>[7,8,7,8]</code> - the diff is <code>. 8 . 8</code></p>
</li>
<li>
<p>Tx no. 9 - <code>[9,8,7,8]</code> - The diff is <code>9 . . .</code></p>
</li>
<li>
<p>Tx no. 10 - <code>[9,10,10,8]</code> - The diff is <code>. 10 10 .</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At the start of the recovery, the state of the page in question is <code>[9,8,7,8]</code>. We start running through the recovery process and we apply transaction no. 7. The result will
be: <code>[7, 8, 7, 8]</code>. Note that this is an <em>invalid</em> result. There was no transaction that had this value in the page. If we&#8217;ll run the entire WAL on the page,
on the other hand, we&#8217;ll get to the final result, but any values that we have in the middle are suspect and shouldn&#8217;t be used.</p>
</div>
<div class="paragraph">
<p>We are writing the changes to the data file during the recovery process using buffered I/O and read it back on the next transaction to apply further diffs. We could probably
reduce the cost of that by running the entire recovery in memory and only writing the final results. While that <em>sounds</em> like a good idea, it is very likely that it isn&#8217;t.
What happens if we have a very large WAL to process, modifying many pages? We&#8217;ll have to hold everything in memory.</p>
</div>
<div class="paragraph">
<p>The simplest solution here is to write the data to the file, and let the operating system to manage the in memory buffers as it sees fit. In the vast majority of the cases,
we&#8217;ll do pure in memory I/O, without really needing to touch the disk. The additional system calls cost that may be involved isn&#8217;t meaningful enough to matter in the grand
scheme of things.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compressing_the_transactions">Compressing the transactions</h3>
<div class="paragraph">
<p>I&#8217;m spending a lot of time in this chapter on reducing the amount of data that we write to the WAL, why is that? I/O is <em>expensive</em>, as in <em>really</em>
expensive. Reading a 4KB value from a <em>good</em> SSD will take about 150 μs (microseconds), in comparison compressing the same 4KB will take 8 μs.
The source is <a href="https://gist.github.com/jboner/2841832">Latency Numbers that Every Programmer Should Know</a>. For durable writes, the situation is <em>much</em>
worse.</p>
</div>
<div class="paragraph">
<p>Interestingly enough, the size of the write doesn&#8217;t matter all that much, what matter is the <em>scale</em>. Writing 8KB or 16KB makes very little difference
when we are talking about durable writes. My assumption is that we are looking at sequential write speeds and we use the same block or
segment in the disk, so there isn&#8217;t really much of a difference between the sizes. Writing 256KB instead of 1MB, on the other hand, is absolutely noticeable in
terms of performance.</p>
</div>
<div class="paragraph">
<p>Using diffs can reduce the amount of data we write significantly, but we can do better by adding compression to the mix. Our diff format is actually
<em>designed</em> to be compressed, that is why I didn&#8217;t try to squeeze it too much in terms of bytes taken. The nice thing about compression is that it will
remove duplication. If we have writes that are big enough to benefit significantly from compression, it is <em>very</em> likely that we&#8217;ll have duplication
and get good compression ratio.</p>
</div>
<div class="paragraph">
<p>The typical algorithms used for data compression in databases are Lz4, Snappy and Zstd. Snappy is optimized for speed over compression ratio, but LZ4 and Zstd
are both better in compression ratio <em>and</em> speed these days. Snappy&#8217;s main advantage is decompression speed, but that isn&#8217;t a major consideration for
me. I assume that we&#8217;ll rarely, if ever, need to actually recover from the WAL during normal operations.</p>
</div>
<div class="paragraph">
<p>Lz4 is typically better in terms of compression and decompression speed and typically and has better compression ratios. It has a size
limitation of about 1.9GB, however. That is a problem because I want to support transactions of any size. In Voron, we use LZ4 and added support
for compressing very large transactions 1.9GB at a time.</p>
</div>
<div class="paragraph">
<p>Zstd is in the same range as Lz4 in terms of compression speed but can offer better compression ratio. It can also compress values of any size,
meaning we don&#8217;t need to write any code to manage very large transactions. Because of those reasons, I choose to use Zstd as the compression
algorithm.</p>
</div>
<div class="paragraph">
<p>To enable compression, we need to modify <code>wal_prepare_txn_buffer()</code>, as you can see in <a href="#wal_prepare_txn_buffer_09"><code>wal.c</code>  - Compressing the transaction&#8217;s buffer</a>. Yopu</p>
</div>
<div id="wal_prepare_txn_buffer_09" class="listingblock">
<div class="title"><code>wal.c</code>  - Compressing the transaction&#8217;s buffer</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_prepare_txn_buffer(
    txn_state_t *tx, wal_txn_t **txn_buffer) {
  uint64_t pages = tx-&gt;modified_pages-&gt;count;
  // <b class="conum">(1)</b>
  size_t tx_header_size =
      sizeof(wal_txn_t) + pages * sizeof(wal_txn_page_t);
  uint64_t total_size =
      (TO_PAGES(tx_header_size) + pages) * PAGE_SIZE;
  size_t cancel_defer = 0;
  wal_txn_t *wt;
  ensure(mem_alloc_page_aligned((void *)&amp;wt, total_size));
  try_defer(free, wt, cancel_defer);
  memset(wt, 0, total_size);
  wt-&gt;number_of_modified_pages = pages;
  wt-&gt;tx_id                    = tx-&gt;tx_id;
  void *end                    = wal_setup_transaction_data(
      tx, wt, ((char *)wt) + tx_header_size);
  // <b class="conum">(2)</b>
  end = wal_compress_transaction(
      wt, (char *)wt + sizeof(wal_txn_t), end);
  // <b class="conum">(3)</b>
  wt-&gt;tx_size              = (uint64_t)((char *)end - (char *)wt);
  wt-&gt;page_aligned_tx_size = TO_PAGES(wt-&gt;tx_size) * PAGE_SIZE;
  // <b class="conum">(4)</b>
  memset(((void *)wt) + wt-&gt;tx_size, 0,
      wt-&gt;page_aligned_tx_size - wt-&gt;tx_size);

  *txn_buffer  = wt;
  cancel_defer = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are no longer trying to get the <code>tx_header_size</code> to be page aligned, we&#8217;ll compact it as much as possible, instead.</p>
</li>
<li>
<p>New code, calling <code>wal_compress_transaction()</code> to compress the transaction.</p>
</li>
<li>
<p>Because of diffing and compressing, the <code>tx_size</code> is no longer required to be a multiple of <code>PAGE_SIZE</code>, writes to the WAL are <em>always</em> page aligned,
so we record the page aligned size here.</p>
</li>
<li>
<p>Zero the memory beyond the <code>tx_size</code> to <code>page_aligned_tx_size</code>. That may contain uncompressed data and is not relevant for us, better to zero it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Aside from adding the call to <code>wal_compress_transaction()</code>, there is very little that we actually need to do here, we are dealing with raw buffers, and
the fact that we moved from holding the pages data to diffs to compressed diffs has no relevance for most of the code. Now, let&#8217;s look at how we are
actually performing the compression. You can see the details in <a href="#wal_compress_transaction"><code>wal.c</code> - Actually running the compression on the transaction data</a>.</p>
</div>
<div id="wal_compress_transaction" class="listingblock">
<div class="title"><code>wal.c</code> - Actually running the compression on the transaction data</div>
<div class="content">
<pre class="highlight"><code>static void *wal_compress_transaction(
    wal_txn_t *wt, void *start, void *end) {
  size_t input_size    = (size_t)(end - start);
  size_t required_size = ZSTD_compressBound(input_size);
  void *buffer;
  if (flopped(mem_alloc(&amp;buffer, required_size))) {
    // no memory, we'll skip compression
    errors_clear();  // recoverable, so can clear it
    return end;
  }
  defer(free, buffer);

  size_t res =
      ZSTD_compress(buffer, required_size, start, input_size, 0);
  if (ZSTD_isError(res) || res &gt;= input_size) {
    // * we got an error, let's just return uncompressed
    // * compressed bigger than input? skip it
    return end;
  }
  wt-&gt;flags = wal_txn_flags_compressed;
  memcpy(start, buffer, res);
  return start + res;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>wal_compress_transaction()</code> we compute the size of the transaction and then what would be the maximum size of the data with compression. A surprising
issue that we have to account for is that compressing a buffer may actually require <em>more</em> data than the original buffer. It&#8217;s easiest to see that by
compressing some data twice. There is <em>some</em> overhead to compression. In the diff example from before and see that we use 8 bytes for offset and length,
for example. Many compression routines have similar structure (more efficient, of course, but you still need some space).</p>
</div>
<div class="paragraph">
<p>You might want to read <a href="http://matt.might.net/articles/why-infinite-or-guaranteed-file-compression-is-impossible/">Impossibly good compression</a> for details
on why that is the case. For our purposes, I&#8217;ll just note that we need to handle this scenario.</p>
</div>
<div class="paragraph">
<p>We allocate a buffer big enough to hold the compressed data and run the compression itself. If we failed to allocate the memory, failed to compress or if
the compressed size is bigger than the input&#8217;s size, we return immediately and the <code>wal_txn_t</code> remained marked as non compressed. If, however, we are able
to gain space reduction from the compression, we&#8217;ll mark the WAL transaction as <code>wal_txn_flags_compressed</code> and copy the compressed data from the compressed
buffer to the transaction&#8217;s buffer. The result of this function is the new end of the transaction buffer.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Memory allocation costs</div>
<div class="paragraph">
<p>We are allocating a buffer for the transaction and another buffer for the compression. In general, for high performance work, we need to police our allocations
because memory allocation and de-allocations are a common cause for performance issues. I&#8217;m going to write the simplest code that I can write right now and
then use the benchmarks to guide me on how to fix this.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_compress_transaction()</code> marks the transaction as compressed if it was able to reduce the size of the input. That will be relevant when we
need to recover from the transaction. This is done in the <code>wal_validate_transaction()</code> function shown earlier in <a href="#wal_validate_transaction"><code>wal.c</code> - Verifying the integrity of the transaction has as part of the database recovery</a> using the
<code>wal_decompress_transaction()</code> function. The details are shown in <a href="#wal_decompress_transaction"><code>wal.c</code> - Support decompressions of transaction buffers during recovery</a>. It is important to note that we decompress the data <em>after</em>
we validate the hash on the transaction buffer.</p>
</div>
<div id="wal_decompress_transaction" class="listingblock">
<div class="title"><code>wal.c</code> - Support decompressions of transaction buffers during recovery</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_decompress_transaction(
    reusable_buffer_t *buffer, wal_txn_t *in, wal_txn_t **txp) {
  // <b class="conum">(1)</b>
  if (in-&gt;flags == wal_txn_flags_none) {
    *txp = in;
    return success();
  }
  // <b class="conum">(2)</b>
  size_t required_size =
      ZSTD_getDecompressedSize((void *)in + sizeof(wal_txn_t),
          in-&gt;tx_size - sizeof(wal_txn_t)) +
      sizeof(wal_txn_t);
  if (required_size &gt; buffer-&gt;size) {
    ensure(mem_realloc(&amp;buffer-&gt;address, required_size));
    buffer-&gt;size = required_size;
  }
  // <b class="conum">(3)</b>
  size_t res = ZSTD_decompress(buffer-&gt;address + sizeof(wal_txn_t),
      required_size - sizeof(wal_txn_t),
      (void *)in + sizeof(wal_txn_t),
      in-&gt;tx_size - sizeof(wal_txn_t));
  if (ZSTD_isError(res)) {
    const char *zstd_error = ZSTD_getErrorName(res);
    failed(ENODATA, msg("Failed to decompress transaction"),
        with(in-&gt;tx_id, "%lu"), with(zstd_error, "%s"));
  }
  // <b class="conum">(4)</b>
  memcpy(buffer-&gt;address, in, sizeof(wal_txn_t));
  *txp            = buffer-&gt;address;
  (*txp)-&gt;tx_size = buffer-&gt;used = res + sizeof(wal_txn_t);
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the transaction buffer is not compressed, there is nothing to do here.</p>
</li>
<li>
<p>Compute the required size for decompression and make sure that we have a large enough buffer for it.</p>
</li>
<li>
<p>Decompress to the buffer, note that we start the decompression a bit after the start of the buffer, to leave room for the <code>wal_txn_t</code> transaction header.</p>
</li>
<li>
<p>Copy the <code>wal_txn_t</code> transaction header from the original buffer to the start of the decompressed one.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Unlike before, we aren&#8217;t going to allocate and free a buffer in the <code>wal_decompress_transaction()</code> function. This is because we need to access the contents of the
buffer outside of this function. To enable that scenario, we use the <code>address</code> field in the <code>reusable_buffer_t</code> we are passed. This allows us to keep the buffer
for the duration of the recovery process. Multiple recovery operations are likely to use the same underlying buffer, saving us the cost of allocations.
I&#8217;ve added <code>defer(free, recovery_state.tmp_buffer.address);</code> to the <code>wal_recover()</code> function to handle the releasing of this buffer.</p>
</div>
<div class="paragraph">
<p>And that is about it, we are now able to compress the WAL transactions as we write them and significantly reduce the overall I/O that we need in most cases.
Adding the diffs for the process, we have lightened our I/O budget in the critical path. The cost of committing a transaction is lowered, because we trade I/O time
for CPU time. From real world usage, I&#8217;ll note that in many cases we are able to reduce the size of the transaction modifications by a <em>lot</em>. Such tradeoffs aren&#8217;t
<em>always</em> a good idea, but in this case, they have a big impact.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit tests</h3>
<div class="paragraph">
<p>Testing features such as compression, page diffing or verifying transaction are hard to write. We are not testing the functionality of the system, but
the <em>manner</em> in which it acts. As you can see in the tests, that means that I have to rely on testing by inference. I&#8217;m afraid that the tests are starting to get a
bit long in this case.</p>
</div>
<div class="paragraph">
<p>There is some amount of non trivial setup that we have to go through in order to properly test some scenarios, and C isn&#8217;t the nicest language
to express that. Nevertheless, the tests has been absolutely invaluable in figuring out where stuff breaks or does something that I didn&#8217;t expect. I&#8217;m running all
the tests with <code>valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --error-exitcode=1 --exit-on-first-error=yes</code>, which means that aside from testing
functionality, I&#8217;m also testing that we don&#8217;t step on any memory that we don&#8217;t own.</p>
</div>
<div class="paragraph">
<p>You can see the tests in <a href="#test_09"><code>test.c</code> - Unit testing complex interactions with the WAL</a>. Note that there are some tricks that I had to employ here. Testing of WAL truncation or corruption was actually hard, because of
WAL diffing and compression, we write 8KB per transaction to the WAL but the actual transaction data is only on the start of that. Most of the rest is zeroed. I was
very confused for a while when I cut the file size of the WAL in half and the recovery proceeded normally. That was because we extend the size of the WAL file when we
open it to the specified <code>wal_size</code>. That means that the new data is zero extended. Because the last portion of the transaction was already zeroed, it passed validation
and was properly recovered.</p>
</div>
<div class="paragraph">
<p>I&#8217;m using writes with random data (cannot be compressed) in order to get reasonable size of the WAL so I can properly write bad data in meaningful places and truncate
the WAL to get the right errors.</p>
</div>
<div id="test_09" class="listingblock">
<div class="title"><code>test.c</code> - Unit testing complex interactions with the WAL</div>
<div class="content">
<pre class="highlight"><code>static result_t write_to_wal_only(
    const char* path, uint64_t* last_wal_position) {
  db_t db;
  db_options_t options = {.minimum_size = 4 * 1024 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  defer(db_close, db);

  txn_t rtx;
  ensure(txn_create(&amp;db, TX_READ, &amp;rtx));
  //  intentionally leaking to prevent data file writes
  // defer(txn_close, rtx);
  txn_t wtx;
  ensure(txn_create(&amp;db, TX_WRITE, &amp;wtx));
  defer(txn_close, wtx);
  for (size_t i = 3; i &lt; 10; i++) {
    page_t p = {.page_num = i};
    ensure(txn_raw_modify_page(&amp;wtx, &amp;p));
    // random data prevents compression
    randombytes_buf(p.address, PAGE_SIZE);
  }
  ensure(txn_commit(&amp;wtx));
  *last_wal_position = db.state-&gt;wal_state.files[0].last_write_pos;
  return success();
}

static result_t assert_no_content(const char* path) {
  db_t db;
  db_options_t options = {.minimum_size = 4 * 1024 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  defer(db_close, db);
  txn_t rtx;
  ensure(txn_create(&amp;db, TX_READ, &amp;rtx));
  defer(txn_close, rtx);
  char zero[PAGE_SIZE] = {0};
  for (size_t i = FIRST_USABLE_PAGE; i &lt; 10; i++) {
    page_t p = {.page_num = i};
    ensure(txn_raw_get_page(&amp;rtx, &amp;p));
    ensure(memcmp(zero, p.address, PAGE_SIZE) == 0);
  }
  return success();
}

describe(diff_and_compression) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("corruption of WAL will not apply transactions") {
    uint64_t last_wal_pos;
    assert(write_to_wal_only("/tmp/db/try", &amp;last_wal_pos));
    // corrupt the WAL
    file_handle_t* handle;
    assert(pal_create_file(
        "/tmp/db/try-a.wal", &amp;handle, pal_file_creation_flags_none));
    char* buffer = "snow";
    assert(pal_write_file(handle, last_wal_pos - 12, buffer, 4));
    assert(pal_close_file(handle));

    assert(assert_no_content("/tmp/db/try"));
  }

  it("truncation of WAL will skip transactions") {
    uint64_t last_wal_pos;
    assert(write_to_wal_only("/tmp/db/try", &amp;last_wal_pos));
    // truncate the WAL
    file_handle_t* handle;
    assert(pal_create_file(
        "/tmp/db/try-a.wal", &amp;handle, pal_file_creation_flags_none));
    assert(pal_set_file_size(handle, 0, last_wal_pos - 10000));
    assert(pal_close_file(handle));

    assert(assert_no_content("/tmp/db/try"));
  }

  it("can recover pages of different size, small to large") {
    uint64_t page;

    {
      db_t db;
      db_options_t options = {.minimum_size = 4 * 1024 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);
      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 1};
        assert(txn_allocate_page(&amp;wtx, &amp;p, 0));
        page                                 = p.page_num;
        p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
        p.metadata-&gt;overflow.size_of_value   = PAGE_SIZE;
        p.metadata-&gt;overflow.number_of_pages = 1;
        memset(p.address, 'a', PAGE_SIZE);
        assert(txn_commit(&amp;wtx));
      }

      txn_t rtx;  // will be abandoned
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));

      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 1, .page_num = page};
        assert(txn_free_page(&amp;wtx, &amp;p));
        assert(txn_commit(&amp;wtx));
      }

      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 2};
        assert(txn_allocate_page(&amp;wtx, &amp;p, 0));
        assert(p.page_num == page);
        p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
        p.metadata-&gt;overflow.number_of_pages = 2;
        p.metadata-&gt;overflow.size_of_value   = PAGE_SIZE * 2;
        memset(p.address, 'b', PAGE_SIZE);
        memset(p.address + PAGE_SIZE, 'c', PAGE_SIZE);
        assert(txn_commit(&amp;wtx));
      }
    }

    {
      db_t db;
      db_options_t options = {.minimum_size = 4 * 1024 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);

      txn_t rtx;
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));
      page_t p = {.page_num = page};
      assert(txn_get_page(&amp;rtx, &amp;p));
      assert(p.number_of_pages == 2);
      for (size_t i = 0; i &lt; PAGE_SIZE; i++) {
        assert(*((char*)p.address + i) == 'b');
      }
      for (size_t i = 0; i &lt; PAGE_SIZE; i++) {
        assert(*((char*)p.address + i + PAGE_SIZE) == 'c');
      }
    }
  }

  it("can recover pages of different size, large to small") {
    uint64_t page;

    {
      db_t db;
      db_options_t options = {.minimum_size = 4 * 1024 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);
      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 3};
        assert(txn_allocate_page(&amp;wtx, &amp;p, 0));
        page                                 = p.page_num;
        p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
        p.metadata-&gt;overflow.size_of_value   = PAGE_SIZE;
        p.metadata-&gt;overflow.number_of_pages = 3;
        memset(p.address, 'a', PAGE_SIZE * 3);
        assert(txn_commit(&amp;wtx));
      }

      txn_t rtx;  // will be abandoned
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));

      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 3, .page_num = page};
        assert(txn_free_page(&amp;wtx, &amp;p));
        assert(txn_commit(&amp;wtx));
      }

      {
        txn_t wtx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
        defer(txn_close, wtx);
        page_t p = {.number_of_pages = 1};
        assert(txn_allocate_page(&amp;wtx, &amp;p, 0));
        assert(p.page_num == page);
        p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
        p.metadata-&gt;overflow.number_of_pages = 1;
        p.metadata-&gt;overflow.size_of_value   = PAGE_SIZE;
        memset(p.address, 'b', PAGE_SIZE);
        assert(txn_commit(&amp;wtx));
      }
    }

    {
      db_t db;
      db_options_t options = {.minimum_size = 4 * 1024 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);

      txn_t rtx;
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));
      page_t p = {.page_num = page};
      assert(txn_get_page(&amp;rtx, &amp;p));
      assert(p.number_of_pages == 1);
      for (size_t i = 0; i &lt; PAGE_SIZE; i++) {
        assert(*((char*)p.address + i) == 'b');
      }
    }
  }
  it("will compress transactions") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t wtx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
    defer(txn_close, wtx);
    uint64_t initial = db.state-&gt;wal_state.files[0].last_write_pos;
    for (size_t i = 3; i &lt; 10; i++) {
      page_t p = {.page_num = i};
      assert(txn_raw_modify_page(&amp;wtx, &amp;p));
      memset(p.address, 'a' + (char)i, PAGE_SIZE);
    }
    assert(txn_commit(&amp;wtx));

    uint64_t final = db.state-&gt;wal_state.files[0].last_write_pos;
    assert((final - initial) == PAGE_SIZE);
  }

  it("will diff data") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    {  // write random data, cannot be compressed
      txn_t wtx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
      defer(txn_close, wtx);
      for (size_t i = 3; i &lt; 10; i++) {
        page_t p = {.page_num = i};
        assert(txn_raw_modify_page(&amp;wtx, &amp;p));
        randombytes_buf(p.address, PAGE_SIZE);
      }
      assert(txn_commit(&amp;wtx));
    }
    uint64_t initial = db.state-&gt;wal_state.files[0].last_write_pos;

    {
      txn_t wtx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
      defer(txn_close, wtx);
      for (size_t i = 3; i &lt; 10; i++) {
        page_t p = {.page_num = i};
        assert(txn_raw_modify_page(&amp;wtx, &amp;p));
        strcpy(p.address, "Hello Gavran");
      }
      assert(txn_commit(&amp;wtx));
    }

    uint64_t final = db.state-&gt;wal_state.files[0].last_write_pos;
    // if we didn't diff the data, the random values
    // will ensure that we can't compress well, so we
    // test that diff works in this manner
    assert((final - initial) == PAGE_SIZE);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
    <ul style="list-style-type: none;">
        <li><a class="footer-text" href="../index.html">Table of contents</a></li>
        <li><a class="footer-text" href="./ch08.html">Previous chapter</a></li>
        <li><a class="footer-text" href="./ch10.html">Next chapter</a></li>
    </ul>
</div>
</body>
</html>