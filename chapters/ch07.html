<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Implementing ACID transactions</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_implementing_acid_transactions">Implementing ACID transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ACID stands for Atomic, Consistent, Isolated and Durable. We have a (very limited) form of atomicity in our transactions right now, because we only write the changes
in the commit. That isn&#8217;t nearly enough. We want to allow concurrent transactions to operate transparently, which means that we have to define <em>how</em> they will operate.</p>
</div>
<div class="paragraph">
<p>Gavran is going to implement a model called single writer / concurrent readers. In this model, we split the transactions into two modes. We have read transactions
and a write transaction. At any given point in time, we may have any number of read transactions but only a single write transaction. Supporting multiple write
transactions is usually something that you need to do if you have a chatty network interface, and as embedded database, that is not required for Gavran. We already
have the API for that with <code>TX_WRITE</code> and <code>TX_READ</code> flags being used to indicate what type of transaction we have. We aren&#8217;t <em>using</em> them at the moment, but the API
is already there.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Single write transaction vs. Concurrent writers</div>
<div class="paragraph">
<p>Most embedded databases implement some form of single write transactions. LMDB, Sqlite, LevelDB, RocksDB and Voron all share this design decision. Berkley DB has a similar
limitation, but with Berkley DB, you can only have a single write transaction, with no concurrent read transactions.</p>
</div>
<div class="paragraph">
<p>Databases such as MySQL or PostgreSQL has the notion of concurrent write transactions, but they use a very different model. In a network database with
transactions that involve multiple network round trips, the latency is too high to allow a single write transaction. You have to have concurrent ones and
deal with all the locking issues that this entails.</p>
</div>
<div class="paragraph">
<p>The problem with concurrent write transactions is that they require that you&#8217;ll implement locking.  In
<a href="https://dl.acm.org/doi/full/10.1145/3226595.3226635">OLTP Through the Looking Glass, and What We Found There</a>, about 30% of the overall performance goes
to locking and latching to manage concurrent writers. A single threaded solution can actually be faster.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>With concurrent readers, we need to decide on the concurrency strategy for Gavran. Take a look at <a href="#tx-timeline">A timeline of concurrent read transactions and a write transaction</a>, where we show a timeline of a few transactions.</p>
</div>
<div id="tx-timeline" class="imageblock">
<div class="content">
<img src="../imgs/tx-timeline.png" alt="tx timeline">
</div>
<div class="title">Figure 1. A timeline of concurrent read transactions and a write transaction</div>
</div>
<div class="paragraph">
<p>Read transaction no. 1 in <a href="#tx-timeline">A timeline of concurrent read transactions and a write transaction</a> was started after the write transaction and ended after the write transaction was committed. Read transaction no. 2 was created
before the write transaction and closed afterward. Only read transaction no. 3 was created after the write transaction commit. Only the third transaction
is going to be able to see the modifications made by the write transaction. The other two transactions are frozen at the time of their creation, seeing
unchanging data of the last transaction that has committed when they were opened.</p>
</div>
<div class="paragraph">
<p>Gavran is going to implement <strong>snapshot isolation</strong> for transactions. Once a transaction is opened, it will have a consistent and unchanging view of the
database. A write transaction commit will only impact <em>later</em> transactions.</p>
</div>
<div class="paragraph">
<p>This behavior is the first task in the road for ACID, the question is, how are we going to implement it? We already have <em>some</em> of it down. While a
transaction is running, other transactions are unaware of the changes that it is making because we use Copy on Write. What if we would extend that
approach a bit and see where it takes us?</p>
</div>
<div class="paragraph">
<p>Consider the following timeline of operations, which shows what we have now.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write tx is created</p>
</li>
<li>
<p>Read tx is created</p>
</li>
<li>
<p>Write tx modifies page 2</p>
</li>
<li>
<p>Read tx reads page 2, see no changes (the data is held in buffer private to the write tx)</p>
</li>
<li>
<p>Write tx commits &amp; closed</p>
</li>
<li>
<p>Read tx reads page 2, see the changes that happened because <code>txn_commit()</code> wrote it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That is the <em>current</em> behavior of Gavran, and it is almost where we want it to be. The only change in behavior we need is that when the write transaction
commits, already opened transactions will <em>not</em> see the changes. How can we implement this? Well, the reason that they can see the changes is that
we write them to the file, which is shared. What would happened if we <em>won&#8217;t</em> write to the file? Let&#8217;s find out.</p>
</div>
<div class="sect2">
<h3 id="_implementing_isolation_between_transactions">Implementing isolation between transactions</h3>
<div class="paragraph">
<p>I&#8217;m afraid that I had to touch quite a few locations for this to work. I&#8217;m going to show them in pieces, so we can paint the whole picture. The idea behind
transaction in Gavran is that the act that expose the data modified by the transaction to other transactions is writing the data to the data file.
In that case, a transaction that reads a page from the data file may observe a value from another transaction.</p>
</div>
<div class="paragraph">
<p>The solution to this is simple, let&#8217;s avoid writing the data to the data file entirely. Instead, when we commit a transaction, we&#8217;ll register the modified
pages to be written at a later date. A new transaction will be able to access the hash table of modified pages. When the new transaction needs to read a
page, it will get it from the previous transactions hash table, thus getting the latest version.
Existing transactions, on the other hand, will not have access to the updated hash table and will continue reading the pages directly from the data file.</p>
</div>
<div class="paragraph">
<p>When all the transactions that were started before the write transaction commit are done, we know that all the running transactions are going to look at
the <em>modified</em> pages in memory, thus no one is observing the data file. We are going to take advantage of this and write the data to the data file at
that point.
We can then clear the hash table from the in memory copy and have new transactions go back to reading directly from the data file.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Thread safety, what&#8217;s that?</div>
<div class="paragraph">
<p>I&#8217;m currently building Gavran with absolutely no thread safety. That is intentional, since thread safety adds a significant complexity for the code and
require very careful setup to get working properly. I want to first get the design laid out before we start touching on additional concerns.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll have complete thread safety, mind you, but I want to add that once all the moving pieces has stopped shaking. All of that said, the design of
transactions in Gavran has been carefully selected to enable a mostly seamless transition to multi threaded usage.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We are basically going to play a shell game with the data. Now its here, not it&#8217;s not.
We&#8217;ll start by looking at the changes in <code>txn_commit()</code>, which you can see in <a href="#txn_commit_07"><code>txn.c</code> - Mark the transaction as committed and register that on the database</a>.</p>
</div>
<div id="txn_commit_07" class="listingblock">
<div class="title"><code>txn.c</code> - Mark the transaction as committed and register that on the database</div>
<div class="content">
<pre class="highlight"><code>result_t txn_commit(txn_t *tx) {
  errors_assert_empty();

  // no modification, no work to do
  if (!tx-&gt;state-&gt;modified_pages-&gt;count) return success();

  tx-&gt;state-&gt;flags  = TX_COMMITED;
  tx-&gt;state-&gt;usages = 1;

  tx-&gt;state-&gt;db-&gt;last_write_tx-&gt;next_tx = tx-&gt;state;
  tx-&gt;state-&gt;db-&gt;last_write_tx          = tx-&gt;state;

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>txn_commit()</code> is not doing much of anything now, it seems. We are marking the transaction as committed, setting the <code>usages</code> count to <code>1</code> and register
the add the transaction to the linked list on <code>db-&gt;last_write_tx</code>. We ignored that field and the <code>next_tx</code> field on the <code>txn_state_t</code> structure so far, but
now it is coming together. We can use the <code>last_write_tx</code> to track all the write transactions in the database, we&#8217;ll see why that is useful shortly. Since
the <code>txn_commit()</code> isn&#8217;t really doing much, let&#8217;s look at the next stage of the process, what is different in <code>txn_close()</code>? You can see that in &lt;txn_close_07&gt;&gt;.</p>
</div>
<div class="paragraph">
<p>Most importantly, <code>txn_commit()</code> no longer writes to the data file. We&#8217;ll need to see how the next transaction is able to read the information from the older
transaction, now that it can&#8217;t get the data from the file.</p>
</div>
<div id="txn_close_07" class="listingblock">
<div class="title"><code>txn.c</code> - If the transaction wasn&#8217;t committed, free it immediately, otherwise, register it for release later</div>
<div class="content">
<pre class="highlight"><code>result_t txn_close(txn_t *tx) {
  if (!tx || !tx-&gt;state) return success();
  db_state_t *db = tx-&gt;state-&gt;db;
  if (tx-&gt;state-&gt;tx_id == db-&gt;active_write_tx) {
    db-&gt;active_write_tx = 0;
  }
  if (!(tx-&gt;state-&gt;flags &amp; TX_COMMITED)) {  // rollback
    txn_free_single_tx_state(tx-&gt;state);
    tx-&gt;state = 0;
    return success();
  }
  if (!db-&gt;transactions_to_free &amp;&amp; tx-&gt;state != db-&gt;default_read_tx)
    db-&gt;transactions_to_free = tx-&gt;state;

  if (--tx-&gt;state-&gt;usages == 0) {
    ensure(txn_gc(tx-&gt;state));
  }

  tx-&gt;state = 0;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new version of <code>txn_close()</code> doesn&#8217;t actually close the transaction. To be rather more exact, if we haven&#8217;t committed the transaction, we will release it
immediately. But otherwise, the <code>txn_close()</code> will put the transaction in the <code>transactions_to_free</code> field on the database if there isn&#8217;t any other transaction
here and call <code>txn_gc()</code> if there are no more usages of this transaction.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Transaction reuse and reference counting</div>
<div class="paragraph">
<p>The idea with the transactional system in Gavran is that we have one write transaction that on commit become the head for all the future read transactions and
the next write transaction. Once a transaction has been committed, it is the basis for all future transactions and no one can open a transaction that belongs
to an older transaction.</p>
</div>
<div class="paragraph">
<p>That is why we can set <code>transaction_to_free</code> if it isn&#8217;t already set. We <em>know</em> that if it is set, it belongs to an <em>older</em> transaction. The only exception to
this role is the <code>default_read_tx</code>, which we&#8217;ll discuss in detail later.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Since <code>txn_close()</code> isn&#8217;t going to free the <code>modified_pages</code> in the transaction, they are going to hang around in memory until we do something with them. That
is the responsibility of <code>txn_create()</code>, which you can see in <a href="#txn_create_07"><code>txn.c</code> - Modifications to the transaction creation</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s us see why we keep the pages around for committed transactions as well as the changes for <code>txn_create</code> in Listing 7.2.</p>
</div>
<div id="txn_create_07" class="listingblock">
<div class="title"><code>txn.c</code> - Modifications to the transaction creation</div>
<div class="content">
<pre class="highlight"><code>result_t txn_create(db_t *db, db_flags_t flags, txn_t *tx) {
  errors_assert_empty();
  // <b class="conum">(1)</b>
  if (flags == TX_READ) {
    tx-&gt;state = db-&gt;state-&gt;last_write_tx;
    tx-&gt;state-&gt;usages++;
    return success();
  }
  // <b class="conum">(2)</b>
  ensure(flags == TX_WRITE,
      msg("txn_create(flags) must be either TX_WRITE or TX_READ"),
      with(flags, "%d"));
  ensure(!db-&gt;state-&gt;active_write_tx,
      msg("Opening a second write transaction is forbidden"));

  size_t cancel_defer = 0;
  txn_state_t *state;
  ensure(mem_calloc((void *)&amp;state, sizeof(txn_state_t)));
  try_defer(free, state, cancel_defer);

  ensure(pagesmap_new(8, &amp;state-&gt;modified_pages));

  state-&gt;flags           = flags;
  state-&gt;db              = db-&gt;state;
  state-&gt;map             = db-&gt;state-&gt;map;
  state-&gt;number_of_pages = db-&gt;state-&gt;number_of_pages;
  // <b class="conum">(3)</b>
  state-&gt;prev_tx             = db-&gt;state-&gt;last_write_tx;
  state-&gt;tx_id               = db-&gt;state-&gt;last_tx_id + 1;
  db-&gt;state-&gt;active_write_tx = state-&gt;tx_id;

  tx-&gt;state    = state;
  cancel_defer = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If we have a read transaction, we use the state from the <code>last_write_tx</code> and increment its usage count. No allocation is required.</p>
</li>
<li>
<p>Validating the flags parameter and ensuring that there is only ever a single write transaction.</p>
</li>
<li>
<p>New code here, setting the <code>prev_tx</code> from the <code>last_write_tx</code> for write transactions, incrementing the transaction id and marking the currently
active write transaction.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Things start to get interesting now. Read transactions now require <em>no</em> allocation or work to start. And the write transaction will set itself up to be the next
state for all future read transactions. What is actually going on in the code for implementing transactions? We now need to wire this behavior into the transaction
itself. You can see how this is done in <a href="#txn_raw_get_page_07"><code>txn.c</code> - Get a page, from the current transaction or a previous transaction or the file directly.</a>.</p>
</div>
<div id="txn_raw_get_page_07" class="listingblock">
<div class="title"><code>txn.c</code> - Get a page, from the current transaction or a previous transaction or the file directly.</div>
<div class="content">
<pre class="highlight"><code>result_t txn_raw_get_page(txn_t *tx, page_t *page) {
  errors_assert_empty();
  page-&gt;address = 0;
  if (pagesmap_lookup(tx-&gt;state-&gt;modified_pages, page))
    return success();
  // <b class="conum">(1)</b>
  txn_state_t *prev = tx-&gt;state-&gt;prev_tx;
  while (prev) {
    if (pagesmap_lookup(prev-&gt;modified_pages, page)) return success();
    prev = prev-&gt;prev_tx;
  }

  if (!page-&gt;address) {
    if (!page-&gt;number_of_pages) page-&gt;number_of_pages = 1;
    ensure(pages_get(tx, page));
  }

  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Iterating over the past transactions and try to find a modified copy of the page and only if it doesn&#8217;t exist do we go to the file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#txn_raw_get_page_07"><code>txn.c</code> - Get a page, from the current transaction or a previous transaction or the file directly.</a> shows the beauty of this approach, when we need to find a page, we start searching in the modified page map, just like before. But we are
going to look in our own map as well as the maps of <em>past transactions</em>. The <code>prev_tx</code> creates a linked list of transactions (and their modified pages) that we
can use to find the most recent version of a page. We&#8217;ll only check the data file for the page if there is no transaction in the list that has this page.</p>
</div>
<div class="paragraph">
<p>You can see how that works in <a href="#concurrent-transactions">Transactions look first at their own modify pages, then at past transactions to find the most recent version of a page.</a>, we have 3 transactions (#4, #5 and #6), each of them modified a common page as well as a page just for that particular
transaction.
Let&#8217;s see what each transaction will see when it ask for a particular page.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page 3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page 4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction #4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1000 (4)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x4000 (4)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction #5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1000 (4)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x8000 (5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA000 (5)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction #6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC000 (6)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1000 (4)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x8000 (5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA000 (5)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Looking at Transaction #6, we can see that when it accesses Page 1 from its own copy, but Page 2 will come from the copy created by Transaction #4 and
Page 3 and Page 4 will come from the copies created by Transaction #5. This allow each transaction to have its own view of the world and protect us
from data being modified while we read the data. Let&#8217;s see the changes that we need to make to <code>txn_raw_modify_page()</code> to support the new behavior, the new
behavior is shown on <a href="#txn_raw_modify_page_07"><code>txn.c</code> - Modifications to <code>txn_raw_modify_page()</code> to support the new behavior</a>.</p>
</div>
<div id="concurrent-transactions" class="imageblock">
<div class="content">
<img src="../imgs/concurrent-transactions.png" alt="concurrent transactions">
</div>
<div class="title">Figure 2. Transactions look first at their own modify pages, then at past transactions to find the most recent version of a page.</div>
</div>
<div class="paragraph">
<p>Because <code>txn_raw_modify_page()</code> is implemented using <code>txn_raw_get_page()</code>, there isn&#8217;t actually anything that we need to do. We are just going to enforce
the fact that only a write transaction can modify a page. In fact, that is the <em>only</em> check we need for this validation. Without modifying pages, there is nothing
that you can do to change Gavran&#8217;s data, after all.</p>
</div>
<div class="paragraph">
<p>The idea behind all of this work is that we have two stages in the lifetime of a write transaction. The active phase, in which you can modify pages, change things, etc.
Then there is the commit, which moves the transaction from to an immutable phase. All the modified copies of the pages we changed are now
considered immutable, a change to these pages in a future transaction will need its own copy.</p>
</div>
<div id="txn_raw_modify_page_07" class="listingblock">
<div class="title"><code>txn.c</code> - Modifications to <code>txn_raw_modify_page()</code> to support the new behavior</div>
<div class="content">
<pre class="highlight"><code>result_t txn_raw_modify_page(txn_t *tx, page_t *page) {
  errors_assert_empty();

  ensure(tx-&gt;state-&gt;flags &amp; TX_WRITE,
      msg("Read transactions cannot modify the pages"),
      with(tx-&gt;state-&gt;flags, "%d"));

  if (pagesmap_lookup(tx-&gt;state-&gt;modified_pages, page)) {
    return success();
  }

// no further changes for the rest of the function</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>txn_modify_page</code> function now checks older transactions for updated copies of the page before reading it from disk by using the <code>txn_raw_get_page()</code>. It is important to note that if the
page was found in an older transaction, we&#8217;ll create a <em>copy</em> of the page. That is because other transactions may be looking at the same copy of the page, so we need to maintain
the immutability of the data from already committed transactions. In effect, we do another Copy on Write on top of the older copy.
This approach allows us to maintain multiple <em>levels</em> of isolation in our transactions.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">MVCC - Multi version concurrency control</div>
<div class="paragraph">
<p>This style of work, when we have multiple concurrent version of the data at play, is called MVCC. This is used by databases such as LMDB, Sqlite, PostgreSQL
and Voron. The <em>manner</em> in which they achieve this ability is very different, however. If you want to read more about it,
<a href="https://ayende.com/blog/175073/voron-internals-mvcc-all-the-moving-parts">I have a post about Voron&#8217;s MVCC implementation</a>, and
<a href="https://medium.com/@kousiknath/how-mvcc-databases-work-internally-84a27a380283">this post discusses PostgreSQL, LMDB and CouchDB&#8217;s implementations</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>What about when we have <em>no</em> previous transactions? This is handled at the database startup, by <code>db_initialize_default_read_tx()</code>, which is called from <code>db_create()</code>.
You can see how this looks like in <a href="#db_initialize_default_read_tx"><code>db.c</code> - Setting up <code>default_read_tx</code> and <code>last_write_tx</code> as part of the database initialization.</a>.</p>
</div>
<div id="db_initialize_default_read_tx" class="listingblock">
<div class="title"><code>db.c</code> - Setting up <code>default_read_tx</code> and <code>last_write_tx</code> as part of the database initialization.</div>
<div class="content">
<pre class="highlight"><code>implementation_detail result_t
db_initialize_default_read_tx(db_state_t *db_state) {
  ensure(mem_calloc((void *)&amp;db_state-&gt;default_read_tx,
                    sizeof(txn_state_t)));
  txn_state_t *tx = db_state-&gt;default_read_tx;
  tx-&gt;modified_pages = 0;
  tx-&gt;db = db_state;
  tx-&gt;map = db_state-&gt;map;
  tx-&gt;number_of_pages = db_state-&gt;number_of_pages;
  tx-&gt;flags = TX_READ | TX_COMMITED | db_state-&gt;options.flags;
  tx-&gt;can_free_after_tx_id = UINT64_MAX;
  db_state-&gt;last_write_tx = db_state-&gt;default_read_tx;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>default_read_tx</code> is an empty transaction, it has no modified pages and it is always the oldest transaction we have. We use that to
simplify the logic and know when we need to go and read from the file directly. We need to actually create such a transaction so we will
not need to do any allocations when a user opens a read transaction.</p>
</div>
<div class="paragraph">
<p>And that is pretty much it. We have MVCC and isolation between transactions. We are well on our way to having <em>real</em> transactions. Hurray!
<a href="#mvcc"><code>test.c</code> - Using MVCC features to check a page that was modified in a write transaction created after the read transaction.</a> shows working code using this feature.</p>
</div>
<div class="paragraph">
<p>As you can see in <a href="#mvcc"><code>test.c</code> - Using MVCC features to check a page that was modified in a write transaction created after the read transaction.</a>, <code>rtx</code> was created after <code>wtx</code>, but it isn&#8217;t aware of anything that happened inside <code>wtx</code>, even after the commit of <code>wtx</code>.
If we want to see the changes in <code>wtx</code>, we need to create a <em>new</em> transaction, one created <em>after</em> the commit of <code>wtx</code>.</p>
</div>
<div class="paragraph">
<p>Congratulation, we now have <strong>snapshot isolation</strong> working.</p>
</div>
<div id="mvcc" class="listingblock">
<div class="title"><code>test.c</code> - Using MVCC features to check a page that was modified in a write transaction created after the read transaction.</div>
<div class="content">
<pre class="highlight"><code>static result_t allocate_and_write_in_page(
    txn_t* tx, uint64_t* page_num) {
  page_t page = {.number_of_pages = 1};
  ensure(txn_allocate_page(tx, &amp;page, 0));
  page.metadata-&gt;overflow.page_flags      = page_flags_overflow;
  page.metadata-&gt;overflow.number_of_pages = 1;
  const char* msg                         = "Hello Gavran";
  strcpy(page.address, msg);
  *page_num = page.page_num;
  return success();
}

static result_t mvcc(const char* path) {
  db_t db;
  db_options_t options = {.minimum_size = 4 * 1024 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  defer(db_close, db);
  // <b class="conum">(1)</b>
  txn_t wtx;
  ensure(txn_create(&amp;db, TX_WRITE, &amp;wtx));
  defer(txn_close, wtx);
  uint64_t page_num;
  ensure(allocate_and_write_in_page(&amp;wtx, &amp;page_num));
  // <b class="conum">(2)</b>
  txn_t rtx;
  ensure(txn_create(&amp;db, TX_READ, &amp;rtx));
  defer(txn_close, rtx);
  // <b class="conum">(3)</b>
  ensure(txn_commit(&amp;wtx));
  ensure(txn_close(&amp;wtx));

  // <b class="conum">(4)</b>
  page_t rp = {.page_num = page_num};
  ensure(txn_get_page(&amp;rtx, &amp;rp));
  ensure(*(char*)rp.address == 0,
      msg("Cannot see data from later transactions"));
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creating a write transaction and modifying a page.</p>
</li>
<li>
<p>Creating a read transaction (<strong>before</strong> committing the write transaction), none of the write transaction changes will be visible to the
read transaction.</p>
</li>
<li>
<p>Committing the write transaction, which does not change what the read transaction can see.</p>
</li>
<li>
<p>There is nothing to see here, this transaction cannot see changes that happened after it was started.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_writing_to_disk_again">Writing to disk again</h3>
<div class="paragraph">
<p>The approach we used is pretty elegant, we get to use Copy on Write to automatically maintain a consistent view of the world even when there
are ongoing changes. It is also <em>highly</em> problematic, because we haven&#8217;t addressed a number of issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When can we write the data to the data file?</p>
</li>
<li>
<p>When can we <code>free</code> the memory that we use for Copy on Write?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As it currently stands, we have a transient dataset as well as a memory leak. And as we have more and more transactions, the need to iterate
over the past transactions is going to make our code slower and slower. We need some way to clean this up, so we need to decide when we can
write to the disk. Let&#8217;s take a look at <a href="#read-and-write-txs">At the top, committed write transactions, at the bottom, read transactions that refers to them</a> and see what we can do about this issue.</p>
</div>
<div id="read-and-write-txs" class="imageblock">
<div class="content">
<img src="../imgs/read-and-write-txs.png" alt="read and write txs">
</div>
<div class="title">Figure 3. At the top, committed write transactions, at the bottom, read transactions that refers to them</div>
</div>
<div class="paragraph">
<p>What we can see in <a href="#read-and-write-txs">At the top, committed write transactions, at the bottom, read transactions that refers to them</a> is that <em>all</em> the read transactions belong to Transaction 4 or higher. There are no read transactions associated
with Transaction 3. What does this mean? It means that we can be sure that no transaction is going to to try to read the data from the file
for the pages modified by Transaction 3.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How can we be sure of the isolation?</div>
<div class="paragraph">
<p>In <a href="#read-and-write-txs">At the top, committed write transactions, at the bottom, read transactions that refers to them</a>, there are no active transactions that use Transaction 3 as a base. We take the opportunity to write any changes that happened
in Transaction 3 or before that to disk, but is it safe to do so?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that Transaction 3 modified Page 7. Because each new transaction will search earlier transactions
for the most recent modified copy of a page, it means that once there are no read transactions using Transaction 2 as a base, any
transaction that attempts to read from Page 7 will <em>have</em> to get either the copy maintained by Transaction 3 or a later copy by a later transaction.</p>
</div>
<div class="paragraph">
<p>Regardless of what option is actually in effect, we can be sure that for <em>the pages modified by Transaction 3 (and earlier transactions)</em>
no active transaction is going to look at the pages in the file. That means, in turn, that we have a chance to write those pages to disk
without having to do any additional work.</p>
</div>
</div>
</div>
<div id="txn_gc" class="listingblock">
<div class="title"><code>txn.c</code> - The <code>txn_gc()</code> will write to disk pages from transactions that are no longer referenced and free orphaned transactions.</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_gc(txn_state_t *state) {
  // <b class="conum">(1)</b>
  db_state_t *db              = state-&gt;db;
  state-&gt;can_free_after_tx_id = db-&gt;last_tx_id + 1;
  // <b class="conum">(2)</b>
  txn_state_t *latest_unused = state-&gt;db-&gt;default_read_tx;
  if (latest_unused-&gt;usages)  // tx using the file directly
    return success();
  // <b class="conum">(3)</b>
  while (
      latest_unused-&gt;next_tx &amp;&amp; latest_unused-&gt;next_tx-&gt;usages == 0) {
    latest_unused = latest_unused-&gt;next_tx;
  }
  if (latest_unused == db-&gt;default_read_tx) {
    return success();  // no work to be done
  }
  // <b class="conum">(4)</b>
  db-&gt;oldest_active_tx = latest_unused-&gt;tx_id + 1;
  // no one is looking, can release immediately
  if (latest_unused == db-&gt;last_write_tx) {
    latest_unused-&gt;can_free_after_tx_id = db-&gt;last_tx_id;
  }
  // <b class="conum">(5)</b>
  ensure(txn_merge_unique_pages(latest_unused));
  ensure(txn_write_state_to_disk(latest_unused));
  txn_free_registered_transactions(db);
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A transaction can be freed once all the <em>existing</em> transactions in the system at the time of it was closed has been also closed.
We manage that by allow to free the transaction once the most up to date transaction is no longer active.</p>
</li>
<li>
<p>The <code>default_read_tx</code> is always the oldest transaction, we start scanning unused transaction from it. If there are any transactions
which are based on the <code>default_read_tx</code>, it means that they are reading directly from the file, and we have to wait for them to be
closed as well.</p>
</li>
<li>
<p>An unused transaction is one whose <code>usages</code> is zeroed. We iterate through the transactions list in their creation order to find the
newest transaction that has zero <code>usages</code> <em>and</em> all its predecessors also have zero <code>usages</code>.</p>
</li>
<li>
<p>We set the oldest active transaction on the database and check if this is the last transaction in the system. If this is the last
transaction and no one is looking, we can free it immediately instead of waiting for the next transaction.</p>
</li>
<li>
<p>Now that we know what is the latest unused transaction, we can clean it up.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At the point in time shown in <a href="#read-and-write-txs">At the top, committed write transactions, at the bottom, read transactions that refers to them</a>, it would be safe to write all the pages from transaction 3 or lower to the data file. It wouldn&#8217;t
be possible for us to <em>release</em> the transaction yet, however. The other transactions may still refer to the pages that it holds. We would
need to wait until all of <em>those</em> transactions are closed before we can free the memory held by those transactions.</p>
</div>
<div class="paragraph">
<p>In other words, we have two events that we need to consider here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing the data from the transaction to the file can be done as soon as there are no transactions that are looking at that transaction
<em>or any older transaction</em>.</p>
</li>
<li>
<p>Freeing the memory from the transaction can be done after all the transactions that were open at the time that we wrote to the data file
are closed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You already saw that we have <code>usages</code> field on a <code>txn_state_t</code> now. This is used to tell whatever there are any read transactions that are
using this transaction state as their base. There is also the <code>next_tx</code> field, which is used to go from each write transaction
to its successor. We use these in order to tell what is the current state of the system at large.</p>
</div>
<div class="paragraph">
<p>It is the job of <code>txn_gc()</code> to run through the active an inactive transactions and decide what we can write to the disk and what we can
free from memory. Let&#8217;s look at the code in <a href="#txn_gc"><code>txn.c</code> - The <code>txn_gc()</code> will write to disk pages from transactions that are no longer referenced and free orphaned transactions.</a> and then we&#8217;ll discuss how it works in depth.</p>
</div>
<div class="paragraph">
<p>That is a <em>lot</em> of behavior to go through, but I managed to break it down nicely to separate functions, which makes things easier.
The <code>txn_gc()</code> starts by scanning from the oldest transaction (always <code>default_read_tx</code>) and move forward by following the <code>next_tx</code> links.
The aim of this search is to find the <em>newest</em> transaction that has zero <code>usages</code>. Such a transaction is ready to be sent to disk. There are no other
viable transactions that can look at the pages that were modified by these transactions. We can safely send them to disk, then.</p>
</div>
<div class="paragraph">
<p>It is <em>very</em> common for multiple transactions to modify the same set of pages. Imagine a metadata page, for example, which will be modified
in many transactions. That means that the pages that were modified by consecutive transactions will have multiple copies in memory. That is
what MVCC is all about, after all. We don&#8217;t want to write the data to disk in transaction order, we&#8217;ll need to overwrite some pages many times
so the first thing we do is scan through the transactions list and find all the unique pages, favoring the latest version of each of them.
That is the responsibility of <code>txn_merge_unique_pages()</code>, shown in <a href="#txn_merge_unique_pages"><code>txn.c</code> - The <code>txn_merge_unique_pages()</code> updates the last unused transaction with the latest version of the pages in all unused transactions</a>.</p>
</div>
<div class="paragraph">
<p>The <code>txn_merge_unique_pages()</code> function in <a href="#txn_merge_unique_pages"><code>txn.c</code> - The <code>txn_merge_unique_pages()</code> updates the last unused transaction with the latest version of the pages in all unused transactions</a> starts from the newest transaction that is known to have zero <code>usages</code> and goes backward,
trying to find pages modified by the transactions that weren&#8217;t modified by prior writes. That helps us avoid overwriting popular pages, such as metadata pages, over and over again.</p>
</div>
<div class="paragraph">
<p>Note that we are actually re-using the hash table that is attached to the <code>txn_state_t</code> of the last unused transaction. That simplify
the amount of code that needs to be written. It is safe to change this <code>txn_state_t</code>, since we have just proven that no one else is looking
at it. Next we have <code>txn_write_state_to_disk()</code>, shown on <a href="#txn_write_state_to_disk"><code>txn.c</code> - The <code>txn_write_state_to_disk()</code> writes the modified pages to the data file</a></p>
</div>
<div id="txn_merge_unique_pages" class="listingblock">
<div class="title"><code>txn.c</code> - The <code>txn_merge_unique_pages()</code> updates the last unused transaction with the latest version of the pages in all unused transactions</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_merge_unique_pages(txn_state_t *state) {
  // state-modified_pages will have distinct set of the latest pages
  // that we want to write
  txn_state_t *prev = state-&gt;prev_tx;
  while (prev) {
    size_t iter_state = 0;
    page_t *entry;
    while (pagesmap_get_next(
        prev-&gt;modified_pages, &amp;iter_state, &amp;entry)) {
      page_t check = {.page_num = entry-&gt;page_num};
      if (pagesmap_lookup(state-&gt;modified_pages, &amp;check)) continue;

      ensure(pagesmap_put_new(&amp;state-&gt;modified_pages, entry));
      entry-&gt;address = 0;  // ownership changed, avoid double free
    }
    prev = prev-&gt;prev_tx;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There isn&#8217;t much to say about the code in <a href="#txn_write_state_to_disk"><code>txn.c</code> - The <code>txn_write_state_to_disk()</code> writes the modified pages to the data file</a>. It should be familiar to you, it used to reside in <code>txn_commit()</code> and did the same work
there. The only thing to notice here is that we are going to be running this on a <code>txn_state_t</code> that contains pages from multiple transactions.
The input of <code>txn_write_state_to_disk()</code> is the result computed by <code>txn_merge_unique_pages()</code>.</p>
</div>
<div id="txn_write_state_to_disk" class="listingblock">
<div class="title"><code>txn.c</code> - The <code>txn_write_state_to_disk()</code> writes the modified pages to the data file</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_write_state_to_disk(txn_state_t *s) {
  size_t iter_state = 0;
  page_t *current;
  while (
      pagesmap_get_next(s-&gt;modified_pages, &amp;iter_state, &amp;current)) {
    ensure(pages_write(s-&gt;db, current));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus far, the implementation has been fairly straightforward. There is one caveat that we have to handle, though. How (and when) are we going to <code>free()</code>
the memory for those transactions?</p>
</div>
</div>
<div class="sect2">
<h3 id="_memory_management_concerns">Memory management concerns</h3>
<div class="paragraph">
<p>Take a look at <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, which shows transactions 4 - 8. Of those, transactions 4 and 5 have no usages, transactions 6 and 7 have some usages
and transaction 8 is the current write transaction. You can also see the references in the transaction list.
Even though we have <code>prev_tx</code> and <code>next_tx</code>, I was careful not to call it a doubly linked list, because it isn&#8217;t, really.</p>
</div>
<div class="paragraph">
<p>There are actually two <em>separate</em> lists in play here. Sometimes they are the same, but sometimes, like in <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, they are not.</p>
</div>
<div class="paragraph">
<p>The <code>default_read_tx</code>, which is using the <code>next_tx</code> to hold a list of transactions in creation order. This is used to find the newest
transaction that has no usages and to decide what pages we can write to the disk. Once a transaction has been written to the disk,
we register that in the <code>transactions_to_free</code> field and we&#8217;ll check when we can actually <code>free</code> those transactions.</p>
</div>
<div class="paragraph">
<p>On <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, you can see the path from <code>default_read_tx</code> to <code>Transaction #4</code> and onward using the <code>next_tx</code> links. There is also
a reference from <code>transactions_to_free</code> to <code>Transaction #4</code>. However, we cannot proceed further along that list because we have the
<code>can_free_after_tx_id</code> set to 6, and that transaction is still active.</p>
</div>
<div id="tx-graph" class="imageblock">
<div class="content">
<img src="../imgs/tx-graph.png" alt="tx graph">
</div>
<div class="title">Figure 4. The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</div>
</div>
<div class="paragraph">
<p>The other way, using the <code>prev_tx</code> is used by the transactions themselves to find the newest copy of a page. Another use for that chain
is to follow back from an unused transaction to all the previous transactions so Gavran can gather all the modified pages in a set of
transactions with zero <code>usages</code>. In <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, that means going from <code>Transaction #5</code> back to <code>Transaction #4</code> and writing
the pages from both transactions at once.</p>
</div>
<div class="paragraph">
<p>If we&#8217;ll call <code>txn_gc_tx</code> on the state in <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, we&#8217;ll find that the newest transaction we can work with is <code>Transaction #5</code>.
All other transactions still have non zero <code>usages</code>, after all. We can see that in terms of active transactions, we have
<code>Transaction #6</code> and <code>Transaction #5</code>, and <code>Transaction #8</code> is a write transaction that hasn&#8217;t been committed yet.</p>
</div>
<div class="paragraph">
<p>Calling <code>txn_merge_unique_pages</code> will merge the pages that was modified in <code>Transaction #4</code> and <code>Transaction #5</code> and
<code>txn_write_state_to_disk</code> will write those pages to disk. The question is, when can we call <code>free</code> on that memory. It turns out that we
can&#8217;t, really. <code>Transaction #6</code> may need to go back into pages held by <code>Transaction #5</code>, and so on until we get to the end.</p>
</div>
<div class="paragraph">
<p>We can only free a transaction once <em>all</em> the transactions that were opened at the time of the transaction that we are closing are also
closed. This is why we set the <code>can_free_after_tx_id</code> to a transaction <em>after</em> the last transaction on the database.</p>
</div>
<div class="paragraph">
<p>The code in <code>txn_try_reset_tx_chain</code> is there to handle what happens when there are no longer any transactions at all. At which point
we reset the whole system back to its initial state. Finally, in <code>txn_free_registered_transactions</code> we run over the list of
<code>transactions_to_free</code> and free them if we can.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What about uncommitted transactions?</div>
<div class="paragraph">
<p>In <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>, we have an uncommitted transaction, <code>Transaction #8</code>. You can see that it is connected to the previous transactions
via <code>prev_tx</code> to <code>Transaction #7</code>. That is done so <code>Transaction #8</code> can get the latest version of pages modified by
<code>Transaction #7</code> or earlier.</p>
</div>
<div class="paragraph">
<p>However, <code>Transaction #8</code> has no transaction that points <em>to</em> it. The <code>next_tx</code> field of <code>Transaction #7</code> is set to null.
Only after the commit of <code>Transaction #8</code> will Gavran wire the <code>next_tx</code> and make <code>Transaction #8</code> part of the transaction
list.</p>
</div>
<div class="paragraph">
<p>That make it much easier to handle rollbacks of transactions, we can simply <code>free</code> the transaction and any pages it modified, and
nothing else needs to be done.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>A transaction will be freed by <code>txn_free_registered_transactions</code> if the following conditions are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s <code>usages</code> is zero.</p>
</li>
<li>
<p>The <code>oldest_active_tx</code> is higher than the transaction&#8217;s <code>can_free_after_tx_id</code> value.</p>
</li>
<li>
<p>It is the first transaction in the list.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last one is important. Consider <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a> and what will happen if we&#8217;ll close all the <code>usages</code> of <code>Transaction #7</code>, at which
point the <code>can_free_after_tx_id</code> will be set to 8. <code>Transaction #6</code>, however, is still in use, and by the time it is closed, it
will be get <code>can_free_after_tx_id</code> value of 10.</p>
</div>
<div class="paragraph">
<p>Because we process the transactions <code>free</code>-s in creation order, we&#8217;ll not be able to <code>free</code> <code>Transaction #7</code> until <code>Transaction #6</code>
is also eligible for <code>free</code>. That behavior removes a huge amount of complexity from the code.</p>
</div>
<div class="paragraph">
<p>With that explanation behind us, let&#8217;s look at <a href="#txn_free_registered_transactions"><code>txn.c</code> - Implementing (careful) freeing of transaction, only when they are no longer visible to any code.</a>, which shows the code that implements this behavior.</p>
</div>
<div id="txn_free_registered_transactions" class="listingblock">
<div class="title"><code>txn.c</code> - Implementing (careful) freeing of transaction, only when they are no longer visible to any code.</div>
<div class="content">
<pre class="highlight"><code>static void txn_free_registered_transactions(db_state_t *state) {
  while (state-&gt;transactions_to_free) {
    txn_state_t *cur = state-&gt;transactions_to_free;

    if (cur-&gt;usages ||
        cur-&gt;can_free_after_tx_id &gt; state-&gt;oldest_active_tx)
      break;

    if (cur-&gt;next_tx) cur-&gt;next_tx-&gt;prev_tx = 0;

    state-&gt;transactions_to_free             = cur-&gt;next_tx;
    state-&gt;default_read_tx-&gt;next_tx         = cur-&gt;next_tx;
    state-&gt;default_read_tx-&gt;map             = cur-&gt;map;
    state-&gt;default_read_tx-&gt;number_of_pages = cur-&gt;number_of_pages;
    if (state-&gt;last_write_tx == cur)
      state-&gt;last_write_tx = state-&gt;default_read_tx;

    txn_free_single_tx_state(cur);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#txn_free_registered_transactions"><code>txn.c</code> - Implementing (careful) freeing of transaction, only when they are no longer visible to any code.</a>, after we verified that we can free a transaction, we first update the
references for of the <code>transactions_to_free</code> and <code>default_read_tx-&gt;next_tx</code> to the next item. We&#8217;ll also free any transaction that we can
free. It is possible for multiple transactions to be <code>free()</code>-ed at once when we have an old transaction that is closed after newer
transaction has already been completed.</p>
</div>
<div class="paragraph">
<p>A note about setting <code>default_read_tx-&gt;next_tx</code>, we are doing something strange here, we are traversing the <code>transactions_to_free</code> list but
update <code>default_read_tx-&gt;next_tx</code>. Why are we doing this? Compared to <code>transaction_to_free</code>, we may skip ahead in <code>default_read_tx-&gt;next_tx</code>
but we know that this is always right to do. The value of <code>default_read_tx-&gt;next_tx</code> after this is run is set to the latest valid transaction
in the system, regardless of where the lists of <code>default_read_tx-&gt;next_tx</code> and <code>transaction_to_free</code> were at the beginning of the call.</p>
</div>
<div class="paragraph">
<p>In <code>txn_free_registered_transactions()</code> we also make sure that the rest of the state of <code>default_read_tx</code> is up to date, in particular the <code>global_state</code>.
This doesn&#8217;t mean much right now, but it will come handy down the line.</p>
</div>
<div class="paragraph">
<p>With that out of the way, we are left with the actual freeing of transactions, which is shown in <a href="#txn_free_single_tx_state"><code>txn.c</code> - Actually doing the work to free a single transaction</a>.</p>
</div>
<div class="paragraph">
<p>The behavior around <code>txn_gc()</code> is complex, enough that I think that it would be a bad idea to move forward before we covered this piece of code with
a good set of tests. We&#8217;ll get to the test writing in a second. I want to look at what we have achieved and what remains to be done first.</p>
</div>
<div class="paragraph">
<p>We now have pretty much figured out how to implement Atomicity and Isolation piece of ACID. We have a single write / concurrent readers system where readers use
<em>snapshot isolation</em> model for consistency. Once a read transaction is opened, its world is frozen, as far as the transaction is concerned. At the same
time, we may create and commit write transactions and not have to do any coordination. There is a hurdle that we need to go through. Managing exactly when
we can write the data to disk and at what point we can actually free the memory is not trivial.</p>
</div>
<div id="txn_free_single_tx_state" class="listingblock">
<div class="title"><code>txn.c</code> - Actually doing the work to free a single transaction</div>
<div class="content">
<pre class="highlight"><code>implementation_detail void txn_free_single_tx_state(
    txn_state_t *state) {
  size_t iter_state = 0;
  page_t *p;
  while (pagesmap_get_next(state-&gt;modified_pages, &amp;iter_state, &amp;p)) {
    free(p-&gt;address);
  }
  free(state-&gt;modified_pages);
  free(state);
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The downside of MVCC</div>
<div class="paragraph">
<p>Using a system with MVCC is easy. You don&#8217;t need to worry about locks or contentions. The way we implemented it in Gavran means that we have full snapshot
isolation without really having to do much work at all. However&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The design we have here has a weakness that must be considered. Gavran is only able to write to the data file (and discard the Copy on Write pages) when there
are no more read transactions that reference those pages. That means that while you have a read transaction active, it is going to block Gavran from writing
to the disk anything that was written after that read transaction was opened.</p>
</div>
<div class="paragraph">
<p>In other words, if you have a long lived read transaction, you are going to stall the process of writing to disk. In practice, in embedded databases there
is rarely much need for long lived read transactions. And the issue only happens when you have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A long lived read transaction.</p>
</li>
<li>
<p>A <em>lot</em> of write transactions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It takes both issues to cause the problem to manifest, and the combination is quite uncommon. Nevertheless, it is something to be aware of. The same issue
is also present with other databases implementing MVCC.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>What we <em>don&#8217;t</em> have yet is the durability story. If we commit the transaction but have a read transaction active, nothing will be written to the disk and
we&#8217;ll end up with missing data. Even if we <em>wrote</em> to the disk, however, we are doing buffered I/O, which means that it is entirely possible for a power failure to cause us to
lose data or corrupt the data file. There is a good path forward from where we are now to get to durable system, which we&#8217;ll explore in the next chapter.
And now, let&#8217;s get to unit testing&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit tests</h3>
<div class="paragraph">
<p>Some of the tests in <a href="#test_07"><code>test.c</code> - Unit testing isolation between transactions</a> are fairly involved, I&#8217;m setting up quite a scenario in order to test the various interactions of transactions opening and closing
in various ways. They have been <em>incredibly</em> helpful in fleshing out the right behavior for Gavran. I would urge you to take a closer look at the
<code>interleaved transactions</code> test, which show some complex interactions between multiple read and write transactions. The state shown in <a href="#tx-graph">The structure of references between transactions which allows us to write them to disk and <code>free</code> them from memory.</a>
is actually the state of the <code>interleaved transactions</code> test, midway through.</p>
</div>
<div id="test_07" class="listingblock">
<div class="title"><code>test.c</code> - Unit testing isolation between transactions</div>
<div class="content">
<pre class="highlight"><code>static result_t write_and_return_read_tx(
    db_t* db, uint32_t val, txn_t* rtx) {
  txn_t wtx;
  ensure(txn_create(db, TX_WRITE, &amp;wtx));
  defer(txn_close, wtx);
  page_t p = {.page_num = 3};
  ensure(txn_raw_modify_page(&amp;wtx, &amp;p));
  *(uint32_t*)p.address = val;
  size_t done           = 0;
  ensure(txn_commit(&amp;wtx));
  ensure(txn_create(db, TX_READ, rtx));
  try_defer(txn_close, rtx, done);
  ensure(txn_close(&amp;wtx));
  done = 1;
  return success();
}

describe(transaction_tests) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("can not see changes from tx after me") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);
    uint64_t page_num;
    {
      txn_t wtx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
      defer(txn_close, wtx);
      assert(allocate_and_write_in_page(&amp;wtx, &amp;page_num));
      txn_t rtx;
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));
      defer(txn_close, rtx);
      // commit write tx
      assert(txn_commit(&amp;wtx));
      assert(txn_close(&amp;wtx));
      // check previous tx
      page_t rp = {.page_num = page_num};
      assert(txn_get_page(&amp;rtx, &amp;rp));
      assert(*(char*)rp.address == 0);
    }
    // next transaction should read it
    {
      txn_t rtx;
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));
      defer(txn_close, rtx);
      page_t rp = {.page_num = page_num};
      assert(txn_get_page(&amp;rtx, &amp;rp));
      assert(strcmp(rp.address, "Hello Gavran") == 0);
    }
  }

  it("will write to disk if no active tx prevents it") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);
    uint64_t page_num;

    {
      txn_t wtx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
      defer(txn_close, wtx);
      assert(allocate_and_write_in_page(&amp;wtx, &amp;page_num));
      txn_t rtx;
      assert(txn_create(&amp;db, TX_READ, &amp;rtx));
      defer(txn_close, rtx);
      // commit write tx
      assert(txn_commit(&amp;wtx));
      assert(txn_close(&amp;wtx));

      char* address = db.state-&gt;map.address + (page_num * PAGE_SIZE);
      assert(*address == 0);
    }
    // and now it will write to the disk
    {
      char* address = db.state-&gt;map.address + (page_num * PAGE_SIZE);
      assert(strcmp(address, "Hello Gavran") == 0);
    }
  }

  it("will NOT write to disk if with read tx active") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);
    uint64_t page_num;

    txn_t wtx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
    defer(txn_close, wtx);
    assert(allocate_and_write_in_page(&amp;wtx, &amp;page_num));
    assert(txn_commit(&amp;wtx));
    assert(txn_close(&amp;wtx));

    char* address = db.state-&gt;map.address + (page_num * PAGE_SIZE);
    assert(strcmp(address, "Hello Gavran") == 0);
  }

  it("mvcc") { assert(mvcc("/tmp/db/try")); }

  it("interleaved transactions") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);
    txn_t tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8;

    uint32_t* ptr = db.state-&gt;map.address + PAGE_SIZE * 3;

    assert(write_and_return_read_tx(&amp;db, 1, &amp;tx1));
    assert(write_and_return_read_tx(&amp;db, 2, &amp;tx2));
    assert(write_and_return_read_tx(&amp;db, 3, &amp;tx3));
    assert(write_and_return_read_tx(&amp;db, 4, &amp;tx4));
    assert(write_and_return_read_tx(&amp;db, 5, &amp;tx5));

    assert(*ptr == 0);  // nothing changed in the file yet
    assert(txn_close(&amp;tx1));
    assert(*ptr == 1);
    assert(txn_close(&amp;tx2));
    assert(*ptr == 2);  // written as expected

    assert(write_and_return_read_tx(&amp;db, 6, &amp;tx6));

    // reverse order
    assert(txn_close(&amp;tx4));
    assert(*ptr == 2);  // no change
    assert(txn_close(&amp;tx3));
    assert(*ptr == 4);  // write only the latest unused

    assert(write_and_return_read_tx(&amp;db, 7, &amp;tx7));
    assert(write_and_return_read_tx(&amp;db, 8, &amp;tx8));

    assert(txn_close(&amp;tx5));
    assert(txn_close(&amp;tx8));
    assert(txn_close(&amp;tx6));
    assert(*ptr == 6);  // midway
    assert(txn_close(&amp;tx7));
    assert(*ptr == 8);  // done
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
  <ul style="list-style-type: none;">
    <li><a class="footer-text" href="../index.html">Table of contents</a></li>
    <li><a class="footer-text" href="./ch06.html">Previous chapter</a></li>
    <li><a class="footer-text" href="./ch08.html">Next chapter</a></li>
  </ul>
</div>
</body>
</html>