<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Working with (and against) the file system</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_working_with_and_against_the_file_system">Working with (and against) the file system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Files are a wonderful abstraction, a stream of bytes that reside under name, sorted in a hierarchy. Simple enough that a child can use it, powerful enough to be
the motto of an the entire set of operating systems. "Everything is a file" is one of the defining features of Unix, but it is also an abstraction, and as such,
it is subject to <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">the Law of Leaky Abstractions</a>.</p>
</div>
<div class="paragraph">
<p>When building a storage engine, we need to have a pretty good idea about how to manage files. As it turns out, there is a lot of things that are
<a href="https://yakking.branchable.com/posts/falsehoods-programmers-believe-about-file-paths/">just wrong</a> about how we think about files.
The <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-pillai.pdf">"All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-Consistent
Applications"</a> paper tested ten applications (from SQLite to Git to PostgreSQL)
to find whatever they are properly writing to files. This paper is usually referred to as the ALICE (Application-Level Intelligent Crash Explorer) paper, after
the name of the tool created to explore failures in file system usage.</p>
</div>
<div class="paragraph">
<p>There are a <em>lot</em> of details that you need to take into account. For example, you may consider that changing a file and then calling <code>fsync()</code> will ensure that
the changes to the file are made durable, and that is correct, if you haven&#8217;t changed the file size. Because while the file data has been flushed, the file
<em>metadata</em> was not. Which may mean some fun times in the future with the debugger.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Testing actual behavior is <em>hard</em>, and the real world isn&#8217;t cooperative</div>
<div class="paragraph">
<p>If you want to build a reliable storage engine, you are going to need to develop some paranoid tendencies. Because the fact that the documentation
says something is possible or not doesn&#8217;t translate to how things really are. When you care about reliability, the file system abstraction leaks
badly. And it is hard to find a way around that.</p>
</div>
<div class="paragraph">
<p>You can simulate some errors, but the sheer variety and scope involved makes thing hard. Especially because the error that hit you may come not from
the code that you are using but several layers down. If you test errors from the file system, but the <em>file system</em> didn&#8217;t check for errors from
the block device you may end up in a funny state. And in 99.999% of the cases, it won&#8217;t matter, but you are <em>going</em> to hit that one in a billion
chance of an actual error at just the wrong time and see a broken system.</p>
</div>
<div class="paragraph">
<p>There have been a number of studies made on the topic and I think that <a href="https://danluu.com/filesystem-errors/">Daniel Luu&#8217;s summary</a> of the topic
lays a lot of the issues on the table. There is not a <em>single</em> storage hardware solution that doesn&#8217;t have failure conditions that can cause
data corruption. And file systems don&#8217;t always handle it properly.</p>
</div>
<div class="paragraph">
<p>To a large degree, we make certain assumptions about the system, then we verify them constantly. The less we demand from the bottom layers, the
more reliable we can make our system.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>LWN has some good articles on the topic of making sure that the <a href="https://lwn.net/Articles/457667/">data actually reach the disk</a> and
the <a href="https://lwn.net/Articles/351422/">complexities involved</a>. The situation is made more complex by the fact that this is depend on what OS and file system
 you use and even what <em>mode</em> you used to mount a particular drive. As the author of a storage engine, you have to deal with these details in either of two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify explicitly the support configuration, raise hell if user is attempting to use on non supported configuration.</p>
</li>
<li>
<p>Make it work across the board. Plan for failure and when it happens, have the facilities in place to recover from it.</p>
</li>
</ul>
</div>
<div id="pal-interface" class="listingblock">
<div class="title"><code>gavran/pal.h</code> - The file system interface that we&#8217;ll consume for our storage engine</div>
<div class="content">
<pre class="highlight"><code>typedef struct span {
  void *address;
  size_t size;
} span_t;

typedef struct pal_file_handle {
  union {
    int fd;
    void *handle;
  };
  char *filename;
  uint64_t size;
} file_handle_t;

// working with files
result_t pal_create_file(const char *path, file_handle_t **handle,
                         enum pal_file_creation_flags flags);
result_t pal_set_file_size(file_handle_t *handle,
                           uint64_t minimum_size,
                           uint64_t maximum_size);
result_t pal_fsync(file_handle_t *handle);
result_t pal_close_file(file_handle_t *handle);
void defer_pal_close_file(struct cancel_defer *cd);

// memory map
result_t pal_mmap(file_handle_t *handle, uint64_t offset,
                  span_t *span);
result_t pal_enable_writes(span_t *range);
void defer_pal_disable_writes(cancel_defer_t *cd);
result_t pal_unmap(span_t *range);
void defer_pal_unmap(cancel_defer_t *cd);

// reading and writing to a file
result_t pal_write_file(file_handle_t *handle, uint64_t offset,
                        const char *buffer, size_t size);
result_t pal_read_file(file_handle_t *handle, uint64_t offset,
                       void *buffer, size_t size);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because working with files is such a huge complex mess, and because it is <em>different</em> across operating systems, we&#8217;ll hide this complexity behind a
platform abstraction layer (PAL). <a href="#pal-interface"><code>gavran/pal.h</code> - The file system interface that we&#8217;ll consume for our storage engine</a> shows the core functions that the PAL expose.
The interface shown in <a href="#pal-interface"><code>gavran/pal.h</code> - The file system interface that we&#8217;ll consume for our storage engine</a> is very small and quite big at the same time. It it small to be the entire interface between a storage engine and a
file system. At the same time, there is quite a bit that is going on here.</p>
</div>
<div class="paragraph">
<p>There are two important structures that we define here: <code>span_t</code> and <code>file_handle_t</code>. The <code>span_t</code> represent a range of memory, and it is named in honor of
<code>Span&lt;T&gt;</code> from .NET. This is going to be used for memory mapping and in general to represent arbitrarily sized chunks of memory. The <code>file_handle_t</code> is going
going to be used to represent a file handle.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Cross platform considerations</div>
<div class="paragraph">
<p>On Posix, a file description is an <code>int</code>, on Windows, it is a <code>HANDLE</code>. Right now I&#8217;m focusing only on Linux support, so I won&#8217;t bother much with cross platform
compatibility at this point. But the structure is already ready to handle either option, so it should be smooth sailing.</p>
</div>
<div class="paragraph">
<p>And yes, I&#8217;m aware of "Famous last words".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The goal of this API is to allow us to do the right thing, regardless of what platform we are running on. Later on, we&#8217;ll build on top of these functions the
storage engine implementation. Let&#8217;s look at <a href="#create_and_set_file"><code>test.c</code> - Using the file API to create a file with a minimum size</a> to see how we can make use of this API to work with files.</p>
</div>
<div id="create_and_set_file" class="listingblock">
<div class="title"><code>test.c</code> - Using the file API to create a file with a minimum size</div>
<div class="content">
<pre class="highlight"><code>static result_t create_and_set_file(const char* file) {
  file_handle_t* h;
  ensure(pal_create_file(file, &amp;h, pal_file_creation_flags_none));
  defer(pal_close_file, h);
  ensure(h-&gt;size == 0);

  ensure(pal_set_file_size(h, 1024 * 128, 1024 * 128));
  ensure(h-&gt;size == 1024 * 128);

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <a href="#create_and_set_file"><code>test.c</code> - Using the file API to create a file with a minimum size</a> should ensure that at the end of the day, we have a file that has a minimum size of 8KB which will retain its size even in the case of an error or
a system crash. That sounds easy enough to do in theory, but require some dancing around to get to it. Right now I&#8217;m going to focus on Linux as the implementation
system, but we&#8217;ll get to other systems down the line.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_file_handle">Creating a file handle</h3>
<div class="paragraph">
<p>Now that we know how to <em>use</em> the API, let&#8217;s see how this is implemented. <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> shows how we open or create a file in Gavran.
It isn&#8217;t a long function, but you can see how all the different parts we built are coming together to make it (much) easier to write correct code.</p>
</div>
<div id="pal_create_file" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Opening (or creating) a file</div>
<div class="content">
<pre class="highlight"><code>result_t pal_create_file(const char *path, file_handle_t **handle_out,
                         enum pal_file_creation_flags flags) {
  errors_assert_empty();
  size_t cancel_defer = 0;

  // <b class="conum">(1)</b>
  file_handle_t *handle;
  ensure(mem_alloc((void *)&amp;handle, sizeof(file_handle_t)));
  try_defer(free, handle, cancel_defer);

  // <b class="conum">(2)</b>
  char *mutable;
  ensure(mem_duplicate_string(&amp;mutable, path));
  defer(free, mutable);
  ensure(pal_ensure_path(mutable, &amp;handle-&gt;size));

  // <b class="conum">(3)</b>
  handle-&gt;filename = realpath(path, 0);
  if (!handle-&gt;filename) {
    failed(errno, msg("Failed to resolve realpath() of file"),
           with(path, "%s"));
  }
  try_defer(free, handle-&gt;filename, cancel_defer);

  // <b class="conum">(4)</b>
  int open_flags = O_CLOEXEC | O_CREAT | O_RDWR;
  if (flags &amp; pal_file_creation_flags_durable) {
    open_flags |= O_DIRECT | O_DSYNC;
  }
  handle-&gt;fd = open(handle-&gt;filename, open_flags, S_IRUSR | S_IWUSR);
  if (handle-&gt;fd == -1) {
    failed(errno, msg("Unable to open file "),
           with(handle-&gt;filename, "%s"));
  }
  // <b class="conum">(5)</b>
  if (handle-&gt;size == 0) {  // new db
    if (!fsync_parent_directory(handle-&gt;filename)) {
      failed(EIO,
             msg("Failed to fsync parent dir on new file creation"),
             with(handle-&gt;filename, "%s"));
    }
  }

  *handle_out = handle;
  cancel_defer = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Allocate the memory for the handle and ensure that it will be freed if the function fails.</p>
</li>
<li>
<p>Create a mutable copy of the file name and then ensuring that the file exists (which requires mutable string).</p>
</li>
<li>
<p>Resolve potentially relative path to an absolute one.</p>
</li>
<li>
<p>Open the actual file, for now, you can ignore the meaning of the <code>flags</code>, we&#8217;ll discuss them later.</p>
</li>
<li>
<p>Call <code>fsync()</code> on the parent directory if this is a new file, we&#8217;ll see why this is needed shortly.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> starts by allocating a temporary string and then calling <code>pal_ensure_path</code>, which will ensure that the path to the file is valid and create it as an empty file.
It then proceeds to allocate the memory for the handle and setting up <code>try_defer()</code> to ensure that in the case of failure, we&#8217;ll free the allocated memory automatically.
We then store a copy of the <code>path</code> in the handle&#8217;s <code>filename</code> field. Note that we are doing that through <code>realpath()</code>, which will resolve relative paths, symbolic links, etc. We need
to <code>free()</code> the memory there. Because <code>realpath</code> requires a file to exists before it can resolve it, we create an empty file in <code>pal_ensure_path()</code> and use the size of the file to know
if we are dealing with an existing database or a new one.</p>
</div>
<div class="paragraph">
<p>Beyond what was already mentioned, you need to take into account users who pass invalid values (file name containing <code>/</code>, for example), <em>all</em> the intricacies of soft and
hard links, size quotas, etc. <a href="https://lwn.net/Articles/686789/">The LWN post</a> about this will probably turn your hair gray.
To keep the code size small and not overburden ourself with validation code, I&#8217;m going to state that I&#8217;m trusting the
callers of the API to have already done the validation of the data. As you can see in <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a>, we are only trying to prevent
accidents, not trying to protect against malicious input. Gavran assumes that it is called with non-malicious values (note that this is different from <em>valid</em> values)
as it is an embedded library and is meant to be used as part of your system.</p>
</div>
<div class="paragraph">
<p>There is one very important validation / setup that we run before we open the file. We call <code>pal_ensure_path()</code>, which ensure that we <em>can</em> create the file. It will create the full
directory path if needed, make sure that there isn&#8217;t a directory with the name in place and in general tidy up the place before we get started. You can see how it is implemented
in <a href="#pal_ensure_path"><code>pal.linux.c</code> - Ensuring that the provided path is valid to create a file on</a>.</p>
</div>
<div id="pal_ensure_path" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Ensuring that the provided path is valid to create a file on</div>
<div class="content">
<pre class="highlight"><code>static result_t pal_ensure_path(char *filename, uint64_t *size) {
  struct stat st;
  if (stat(filename, &amp;st) == -1) {
    if (errno != ENOENT) {
      failed(errno, msg("Unable to stat "), with(filename, "%s"));
    }
    *size = 0;
    ensure(pal_ensure_full_path(filename));
    int fd = open(filename, O_CLOEXEC | O_CREAT | O_RDWR,
                  S_IRUSR | S_IWUSR);
    if (fd == -1) {
      failed(errno, msg("Unable to create file "),
             with(filename, "%s"));
    }
    if (close(fd) == -1) {
      failed(errno, msg("Unable to close file after creating it "),
             with(filename, "%s"));
    }
  } else {
    *size = (uint64_t)st.st_size;
    if (S_ISDIR(st.st_mode)) {
      failed(EISDIR, msg("The path is a directory, expected a file "),
             with(filename, "%s"));
    }
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another responsibility that <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> has, aside from creating the full director path, is to let us know if we are creating a new file or opening an existing one. Why do we care?
We are opening the file using <code>O_CREAT</code>, so the operating system will take care of that detail for us.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Beware the paths</div>
<div class="paragraph">
<p>In <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a>, I&#8217;m keeping track of the absolute path of the file. Even if we were provided with a relative path, I&#8217;m converting that to the full one.
Why make extra work for ourselves? I could have simply called <code>strdup()</code> and call it a day, no?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we accept the path <code>"db/phones"</code>, which is a relative path. It gets resolved based on the current directory, as expected. However, our
storage engine is meant to be <em>embedded</em>. What will happen if the parent application decide to change its output directory? That will mean that our
relative file name will point to a <em>different</em> location, which is going to cause unforeseen issues. Better to stop this early.</p>
</div>
<div class="paragraph">
<p>On Linux, once you opened a file, you no longer have access to its name. It may have multiple names (hard links) or non (anonymous or have been deleted).
That is why I&#8217;m keeping track of the provided name (after resolving to the real path) as part of the handle. It is too good a source of information to just
discard.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The act of creating a file is a non trivial operation, since we need to make sure that the file creation is atomic and durable.
<a href="#fsync_parent_directory"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</a> deals with a fairly nasty problem with Linux, management of file metadata. In particular, adding a file or changing the size of a file will
cause changes not to the file itself, but to its parent directory. This isn&#8217;t <em>actually</em> true, but it is a fairly good lie in the sense that it gives you
enough information to have a mostly correct gut feeling about how things work.</p>
</div>
<div class="paragraph">
<p>If you want to understand how it works in more depth, I would recommend reading an excellent
book on the topic: <a href="http://www.nobius.org/practical-file-system-design.pdf">Practical File System Design with the Be File System</a>. It is an old one (I read it the first
time close to two decades ago) but it does an excellent job of covering a <em>lot</em> of the details. At under 250 pages, it makes for an <em>excellent</em> read for a very complex
topic. Another resource you might want to consider is <a href="https://blog.carlosgaldino.com/writing-a-file-system-from-scratch-in-rust.html">GotenksFS</a>, a file system explicitly
designed for learning purposes. There is also <a href="https://github.com/libfuse/libfuse">libfuse</a> which allows you to define file systems in user space, which can be really
interesting peek into how file systems really work.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">What about fork support?</div>
<div class="paragraph">
<p>When opening the file, we use <code>O_CLOEXEC</code>. Meaning that we don&#8217;t want to share this file descriptor across forks. The design of Gavran isn&#8217;t going to be friendly to multi process access
and multiple processes sharing the same file descriptors can be problematic. For that reason, we ask the operating system to close any such files explicitly.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Metadata updates not being part of <code>fsync()</code> make it possible for you to make changes to a file (creating the file or increasing its size), call <code>fsync()</code> on the
file and then losing data because the <em>existence</em> or the <em>size</em> of the file wasn&#8217;t properly persist to stable medium. I&#8217;ll refer you to
<a href="https://lwn.net/Articles/457667/">LWN again for the gory details</a>.</p>
</div>
<div class="paragraph">
<p><a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> and <a href="#fsync_parent_directory"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</a> has quite a lot of error handling, but most of it isn&#8217;t visible, hidden in the <code>defer()</code> call which simplify the overall system logic.
Why am I being so paranoid about error handling? To the point I defined a whole infrastructure for managing that before writing a single byte to a file?
The answer is simple, we aim to create an ACID storage engine, one which will take data and <em>keep</em> it. As such, we have to be aware that the
underlying system can fail in interesting ways.</p>
</div>
<div id="fsync_parent_directory" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</div>
<div class="content">
<pre class="highlight"><code>static result_t fsync_parent_directory(char *file) {
  char *last = strrchr(file, '/');
  int fd;
  if (!last) {
    // <b class="conum">(1)</b>
    fd = open(".", O_RDONLY);
  } else {
    // <b class="conum">(2)</b>
    *last = 0;
    fd = open(file, O_RDONLY);
    *last = '/';
  }
  if (fd == -1) {
    failed(errno, msg("Unable to open parent directory"),
           with(file, "%s"));
  }
  defer(close, fd);
  if (fsync(fd)) {
    failed(errno, msg("Failed to fsync parent directory"),
           with(file, "%s"));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If there is no <code>/</code> in the path, assume that this is from the current directory</p>
</li>
<li>
<p>We need to find the name of the <em>parent</em> directory, we add a null in the right location to find it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The ALICE paper has found numerous issue is projects that have been heavily battle tested. And a few years ago that have been a case of data loss in PostgreSQL that has been
track down to not checking the return value of an <code>fsync()</code> call. This LWN article summarize <a href="https://lwn.net/Articles/752063/">the incident</a> quite well.
If we aim to build a robust system, we <em>must</em> assume that anything can fail, and react accordingly.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">What happens if <code>close()</code> fail from the <code>defer()</code>?</div>
<div class="paragraph">
<p>In <a href="#fsync_parent_directory"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</a>, we setup <code>close()</code> to be invoked automatically by the compiler when the scope ends. However, what happens if there is an error
in the <code>close</code> ? That happens after the <code>return</code> statement, so the return value was already selected. We handle this by pushing an error from a
deferred operation and checking <code>errors_get_count()</code> to validate that there are no surprises.</p>
</div>
<div class="paragraph">
<p>And while it may seem funny, <code>close</code> <em>can</em> fail. Here is the <a href="https://lwn.net/Articles/576478/">LWN discussion on the topic </a>. And
<a href="https://stackoverflow.com/questions/24477740/">StackOveflow</a> has an interesting story of the result of missing a call to <code>close()</code>. We are going to handle
this differently, though. Errors during cleanup routines are already very hard to deal with. If we have to deal with them routinely that would be
a pain. Instead, we are going to try to set things up so this doesn&#8217;t matter.</p>
</div>
<div class="paragraph">
<p>With <code>flopped()</code> also validating the <code>errors_count()</code>, we know that even if the error happened in the <code>defer()</code> call, we&#8217;ll detect and treat it just the same.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What <a href="#fsync_parent_directory"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</a> does, essentially, is to <code>open()</code> the parent directory using <code>O_RDONLY</code> and then call <code>fsync()</code> on the returned file descriptor. This
instructs the file system to properly persist the directory information and protect us from losing a new file.  Note that we rely on the fact that
strings are mutable in C to truncate the <code>file</code> value by adding a null terminator for the parent directory (we restore it immediately afterward).
This trick allows us to avoid allocating memory during these operations.
It is safe to make this change in memory because the string we mutate is the one belonging to the <code>handle</code>. So that is our own memory and we are fine to modify it.</p>
</div>
<div class="paragraph">
<p>The reason we need to call <code>fsync_parent_directory()</code> is that to make the life of the user easier, we are going to create the file if it does not
exists, including any parent directories. And if we are creating these directories, we need to ensure that they won&#8217;t go away because of file
system metadata issues.</p>
</div>
<div class="paragraph">
<p>Sadly, safely creating the full path is a somewhat tedious task. You can see how we approach it in <a href="#pal_ensure_full_path"><code>pal.linux.c</code> - Ensuring that the full path provide exists and the caller has access to it</a>, where quite a lot is going on.
If the file already exists, we can return successfully immediately. If the file is a directory, we return an error. We then scan the path
one directory at a time and check if the directory exists. I&#8217;m using a trick here by putting a <code>0</code> in the place of the current directory
separator.</p>
</div>
<div id="pal_ensure_full_path" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Ensuring that the full path provide exists and the caller has access to it</div>
<div class="content">
<pre class="highlight"><code>static result_t pal_ensure_full_path(char *file) {
  // already exists?
  struct stat st;
  if (!stat(file, &amp;st)) {
    if (S_ISDIR(st.st_mode)) {
      failed(EISDIR, msg("The path is a directory, expected a file"),
             with(file, "%s"));
    }
    return success();  // file exists, so we are good
  }

  char *cur = file;
  if (*cur == '/')  // rooted path
    cur++;

  while (*cur) {
    char *next_sep = strchr(cur, '/');
    if (!next_sep) {
      return success();  // no more directories in path
    }
    *next_sep = 0;  // add null sep to cut the string

    if (!stat(file, &amp;st)) {  // now we are checking the directory!
      if (!S_ISDIR(st.st_mode)) {
        failed(ENOTDIR,
               msg("The path is a file, but expected a directory"),
               with(file, "%s"));
      }
    } else {  // probably does not exists
      if (mkdir(file, S_IRWXU) == -1 &amp;&amp; errno != EEXIST) {
        failed(errno, msg("Unable to create directory"),
               with(file, "%s"));
      }
      ensure(fsync_parent_directory(file));
    }
    *next_sep = '/';
    cur = next_sep + 1;
  }
  failed(
      EINVAL,
      msg("The last char in the path is '/', which is not allowed"),
      with(file, "%s"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, given a <code>/db/phones\0</code>, we&#8217;ll start the search for <code>/</code> from the second character and then place a null terminator on that
position. The filename would then be: <code>/db\0phones\0</code>. If needed, we will create the directory and then move to the next one. As part of
that, we&#8217;ll set the <code>/</code> again and continue from the next <code>/</code>. This code requires a <em>mutable</em> string to work, but it does the work with no
allocations, which is nice.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Reducing user frustration</div>
<div class="paragraph">
<p>Automatically creating a directory when given a path is a <em>small</em> feature. Call <code>mkdir()</code> before <code>open</code>, pretty much. Doing that <em>reliably</em> is more
complex, but not too hard. There are things you need to consider when doing this, what permissions should you give, how to handle any soft or
hard links that you find along the way, etc.</p>
</div>
<div class="paragraph">
<p>On the other hand, <em>not</em> creating the directory automatically adds a tiny bump of frustration for the user. There is an extra, usually
unnecessary step to take along the way.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If we need to create a new directory, we make sure to call <code>fsync_parent_directory()</code> to ensure that a power failure will not cause the directory to go poof.
As careful as I am being here, note that there are many scenarios that I&#8217;m not trying to cover. Using soft and hard links or junction points is the first example that
pops to mind. And double the work if you need to deal with files or paths that come from un-trusted source. OWASP has quite a bit to talk about in terms of the kind of
vulnerabilities that this might expose.</p>
</div>
<div class="paragraph">
<p>Earlier I discussed wanting to get the proper primitives and get as far away from the level of code that you would usually need to write to deal with the file system,
I think that now it is much clearer exactly why I want to get to that level as soon as I can.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_the_files_size">Setting the file&#8217;s size</h3>
<div class="paragraph">
<p>When creating a file, it is created with zero bytes. That makes perfect sense, after all. There <em>is</em> no data here. When you&#8217;ll write to the file, the file system will
allocate the additional space needed on the fly. This is simple, require no thinking on our part and exactly the wrong thing to want in a storage engine.</p>
</div>
<div class="paragraph">
<p>We just saw how hard we have to work to properly ensure that changes to the metadata (such as, for example, changing its size) are properly protected against possible
power failures. If we would need to call <code>fsync_parent_directory()</code> after every write, we can kiss our hopes for good performance goodbye. Instead of letting the file
system allocate the disk space for our file on the fly, we&#8217;ll ask it for the space in advance, in well known locations. That will ensure that we only rarely need to
call <code>fsync_parent_directory()</code>.</p>
</div>
<div class="paragraph">
<p>Requesting the disk space in advance has another major benefit, it gives the file system the most information about how much disk space we want. It means that we give
the file system the chance to give us long sequences of consecutive disk space. In the age of SSD and NVMe it isn&#8217;t as critical as it used to be, but it still matters.
Depending on your age, you may recall running <code>defrag</code> to gain <em>substantial</em> performance increase on your system or have never heard about it at all.</p>
</div>
<div class="paragraph">
<p><a href="#pal_set_file_size"><code>pal.linux.c</code> - Pre-allocate disk space by letting the file system know ahead of time what we need</a> shows how we request that the file system allocate enough disk space for us. At its core, we simply call to <code>ftruncate()</code> which will extend the file
for us, if needed. The function allows you to specify minimum and maximum file size because we&#8217;ll need to support truncation of files in the future, and if
the amount of code is small enough, I would rather show you the whole thing at once, rather than tease it out.</p>
</div>
<div id="pal_set_file_size" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Pre-allocate disk space by letting the file system know ahead of time what we need</div>
<div class="content">
<pre class="highlight"><code>result_t pal_set_file_size(file_handle_t *handle,
                           uint64_t minimum_size,
                           uint64_t maximum_size) {
  errors_assert_empty();

  struct stat st;
  if (fstat(handle-&gt;fd, &amp;st)) {
    failed(errno, msg("Unable to stat file"),
           with(handle-&gt;filename, "%s"), with(minimum_size, "%lu"));
  }
  uint64_t new_size = 0;

  if (minimum_size &gt; (uint64_t)st.st_size) {
    new_size = minimum_size;
  } else if (maximum_size &lt; (uint64_t)st.st_size) {
    new_size = maximum_size;
  }

  if (!new_size) return success();

  if (ftruncate(handle-&gt;fd, (off_t)new_size) == -1) {
    failed(errno, msg("Unable to change file to size"),
           with(handle-&gt;filename, "%s"), with(new_size, "%lu"));
  }
  handle-&gt;size = new_size;

  char *mutable;
  ensure(mem_duplicate_string(&amp;mutable, handle-&gt;filename));
  defer(free, mutable);

  ensure(fsync_parent_directory(mutable));

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in <a href="#pal_set_file_size"><code>pal.linux.c</code> - Pre-allocate disk space by letting the file system know ahead of time what we need</a> we call to <code>fsync_parent_directory()</code>. That isn&#8217;t interesting on its on, it is interesting because we need to pass it a <em>mutable</em> string.
Of course, <code>fsync_parent_directory()</code> makes sure to return things to normal by the time it returns, but it means that we cannot pass it a constant value and expect things
to work and <code>handle&#8594;filename</code> is going to be part of our database&#8217;s shared state, so we can&#8217;t mutate it casually. There might be other threads peeking at the value while it
is being mutated. Therefor, we have to use a temporary copy. Convenience function such as <code>mem_duplicate_string()</code> and using <code>defer()</code> make this a breeze.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">The perils of paths</div>
<div class="paragraph">
<p>I&#8217;m doing dynamic memory allocation in <a href="#pal_set_file_size"><code>pal.linux.c</code> - Pre-allocate disk space by letting the file system know ahead of time what we need</a>, but I could do a static buffer of size <code>PATH_MAX</code>, wouldn&#8217;t that be better?
There are actually scenarios where <code>PATH_MAX</code> is <em>not</em> sufficient. See <a href="https://eklitzke.org/path-max-is-tricky">this post</a> a full discussion of the perils of
using <code>PATH_MAX</code>.</p>
</div>
<div class="paragraph">
<p>One of tha advantages of stack allocation is that it will be automatically cleaned up. We get the same behavior via <code>defer()</code>, so that is great. There <em>is</em> a
non trivial cost for allocating memory, though. We&#8217;ll discuss memory allocation strategies when we get to benchmarking, in the last part of this book.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_closing_a_file">Closing a file</h3>
<div class="paragraph">
<p>After quite a journey, we are almost at the end. The only function we are left to implement to be able to compile the code in <a href="#create_and_set_file"><code>test.c</code> - Using the file API to create a file with a minimum size</a> is <code>pal_close_file()</code>.
You can see the code in <a href="#pal_close_file"><code>pal.linux.c</code> - Closing a file</a>.</p>
</div>
<div id="pal_close_file" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Closing a file</div>
<div class="content">
<pre class="highlight"><code>result_t pal_close_file(file_handle_t *handle) {
  if (!handle) return success();
  defer(free, handle);
  defer(free, handle-&gt;filename);
  if (close(handle-&gt;fd) == -1) {
    failed(errno, msg("Failed to close file"),
           with(handle-&gt;filename, "%s"), with(handle-&gt;fd, "%i"));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pal_close_file()</code> function simple call the <code>close()</code> method and add some additional error handling, nothing more. We aren&#8217;t trying to call <code>fsync()</code> or do any
fancy things at this layer. That will be the responsibility of higher tiers in the code. Note that we <em>setup</em> the <code>handle&#8594;filename</code> and the <code>handle</code> itself to
be freed, but we aren&#8217;t calling that explicitly. I find that it is cleaner to do things this way. I don&#8217;t need to think about the error conditions that I may
need to cover.</p>
</div>
<div class="paragraph">
<p>One thing that deserve calling out here, an error from <code>close()</code> isn&#8217;t theoretical. In almost all cases, whenever you do I/O, you are not interacting with
the actual hardware, but the page cache. That means that almost all the I/O is done in an asynchronous fashion and <code>close()</code> is one way for you to get
notified if there have been any errors.</p>
</div>
<div class="paragraph">
<p>Even with checking the return value of <code>close()</code>, you still need to take into account that errors <em>will</em> happen. Unless <code>fsync()</code> was called, the file system
is free to take you writes to a <code>close()</code> file and just throw them away. This is not a theoretical issue, by the way, it happens quite often in many
failure scenarios. The recommendation from the <a href="https://marc.info/?l=linux-fsdevel&amp;m=152535409207496&amp;w=2">file system mailing list</a> is to call <code>fsync()</code> and
then <code>close()</code>, to get the highest durability mode.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_and_write_from_the_file">Reading and write from the file</h3>
<div class="paragraph">
<p>Now that we are able to create a file and allocate disk space for it, we need to tackle the next challenge, deciding how we are going to read and write
from this file. I&#8217;ll defer talking about the internal organization of the file to the next chapter, for now, let&#8217;s talk about the low level interface
that the PAL will offer to the rest of the system.</p>
</div>
<div class="paragraph">
<p>We already saw them in <a href="#pal-interface"><code>gavran/pal.h</code> - The file system interface that we&#8217;ll consume for our storage engine</a>, <code>pal_mmap()</code> and <code>pal_unmap()</code> as well as <code>pal_write_file()</code> and <code>pal_read_file()</code> are the functions that are
provided for this purpose.  There isn&#8217;t much there, which is quite surprising. There is a <em>vast</em> difference between the performance of reading from
disk (even fast ones) and reading from memory. For this reason, database and storage engines typically spend quite a bit of time managing buffer pools
and reducing the number of times they <em>have</em> to go to disk.</p>
</div>
<div class="paragraph">
<p>I&#8217;m going to use a really cool technique to avoid the issue entirely. By mapping the file into memory, I don&#8217;t have to write a buffer pool, I can
use the page cache that already exists in the operating system. Using the system&#8217;s page cache has a lot of advantages. I have run into this idea
for the first time when reading LMDB&#8217;s codebase and it is a fundamental property of how Voron (RavenDB&#8217;s storage engine) achieve its speed.
I also recommend reading the <a href="https://queue.acm.org/detail.cfm?id=1814327">"You&#8217;re Doing It Wrong" paper by Poul-Henning Kamp</a> that goes into
great details why this is a great idea.</p>
</div>
<div class="paragraph">
<p>The idea is that we&#8217;ll ask the operating system to <code>mmap()</code> the file into memory and we&#8217;ll be able to access the data through directly memory access.
The operating system is in charge of the page cache, getting the right data to memory, etc. That is a lot of code that we don&#8217;t have to write, which
has gone through literal decades of optimizations. In particular, the page cache implements strategies such as read ahead, automatic eviction as needed
and many more behaviors that you&#8217;ll usually need to write in a buffer pool implementation. By leaning on the OS' virtual memory manager to do all that
we gain enormous leverage.</p>
</div>
<div class="paragraph">
<p>We could map the memory for both reads and writes, but I believe that it would make more sense to only map the file data for reads. This is to avoid
cases where we accidentally write over the file data in an unintended manner. Instead, we create an explicit call to write the data to the file: <code>pal_write_file()</code>.
The <code>pal_unmap()</code> is just the other side of the <code>pal_mmap()</code> operation, allowing us to clean up after ourselves. I&#8217;m adding <code>pal_read_file()</code> for completion&#8217;s sake
and because if we are running in 32 bits, we can&#8217;t really <code>mmap()</code> a 10 GB file, so we also need another fallback. You can see the mapping and un-mapping code in <a href="#pal_map"><code>pal.linux.c</code> - Implementing mapping and un-mapping of memory from out data file</a>.</p>
</div>
<div class="paragraph">
<p>What is the best option for reading and writing, then? Go memory mapped I/O all the way or rely on <code>read()</code> and <code>write()</code>?  And can we mix them? Why have two way to go about
this? I&#8217;m mostly going to be using memory mapped I/O for reads, but writes will use <code>pwrite()</code> to write to it. That gives me the benefit of using the OS' buffer cache and
make the best use of the system resources. Using <code>pwrite</code>, on the other hand, ensures that we aren&#8217;t accidentally writing beyond the end of the buffer and will help us catch
any errors.</p>
</div>
<div class="paragraph">
<p>On Linux, that is safe to do, because both <code>mmap()</code> and the <code>write()</code> call are using the same page cache and are coherent with respect to one another.
On <em>Windows</em>, on the other hand, that is not the case. Mixing file I/O calls and memory mapped files lead to situation where you write data using the
I/O API which will take some time to be visible using the memory view. For further reading, you can read how I found out about
<a href="https://ayende.com/blog/164577/is-select-broken-memory-mapped-files-with-unbufferred-writes-race-condition">this delightful state off affairs</a>. When we get to the
Windows side of things, we&#8217;ll show how to deal with this limitation properly.</p>
</div>
<div id="pal_map" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Implementing mapping and un-mapping of memory from out data file</div>
<div class="content">
<pre class="highlight"><code>result_t pal_mmap(file_handle_t *handle, uint64_t offset, span_t *m) {
  errors_assert_empty();
  m-&gt;address = mmap(0, m-&gt;size, PROT_READ, MAP_SHARED, handle-&gt;fd,
                    (off_t)offset);
  if (m-&gt;address == MAP_FAILED) {
    m-&gt;address = 0;
    failed(errno, msg("Unable to map file"),
           with(handle-&gt;filename, "%s"), with(m-&gt;size, "%lu"));
  }
  return success();
}

result_t pal_unmap(span_t *m) {
  if (!m-&gt;address) return success();
  if (munmap(m-&gt;address, m-&gt;size) == -1) {
    failed(EINVAL, msg("Unable to unmap"), with(m-&gt;address, "%p"));
  }
  m-&gt;address = 0;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There really isn&#8217;t much there in <a href="#pal_map"><code>pal.linux.c</code> - Implementing mapping and un-mapping of memory from out data file</a>. We just need to call <code>mmap()</code> or <code>munmap()</code> and do some basic error reporting in the case of an error.
In <a href="#pal_map_defer"><code>pal.linux.c</code> - Allowing to <code>close()</code> the file and <code>unmap()</code> via <code>defer()</code></a>, however, we allow to <code>close()</code> the file and <code>unmap()</code> the memory using a <code>defer()</code> call.</p>
</div>
<div id="pal_map_defer" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Allowing to <code>close()</code> the file and <code>unmap()</code> via <code>defer()</code></div>
<div class="content">
<pre class="highlight"><code>void defer_pal_close_file(cancel_defer_t *cd) {
  if (cd-&gt;cancelled &amp;&amp; *cd-&gt;cancelled) return;
  if (flopped(pal_close_file(*(void **)cd-&gt;target))) {
    errors_push(EINVAL, msg("Failure to close file during defer"));
  }
}

void defer_pal_unmap(cancel_defer_t *cd) {
  if (cd-&gt;cancelled &amp;&amp; *cd-&gt;cancelled) return;
  span_t *ctx = cd-&gt;target;
  if (flopped(pal_unmap(ctx))) {
    errors_push(EINVAL, msg("Failure to close file during defer"),
                with(ctx-&gt;address, "%p"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#pal_write_file"><code>pal.linux.c</code> - Writing and reading data to the file</a> we have the implementation of writing and reading to files using normal file I/O.
The <code>pal_write_file()</code> call is a simple wrapper around the <code>pwrite()</code> call, with the only difference being that we&#8217;ll repeat the write until the entire buffer
has been written. In practice, this usually means that we&#8217;ll only do a single call to <code>pwrite()</code> which will perform all the work. And <code>pal_read_file()</code> does
the same on top of <code>pread()</code>. The only difference there is that <code>pal_read_file</code> will consider partial writes as errors, so you either get the whole buffer you
asked for, or an error.</p>
</div>
<div id="pal_write_file" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Writing and reading data to the file</div>
<div class="content">
<pre class="highlight"><code>result_t pal_write_file(file_handle_t *handle, uint64_t offset,
                        const char *buffer, size_t size) {
  errors_assert_empty();
  while (size) {
    ssize_t result = pwrite(handle-&gt;fd, buffer, size, (off_t)offset);
    if (result == -1) {
      if (errno == EINTR) continue;  // repeat on signal

      failed(errno, msg("Unable to write bytes to file"),
             with(size, "%lu"), with(handle-&gt;filename, "%s"));
    }
    size -= (size_t)result;
    buffer += result;
    offset += (size_t)result;
  }
  return success();
}
result_t pal_read_file(file_handle_t *handle, uint64_t offset,
                       void *buffer, size_t size) {
  errors_assert_empty();
  while (size) {
    ssize_t result = pread(handle-&gt;fd, buffer, size, (off_t)offset);
    if (result == 0) {
      failed(EINVAL, msg("File EOF before we read entire buffer"),
             with(size, "%lu"), with(handle-&gt;filename, "%s"));
    }
    if (result == -1) {
      if (errno == EINTR) continue;  // repeat on signal

      failed(errno, msg("Unable to read bytes from file"),
             with(size, "%lu"), with(handle-&gt;filename, "%s"));
    }
    size -= (size_t)result;
    buffer += result;
    offset += (size_t)result;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As much as I want to tunnel my writes I/O purely through the <code>pwrite</code> system call, there are going to be cases where we&#8217;ll want to enable writable memory map
for the ease in which they allow us to make changes in memory. Supporting that is quite easy, using the <code>mprotect()</code> system call, you can see the code in
<a href="#pal_enable_writes"><code>pal.linux.c</code> - Enable writable memory maps and allow to disable them</a>.</p>
</div>
<div id="pal_enable_writes" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Enable writable memory maps and allow to disable them</div>
<div class="content">
<pre class="highlight"><code>result_t pal_enable_writes(span_t *s) {
  if (mprotect(s-&gt;address, s-&gt;size, PROT_READ | PROT_WRITE) == -1) {
    failed(errno,
           msg("Unable to modify the memory protection flags"));
  }
  return success();
}

void defer_pal_disable_writes(cancel_defer_t *cd) {
  if (cd-&gt;cancelled &amp;&amp; *cd-&gt;cancelled) return;
  span_t *s = cd-&gt;target;
  if (mprotect(s-&gt;address, s-&gt;size, PROT_READ) == -1) {
    errors_push(errno,
                msg("Unable to modify the memory protection flags"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#pal_enable_writes"><code>pal.linux.c</code> - Enable writable memory maps and allow to disable them</a> doesn&#8217;t define a <code>pal_disable_writes()</code> method, instead it jump directly to the <code>defer</code> call. You are expected to call <code>defer(pal_disable_writes, span);</code>
immediately after calling <code>ensure(pal_enable_writes(span)</code>. This API reflects the notion that writable memory mapped is meant to be <em>rare</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_durable_writes_and_fsync">Durable writes and <code>fsync()</code></h3>
<div class="paragraph">
<p>There is only one area of the API that we haven&#8217;t looked at yet. The <code>pal_fsync()</code> function is implemented just as simply as you would expect it to be. You can see it in
<a href="#pal_fsync"><code>pal.linux.c</code> - Flushing a file</a>.</p>
</div>
<div id="pal_fsync" class="listingblock">
<div class="title"><code>pal.linux.c</code> - Flushing a file</div>
<div class="content">
<pre class="highlight"><code>result_t pal_fsync(file_handle_t *handle) {
  if (fdatasync(handle-&gt;fd) == -1) {
    failed(errno, msg("Failed to sync file"),
           with(handle-&gt;filename, "%s"), with(handle-&gt;fd, "%i"));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, there is a surprise in <a href="#pal_fsync"><code>pal.linux.c</code> - Flushing a file</a>, we aren&#8217;t calling <code>fsync()</code>, we are only calling <code>fdatasync()</code>. Note that elsewhere in the PAL, we used <code>fsync()</code>, in
<a href="#fsync_parent_directory"><code>pal.linux.c</code> - Calling fsync() on a parent directory to ensure that the file metadata has been preserved</a>, for example. Why this discrepancy? And why we call the method <code>pal_fsync()</code> and not <code>pal_fdatasync()</code>?</p>
</div>
<div class="paragraph">
<p>When we call <code>fsync()</code>, we are asking to flush the data of the file to disk and the file&#8217;s metadata (last modified, access time, etc). When we call <code>fdatasync()</code>, we
only ask to flush the file&#8217;s data, the metadata isn&#8217;t required to be included. That makes <code>fdatasync()</code> cheaper for scenarios where metadata updates aren&#8217;t important.
Remember, <code>fsync()</code> and <code>fdatasync()</code> are <em>expensive</em>, so any reduction in cost is welcome.</p>
</div>
<div class="paragraph">
<p>I&#8217;m calling it <code>pal_fsync()</code> because the choice of <code>fdatasync()</code> is an implementation detail. On Mac, we&#8217;ll need to use <code>fcntl(fd, F_FULLFSYNC);</code> because <code>fsync()</code>
doesn&#8217;t actually do what it is supposed to do. On Windows, we&#8217;ll call to <code>FlushFileBuffers()</code>, which is the <code>fsync()</code> equivalent.
We''ll learn all about why <code>fsync()</code> is important to a storage engine in Chapter 8.</p>
</div>
<div class="paragraph">
<p>There is another aspect of durable writes that we have to look at. In <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> I mentioned the <code>flags</code> argument and said that I&#8217;ll talk about it later.
That later is now, and you can see the flags' options in <a href="#pal_file_creation_flags"><code>gavran/pal.h</code> - Flags for opening a file</a>.</p>
</div>
<div id="pal_file_creation_flags" class="listingblock">
<div class="title"><code>gavran/pal.h</code> - Flags for opening a file</div>
<div class="content">
<pre class="highlight"><code>enum pal_file_creation_flags {
  pal_file_creation_flags_none = 0,
  pal_file_creation_flags_durable = 1
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>There aren&#8217;t really many options here, we have durable mode and non durable mode, that is all. When looking at <a href="#pal_create_file"><code>pal.linux.c</code> - Opening (or creating) a file</a> we can see that if we set the
<code>flags</code> to <code>pal_create_file()</code> to <code>pal_file_creation_flags_durable</code>, it will simply add the following flags to the <code>open()</code> call: <code>O_DIRECT | O_DSYNC</code>. What does
this mean?</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">The cost of <code>fsync()</code></div>
<div class="paragraph">
<p>Using <code>fsync()</code>, we can ensure that writes to the disk has actually reached a stable medium. In other words, after <code>fsync()</code> was called, we can
rest assured that a power failure won&#8217;t wipe our data. For a storage engine that, as you can imagine, this is a highly desirable property.</p>
</div>
<div class="paragraph">
<p>The issue is that <code>fsync()</code> is a <strong>very</strong> costly call. It is usually <em>the</em> most expensive call you&#8217;ll make, period. To the point where we&#8217;ll spend
considerable time and effort down the line to <em>reduce</em> the number of times we have to call <code>fsync()</code>. The primary issue with <code>fsync()</code> is that it
needs to clear not just the data in our file but to effectively flush the entire disk cache. If you have a lot of pending I/O, you will <em>wait</em> until
this is completed, and that can take a while.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I&#8217;m going to cover this in more detail in Chapter 8, but the general idea is that <code>O_DSYNC</code> is saying to the operating system that on every write to the file, it needs
to behave as if we called <code>fdatasync()</code> and <code>O_DIRECT</code> instructs the file system to ignore all buffers and use direct I/O. <em>Together</em>, however, they allow us to do
something far more interesting. They tell the operating system that we want to make a durable write to disk, bypassing all buffering in the middle. This is a <em>dramatically</em>
more expensive option, and using it in this manner requires that we&#8217;ll accept some harsh limitations on how we can actually write. All data must be page aligned, all
writes must be page aligned, etc.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll be using this mode sparingly, but it is a crucial one to ensuring that we can get proper durable writes in the system. You can see how they are used in Chapter 8.
For now, we&#8217;ll just use the non durable mode everywhere.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Using a block device instead of bothering with the file system</div>
<div class="paragraph">
<p>Technically speaking, the model that I intend to use will work just as well for raw block devices as it would do for files. Indeed, there are some
real benefits of bypassing the file system for a storage engine. What I most want from a file system as a storage engine author is that it will
<em>get out of my way</em>. There are also some performance benefits, avoiding the need for data fragmentation, overhead of the file system, etc.</p>
</div>
<div class="paragraph">
<p>That said, working with files is <em>ever so much</em> easier. Yes, you can use commands such as <code>dd</code> to move data between blocks and files, but that
tend to be much more awkward than if the data reside in a file. In fact, we are going to try hard to get to the point where we have as few files
as we can get away with and do all our work internally inside our file.</p>
</div>
<div class="paragraph">
<p>That would allow us to switch to a block device at a later point in time, but having direct access to the file is just too convenient to give up.
However, there is another consideration to take into account. A database server can expect to have the right kind of permissions to allow opening a
raw block device. But an embedded storage engine needs to deal with limited rights on behalf of its processes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_our_api_for_storing_and_retrieving_data">Using our API for storing and retrieving data</h3>
<div class="paragraph">
<p>We are still very early on in the process, but I think that peeking at <a href="#read_write_io"><code>test.c</code> - Using the file API to read &amp; write</a> will show you how far we have come. We are making for use of all
of our functions to store and read data from the file.</p>
</div>
<div id="read_write_io" class="listingblock">
<div class="title"><code>test.c</code> - Using the file API to read &amp; write</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">static result_t read_write_io(const char* file) {
  file_handle_t* h;
  ensure(pal_create_file(file, &amp;h, pal_file_creation_flags_none));
  defer(pal_close_file, h);
  ensure(pal_set_file_size(h, 1024 * 128, 1024 * 128));

  span_t range = {.size = h-&gt;size};
  ensure(pal_mmap(h, 0, &amp;range));
  defer(pal_unmap, range);
  ensure(range.size == 1024 * 128);

  const char* msg = "Hello from Gavran";
  ensure(pal_write_file(h, 0, msg, strlen(msg)));

  ensure(strcmp(msg, range.address) == 0);

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#read_write_io"><code>test.c</code> - Using the file API to read &amp; write</a> shows case the the benefits of <code>defer</code> again, which is rapidly becoming my favorite approach to dealing with error handling in this codebase.
We have to deal with multiple resources, but there isn&#8217;t any jump in complexity in the function. Everything <em>works</em>.</p>
</div>
<div class="paragraph">
<p>As for the actual code, we create a new database, ensure that it has the right size, map it into memory and then write a value to it using the <code>pal_write_file()</code>
function. We then read from it using the memory mapped address. The code reads nearly as well as the description of the code, with little in the way of unnecessary details.</p>
</div>
<div class="paragraph">
<p>This may seem like a humble beginning, but we are currently building the foundation of our storage engine. In the next chapter, we are going to
start talking about how we are going to make <em>use</em> of this functionality.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tests">Tests</h3>
<div class="paragraph">
<p>In order to make sure that we are producing good software, and that means tests. Now that the chapter is over, it is time to see its tests. I&#8217;m not going
to deeply into the testing side of the pool, but I have found them to be invaluable to ensure that the software does what you <em>think</em> it does.
In this case, you already saw the major test cases, <a href="#read_write_io"><code>test.c</code> - Using the file API to read &amp; write</a> and <a href="#create_and_set_file"><code>test.c</code> - Using the file API to create a file with a minimum size</a>, but I got a few that test more esoteric pieces of the API
as well in <a href="#tests_ch03"><code>test.c</code> - Testing the PAL API</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note on testing</div>
<div class="paragraph">
<p>On each chapter, I&#8217;m going to create a set of unit tests that will verify the functionality on the system. Each chapter conclude with a system that pass
all its (and previous) tests. That is important to ensure that any change that I&#8217;m making isn&#8217;t going to break the system.</p>
</div>
<div class="paragraph">
<p>That said, be aware that you can spend a lot of time tying yourself to a particular implementation choices using tests.
Right now I&#8217;m writing fairly silly tests, mostly because I&#8217;m not going to try to test that we are writing durably to disk. That requires a lab with a
UPS that I can trigger via an API and a machine that I don&#8217;t mind frying.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>And now we are ready to see how we are going to be <em>using</em> the files.</p>
</div>
<div id="tests_ch03" class="listingblock">
<div class="title"><code>test.c</code> - Testing the PAL API</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">describe(pal_tests) {
  const char file[] = "/tmp/files/try";

  before_each() {
    errors_clear();
    system("mkdir -p /tmp/files");
    system("rm -f /tmp/files/*");
  }

  it("can work with files") { assert(create_and_set_file(file)); }

  it("can read and write") { assert(read_write_io(file)); }

  it("can get file name") {
    file_handle_t* h;
    assert(pal_create_file(file, &amp;h, pal_file_creation_flags_none));
    defer(pal_close_file, h);
    assert(strcmp(file, h-&gt;filename) == 0);
  }

  it("can open and close file") {
    file_handle_t* h;
    assert(pal_create_file(file, &amp;h, pal_file_creation_flags_none));
    assert(pal_close_file(h));
  }

  it("will create empty file") {
    file_handle_t* h;
    assert(pal_create_file(file, &amp;h, pal_file_creation_flags_none));
    defer(pal_close_file, h);
    assert(h-&gt;size == 0);
  }

  it("will error on opening directory") {
    file_handle_t* h;
    assert(!pal_create_file("/tmp/files", &amp;h,
                            pal_file_creation_flags_none));
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
  <ul style="list-style-type: none;">
    <li><a class="footer-text" href="../index.html">Table of contents</a></li>
    <li><a class="footer-text" href="./ch02.html">Previous chapter</a></li>
    <li><a class="footer-text" href="./ch04.html">Next chapter</a></li>
  </ul>
</div>
</body>
</html>