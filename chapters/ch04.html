<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>THe paging layer and our first transactions</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_the_paging_layer_and_our_first_transactions">The paging layer and our first transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have gotten to the point where we can read and write data to a file. It will take a while to understand why we didn&#8217;t simply call <code>write</code> or <code>read</code> directly and call
it a day. We&#8217;ll discuss that in detail when we implement transactions. Right now, I want to focus on how we are going to lay out the data on the file.</p>
</div>
<div class="paragraph">
<p>Files are typically thought of as sequence of bytes. Consider the text file shown below. It shows a simple text file consisting of several lines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>One
Three
Four</pre>
</div>
</div>
<div class="paragraph">
<p>If I want to add <code>Two</code> to the file in the right location, what do I have to do? There is no easy way to add data in the middle of the file. I have to write out
what I want and then continue writing to the end of the file (extending it along the way). There actually <em>are</em> ways to extend a file in such a manner, in turns
out. It isn&#8217;t very useful for most scenarios, but I want to discuss that a bit so you&#8217;ll understand how that works.</p>
</div>
<div class="paragraph">
<p>You can call <code>fallocate</code> with <code>FALLOC_FL_INSERT_RANGE</code> to insert a range of blocks in the middle of a file. That works because while the file system presents
you with the illusion of a sequence of bytes, the reality is very different. Take a look at <a href="#file-layout">Physical layout of a file on disk</a>, which shows the physical outline of the text file above.</p>
</div>
<div id="file-layout" class="imageblock">
<div class="content">
<img src="../imgs/file-layout.png" alt="file layout">
</div>
<div class="title">Figure 1. Physical layout of a file on disk</div>
</div>
<div class="paragraph">
<p>Any file that is smaller than 512 bytes will fit on a single block one block (sometimes called sector). A block is 512B - 4KB in size, in most cases and you can
assume that it will be 4KB on pretty much any modern disk. And by modern, I&#8217;m talking anything anything made in the past <em>decade</em>.</p>
</div>
<div class="paragraph">
<p>Pretend that the file is actually large enough to reside on multiple blogs. You can use the <code>filefrag</code> command to view the blocks on the file. This is <em>exactly</em>
what happens when we talk about fragmentation of files. The physical layout of the file is made up of blocks, which reside on a block device (the disk drive).
It is the job of the file system to map those blocks into a file and present us with the file stream abstraction.</p>
</div>
<div class="paragraph">
<p>With <code>FALLOC_FL_INSERT_RANGE</code>, we can tell the file system that we want to add new blocks to the file, somewhere in the middle. That is a cheap operation, because
we aren&#8217;t actually moving anything. We simply change the list of blocks that are assigned to the file and write new data to the block. You can see how that looks
on <a href="#file-layout-modified">A file&#8217;s physical layout after adding a block in the middle</a>.</p>
</div>
<div id="file-layout-modified" class="imageblock">
<div class="content">
<img src="../imgs/file-layout-modified.png" alt="file layout modified">
</div>
<div class="title">Figure 2. A file&#8217;s physical layout after adding a block in the middle</div>
</div>
<div class="paragraph">
<p>So we can add data cheaply in the middle of a file, although it requires somewhat unusual API calls. The problem is that we can do that only on block boundary. On
most modern systems, that is 4KB in size. We can also only insert data in increments of 4KB, so this approach isn&#8217;t generally usable.
At the same time, we are going to think about how we are going to manage the data we put into storage. We need to consider how we read and write data. As it
turns out, there are quite a few common methods to handle this scenario:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Append only - we always write at the end of the file, and the file format ensures that new values are found before old values. This has the benefit of being
simple to start with, since there is very little to manage, but you&#8217;ll very quickly end up with most of your space being used by values that has been
overwritten. Getting rid of these old values require you to <em>compact</em> the file, which may take twice as much space as the original file take and introduce
a <em>lot</em> of load on the I/O system.</p>
</li>
<li>
<p>Fixed size records - in this model, we define the size of a record upfront (64 bytes, for example) and then we can treat the file as an array of those records.
This is how many applications stored their data and it is a very simple method that is surprisingly powerful. It has the downside, of course, that you are
forced to pick a set size and use it for the life time of the data. Free space allocation is also something that you need to manage here, as you need some
way to handle deleted records.</p>
</li>
<li>
<p>Page model - the file is divided into pages (typically in the range of 4KB to 4MB) in size that are treated as independent buffers. We are always working on a
the page level, which is a buffer that is read and written to in an atomic fashion. In other words, we replicate exactly how the file system think of the world.
This is similar to the fixed size records option, but instead of storing fixed size records, we have fixed size pages and we are free to manage their internal
structure as we see fit. The page size is also large enough that we can pack multiple records into a single page.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Always work <em>with</em> the hardware</div>
<div class="paragraph">
<p>One additional factor for using pages as the manner in which we manage the data in the file is that this means that all our I/O is now going to be page based.
This in turn means that drives such as SSD or NVMe are going to have easier time, because we are never going to issue a read or a write the crosses a page
boundary. This also tend to allow you to get better lifetime from your hardware, since you are reduce the amount of work it needs to do.
Writing on page boundary has been shown to increase the longevity of the hard drives and can also allow the disk to optimize the data access better.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_getting_to_grips_with_paging">Getting to grips with paging</h3>
<div class="paragraph">
<p>For our storage engine, we are going to use the paging model. That allows the most flexibility and is the most common choice for storage engines. I&#8217;m not going to
go too deeply into the other design choices, you might want to refer the <a href="https://www.databass.dev/">Database Internals</a> book for details. In particular, the terms you
are looking for are Log Structure Merge vs Page Structure.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Pages are a way to work with the data inside the storage engine</div>
<div class="paragraph">
<p>Our storage engine is going to divide the file into pages that are 8KB in side. Instead of thinking about the whole of a file as a stream of bytes, we are going
to cut it into pages and work on each one of them independently. This is a very common decision for databases since there are many benefits for this approach.
Modifying a single page solve the need to insert data in the middle of a file, since we can overwrite the page as a whole.</p>
</div>
<div class="paragraph">
<p>Pages are to a database as bytes are to a file. The basic building blocks, but they aren&#8217;t sufficient. In order to actually make <em>sense</em> of the system, we have
to layer additional features and data structures. I&#8217;m building Gavran from the ground up and explaining each section independently. It all come together and
then we&#8217;ll have a beautiful picture and gorgeous architecture.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next question to ask is what will be the page size we&#8217;ll select. The page size is of great important for the storage engine. That is the atomic unit on which
all operations are made. The page size must be a multiple of the file system block size. In practice, that means that it should be a multiple of 4KB these days.
When building Voron (RavenDB&#8217;s storage engine) we have run a whole bunch of benchmarks and the sweet spot for our needs was a page size that was 8KB. I&#8217;m going
to use that value again and maybe we&#8217;ll play with the size when we get to writing benchmark code (which is still very far away).</p>
</div>
<div class="paragraph">
<p>The API that we wrote so far isn&#8217;t really suitable for working with pages. That is intentional, we are now building another layer in the storage engine. On top
of our PAL code (which deals with files) we now have a paging layer. I&#8217;m going to need to jump ahead a little bit and declare a few things that will not make
<em>any</em> sense now. Instead of building pages and then the database infrastructure, I&#8217;m going to define the code as it should be in the end. You can see the
relevant definitions in <a href="#paging-api"><code>gavran/db.h</code> - The low level paging API</a>.</p>
</div>
<div id="paging-api" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The low level paging API</div>
<div class="content">
<pre class="highlight"><code>#define PAGE_SIZE 8192
#define PAGE_ALIGNMENT 4096

#define ROUND_UP(size, amount) \
  MAX(((size) / amount + ((size) % amount ? 1 : 0)), 1)

#define TO_PAGES(size) ROUND_UP(size, PAGE_SIZE)

typedef struct page_metadata page_metadata_t;

typedef struct page {
  void *address;
  void *previous;  // relevant only for modified page
  page_metadata_t *metadata;
  uint64_t page_num;
  uint32_t number_of_pages;
  uint32_t _padding;
} page_t;

result_t pages_get(txn_t *tx, page_t *p);
result_t pages_write(db_state_t *db, page_t *p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#paging-api"><code>gavran/db.h</code> - The low level paging API</a>, we define the <code>PAGE_SIZE</code> constant and the <code>page_t</code> struct as well as functions that we&#8217;ll use to read and write those pages.
The fields that we care about at this point in <code>page_t</code> are <code>address</code>, <code>size</code> and <code>page_num</code>, we&#8217;ll leave the rest for later. The <code>address</code> is used to return the
address of the page in memory, the <code>size</code> is the size of the data that is stored on the page. This may actually be more than single page&#8217;s worth of data, in some
cases. And the <code>page_num</code> is the page number, naturally. It is important to note that this is an <em>in memory</em> structure, this is never persisted to disk.</p>
</div>
<div class="paragraph">
<p>The <code>pages_get()</code> and <code>pages_write()</code> functions uses types that we haven&#8217;t seen yet, <code>txn_t</code> and <code>db_state_t</code>. For now, we&#8217;ll ignore these, I&#8217;ll introduce how they work
shortly.</p>
</div>
<div class="paragraph">
<p>We can use the API in <a href="#paging-api"><code>gavran/db.h</code> - The low level paging API</a> to get a particular page or to write a set of pages. Let&#8217;s explore how we can use this API to implement the same read &amp; write operation as we did in
the <code>read_write_io()</code> function in the previous chapter.
One caveat we have to take into account is that we <em>can&#8217;t</em> modify the result of the <code>pages_get()</code> directly. This is because the memory is mapped as readonly. Attempts
to write to it will result in a segmentation fault. In order to deal with that, we&#8217;ll copy the page to our own buffer and use the <code>pages_write()</code> to update its content.</p>
</div>
<div class="paragraph">
<p>We are working with pages, so we want to use system page aligned memory, which usually means that we want to make use of <code>posix_memalign()</code>. We already saw how we wrapped this
function in <code>mem_alloc_page_aligned()</code> for our needs. With that in place, we can now write the code to modify the data. You can see how that is done in <a href="#create_and_write_file"><code>test.c</code> - Reading and writing using the paging API</a>.</p>
</div>
<div class="paragraph">
<p>We get the page, copy it to our own buffer, modify our own copy and then write it back. This technique is called Copy On Write and it has some highly desirable
properties. For example, until I call <code>pages_write()</code>, there has been no change to the file. That means that I can abort an operation midway through, free the
copy of the memory I used and move on without need to write compensation logic to restore things to the way it was. <a href="#paging-impl"><code>pages.c</code> - Reading and writing using the paging API</a> shows the implementation of
<code>pages_get()</code> and <code>pages_write()</code>.</p>
</div>
<div id="create_and_write_file" class="listingblock">
<div class="title"><code>test.c</code> - Reading and writing using the paging API</div>
<div class="content">
<pre class="highlight"><code>static result_t create_and_write_file(const char* path) {
  const int DB_SIZE = 128 * 1024;
  // <b class="conum">(1)</b>
  file_handle_t* handle;
  ensure(pal_create_file(path, &amp;handle, 0));
  defer(pal_close_file, handle);
  ensure(pal_set_file_size(handle, DB_SIZE, DB_SIZE));
  // <b class="conum">(2)</b>
  span_t m = {.size = DB_SIZE};
  ensure(pal_mmap(handle, 0, &amp;m));
  defer(pal_unmap, m);

  // <b class="conum">(3)</b>
  db_state_t db_state = {.map = m, .handle = handle};
  page_t p = {.page_num = 0};
  txn_state_t txn_state = {.map = m, .db = &amp;db_state};
  txn_t txn = {.state = &amp;txn_state};

  // <b class="conum">(4)</b>
  ensure(pages_get(&amp;txn, &amp;p));
  page_t copy = {.number_of_pages = 1};
  // <b class="conum">(5)</b>
  ensure(mem_alloc_page_aligned(&amp;copy.address,
                                copy.number_of_pages * PAGE_SIZE));
  defer(free, copy.address);
  // <b class="conum">(6)</b>
  memcpy(copy.address, p.address, PAGE_SIZE);
  strcpy(copy.address, "Hello Gavran!");
  // <b class="conum">(7)</b>
  ensure(pages_write(&amp;db_state, &amp;copy));

  // <b class="conum">(8)</b>
  ensure(strcmp("Hello Gavran!", p.address) == 0);

  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the file and set its size.</p>
</li>
<li>
<p>Map the file to memory.</p>
</li>
<li>
<p>Manual setup (for now) of the data structures we need to make things happen.</p>
</li>
<li>
<p>Get the page from the memory mapped file.</p>
</li>
<li>
<p>Allocate a standalone buffer for the page.</p>
</li>
<li>
<p>Copy the page from the data file to the new buffer and then modify the <em>copy</em>.</p>
</li>
<li>
<p>Write the copied data back to the data file.</p>
</li>
<li>
<p>Ensure that we can see the changes in the page after we written to the file.</p>
</li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">System page size vs. <code>PAGE_SIZE</code></div>
<div class="paragraph">
<p>Gavran is going to use <code>PAGE_SIZE</code> (8KB) for its pages, but there is also the <em>system</em> page size, which is something related, but different. The system page size is
going to be 4KB on pretty much all platforms. You can see this <a href="https://stackoverflow.com/questions/11543748">StackOverflow answer</a> for the details why this is the winning
choice.</p>
</div>
<div class="paragraph">
<p>When we talk about page aligned memory, we are actually talking about memory that is aligned on 4KB boundary (system page size), because that is what the API and hardware
will demand from us. When we are talking about pages in our data file, then we refer to the 8KB pages that Gavran will use. In <a href="#paging-api"><code>gavran/db.h</code> - The low level paging API</a>, you can see it as <code>PAGE_SIZE</code>
vs. <code>PAGE_ALIGNMENT</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code in <a href="#create_and_write_file"><code>test.c</code> - Reading and writing using the paging API</a> deals with creating the appropriate <code>db_state_t</code> and <code>txn_state_t</code> is pretty nasty, we are manually setting up a lot of data structured
that I haven&#8217;t introduced yet. I decided that it is  better to show you the end result, rather than iterate through the same function multiple times. You can see that for now,
we simply need a way to pass the <code>span_t</code> that we mapped and the <code>handle</code> to the <code>pages_get()</code> and <code>pages_write()</code> functions.</p>
</div>
<div id="paging-impl" class="listingblock">
<div class="title"><code>pages.c</code> - Reading and writing using the paging API</div>
<div class="content">
<pre class="highlight"><code>result_t pages_get(txn_t *tx, page_t *p) {
  uint64_t offset = p-&gt;page_num * PAGE_SIZE;
  if (offset + p-&gt;number_of_pages * PAGE_SIZE &gt; tx-&gt;state-&gt;map.size) {
    failed(ERANGE,
           msg("Requests for a page that is outside of the bounds of "
               "the file"),
           with(p-&gt;page_num, "%lu"),
           with(tx-&gt;state-&gt;map.size, "%lu"));
  }

  p-&gt;address = (tx-&gt;state-&gt;map.address + offset);
  return success();
}

result_t pages_write(db_state_t *db, page_t *p) {
  ensure(pal_write_file(db-&gt;handle, p-&gt;page_num * PAGE_SIZE,
                        p-&gt;address, PAGE_SIZE * p-&gt;number_of_pages),
         msg("Unable to write page"), with(p-&gt;page_num, "%lu"));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for <code>pages_get()</code> and <code>pages_write()</code> right now is mostly about forwarding the calls. I created these functions because they will become much more important
down the line.</p>
</div>
<div class="paragraph">
<p>I&#8217;m likely not going to be able to keep track of everything in a system that need to modify more than a single page.  We need some way to manage pages in a more
seamless manner, to handle the Copy On Write, the writes of all the modified pages back to the file and to free all that memory.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Trust the hardware, but verify</div>
<div class="paragraph">
<p>One of the things that we&#8217;ll need to implement at some point is checksum of the pages data. If the data was corrupted on disk, we want to learn about this as soon
as possible. We&#8217;ll likely implement checksum operations in those methods. Data encryption is also very likely to be implemented at this location as well.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For that matter, what happens if I need to modify the same page twice? Am I going to have multiple copies? What will end up in the file in the end?
All of that leads me to realize that we can&#8217;t remain at the level of working with a single page, we need some higher scope to work with here. We need to implement
the concept of a database and a transaction.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_skeleton_database">A skeleton database</h3>
<div class="paragraph">
<p>We aren&#8217;t really ready for real transactions, because it will take time until the code will be able to deliver the appropriate transactional properties, but
that is the right term for where we will be.</p>
</div>
<div class="paragraph">
<p>A transaction is a short lived object that is meant to do a specific operation. This is important because we don&#8217;t expect a transaction to last very long or be very large.
I&#8217;m sure we&#8217;ll get some of those, but we are going to optimize for small &amp; short transactions. Long or big transactions will work, but they aren&#8217;t our optimization target.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">Paying attention to the man behind the screen</div>
<div class="paragraph">
<p>C is a great low level language, but I&#8217;m really feeling the lack of data types. I want to make sure that everything that goes into the engine
is covered here, but I&#8217;m not sure how useful it will be to have you go through a hash table implementation, for example.</p>
</div>
<div class="paragraph">
<p>I&#8217;m assuming that if you are reading this book, you probably are familiar with this enough so that should be of no interest to you. For now,
I want to keep putting all the code here, but I think that when I&#8217;ll start using code beyond the standard library, I&#8217;m going to just point
you to that code and not put it here.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Look at <a href="#txn_api"><code>gavran/db.h</code> - Transaction API declaration for our storage engine</a>, which shows the API we are going to expose for our users. The idea in <a href="#txn_api"><code>gavran/db.h</code> - Transaction API declaration for our storage engine</a> is that we want to do <em>everything</em> within the scope of a transaction.
Note that if you want to get or modify a page, you must provide a
valid transaction to do so. The functions are also named <code>txn_raw_get_page()</code>, the <code>raw</code> part of the name indicates that they are raw interface. I don&#8217;t
intend for our users to <em>ever</em> work at that level. These are here for the internal implementation, nothing else. Building Gavran in layers like that helps to stabilize the
architecture of the system. It also help us reduce the internal dependencies. A raw method call can be done with no setup, but higher level calls likely need more details.</p>
</div>
<div class="paragraph">
<p>We now have a <code>txn_t</code> struct that we can use to represent the transaction, but the actual implementation is hidden away in the <code>txn_state_t</code>. We&#8217;ll shortly
see why that is a <em>very</em> useful approach for what we want to do. We also introduced the concept of a <code>db_t</code>, which similarity hold the <code>db_state_t</code> and not much else. The
idea is that <code>txn_t</code> and <code>db_t</code> are values that the user is using, while the <code>db_state_t</code> and <code>txn_state_t</code> are used by Gavran internally.</p>
</div>
<div id="txn_api" class="listingblock">
<div class="title"><code>gavran/db.h</code> - Transaction API declaration for our storage engine</div>
<div class="content">
<pre class="highlight"><code>typedef struct db_state db_state_t;
typedef struct txn_state txn_state_t;
typedef struct pages_hash_table pages_map_t;

typedef struct db {
  db_state_t *state;
} db_t;

typedef enum db_flags {
  db_flags_none                   = 0,
  txn_write                       = 1 &lt;&lt; 1,
  txn_read                        = 1 &lt;&lt; 2,
  txn_flags_apply_log             = 1 &lt;&lt; 3,
  txn_flags_commited              = 1 &lt;&lt; 4,
  db_flags_avoid_mmap_io          = 1 &lt;&lt; 5,
  db_flags_encrypted              = 1 &lt;&lt; 6,
  db_flags_page_validation_once   = 1 &lt;&lt; 7,
  db_flags_page_validation_always = 1 &lt;&lt; 8,
  db_flags_log_shipping_target    = 1 &lt;&lt; 9,
  db_flags_page_validation_none =
      db_flags_page_validation_once | db_flags_page_validation_always,
  db_flags_page_validation_none_mask =
      ~(db_flags_page_validation_once |
          db_flags_page_validation_always),
  db_flags_page_need_txn_working_set =
      db_flags_encrypted | db_flags_avoid_mmap_io

} db_flags_t;

typedef struct txn {
  txn_state_t *state;
  pages_map_t *working_set;
} txn_t;

result_t db_create(
    const char *filename, db_options_t *options, db_t *db);
result_t db_close(db_t *db);
enable_defer(db_close);

result_t txn_create(db_t *db, db_flags_t flags, txn_t *tx);
result_t txn_close(txn_t *tx);
enable_defer(txn_close);

result_t txn_commit(txn_t *tx);
result_t txn_raw_get_page(txn_t *tx, page_t *page);

result_t txn_raw_modify_page(txn_t *tx, page_t *page);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can imagine, the transaction API is going to be of enormous importance for our storage engine and as such, so we&#8217;ll spend some time fleshing out the API.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">How the code is structured?</div>
<div class="paragraph">
<p>I thought a lot about how to present the code in this book, because I don&#8217;t want to dump all the concerns that we have to deal with in building a storage engine on you all at
once. Once option was to show you a piece of code and how it changes over time. That ended up being pretty hard to work through. Similarly to trying to explain a change by
looking at the diff.</p>
</div>
<div class="paragraph">
<p>Instead, I&#8217;m structuring the code so we are looking at the complete solution, but I&#8217;ve broken apart the implementation so it is composed of individual functions. I&#8217;m only going
to be discussing the relevant functions at any given point in time. If I&#8217;m not calling out a particular function, you can assume that it has no impact on the functionality we
discussed and ignore it at this point. I&#8217;ll come back later and explain it in detail.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is where we start to put together the skeleton of Gavran. Let&#8217;s take a look at the first stage, creating a database, shown in <a href="#create_db"><code>db.c</code> - Creating an database instance</a>.</p>
</div>
<div id="create_db" class="listingblock">
<div class="title"><code>db.c</code> - Creating an database instance</div>
<div class="content">
<pre class="highlight"><code>result_t db_create(const char *path, db_options_t *options,
                   db_t *db) {
  db_options_t owned_options;
  db_initialize_default_options(&amp;owned_options);
  if (options) {
    ensure(db_validate_options(options, &amp;owned_options));
  }
  size_t done = 0;
  ensure(mem_calloc((void *)&amp;db-&gt;state, sizeof(db_state_t)));
  try_defer(db_close, db, done);
  ensure(pal_create_file(path, &amp;db-&gt;state-&gt;handle,
                         pal_file_creation_flags_none));
  try_defer(pal_close_file, db-&gt;state-&gt;handle, done);
  memcpy(&amp;db-&gt;state-&gt;options, &amp;owned_options, sizeof(db_options_t));
  ensure(pal_set_file_size(db-&gt;state-&gt;handle,
                           owned_options.minimum_size, UINT64_MAX));
  db-&gt;state-&gt;map.size = db-&gt;state-&gt;handle-&gt;size;
  if (!(owned_options.flags &amp; db_flags_avoid_mmap_io)) {
    ensure(pal_mmap(db-&gt;state-&gt;handle, 0, &amp;db-&gt;state-&gt;map));
  }
  try_defer(pal_unmap, db-&gt;state-&gt;map, done);
  ensure(db_initialize_default_read_tx(db-&gt;state));
  ensure(db_init(db));
  ensure(db_setup_page_validation(db));
  done = 1;  // no need to do resource cleanup
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <a href="#create_db"><code>db.c</code> - Creating an database instance</a> is <em>dense</em>, I&#8217;m afraid. There is quite a lot of stuff going here that would be discussed in future chapters, for now, let&#8217;s talk about the parts that
we are most interested on. We allocate the state for the database, create the file and set its minimum size, note that we <em>aren&#8217;t</em> setting the maximum size. If we were, and the
file was larger than the maximum size, we may discard parts of the data file. There is a lot of other things that are going here, setting up the database, creating default read
transaction, various options, etc. I&#8217;m ignoring all of these at this point.</p>
</div>
<div class="paragraph">
<p>I&#8217;m sorry for the code dump, but I assume that it is best to show everything as a single unit rather than tease and reveal them one piece at a time.
Let&#8217;s look at the actual implementation details. We&#8217;ll start by looking at the <code>db_state_t</code> and <code>txn_state_t</code> structs that we are using in <a href="#create_db"><code>db.c</code> - Creating an database instance</a>.
There are quite a lot of fields there that we&#8217;ll only need in the future. You can see the full details in <a href="#state_structs"><code>gavran/db.h</code> - Internal state structures</a>.</p>
</div>
<div class="paragraph">
<p>At this point, we can ignore all but the first three fields on each of the structs in <a href="#state_structs"><code>gavran/db.h</code> - Internal state structures</a>. The <code>db_state_t</code> contains the options for the database (currently we only
care for the <code>minimum_size</code> field), the file handle the the mapped memory in the <code>global_state</code>. The <code>txn_state_t</code> also has a copy of the <code>global_state</code> (and thus, the mapping).</p>
</div>
<div id="state_structs" class="listingblock">
<div class="title"><code>gavran/db.h</code> - Internal state structures</div>
<div class="content">
<pre class="highlight"><code>typedef struct db_state {
  db_options_t options;
  span_t map;
  uint64_t number_of_pages;
  uint64_t last_tx_id;
  file_handle_t *handle;
  wal_state_t wal_state;
  txn_state_t *last_write_tx;
  uint64_t active_write_tx;
  txn_state_t *default_read_tx;
  txn_state_t *transactions_to_free;
  uint64_t *first_read_bitmap;
  uint64_t original_number_of_pages;
  uint64_t oldest_active_tx;
} db_state_t;

typedef struct txn_state {
  uint64_t tx_id;
  db_state_t *db;
  span_t map;
  uint64_t number_of_pages;
  pages_map_t *modified_pages;
  cleanup_callback_t *on_forget;
  cleanup_callback_t *on_rollback;
  txn_state_t *prev_tx;
  txn_state_t *next_tx;
  void *shipped_wal_record;
  uint64_t can_free_after_tx_id;
  struct {
    reusable_buffer_t buffer;
    btree_stack_t stack;
  } tmp;
  uint32_t usages;
  db_flags_t flags;
} txn_state_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#create_db"><code>db.c</code> - Creating an database instance</a> we call to <code>db_validate_options()</code> to validate the options and copy the user defined values to our own copy. I&#8217;m showing the code in <a href="#db_validate_options"><code>db.c</code> - Validating the database&#8217;s options and default options initialization</a>,
note that this is a simplified version of what we&#8217;ll have in the future. We&#8217;ll update this function in the future.
You can see in <a href="#db_validate_options"><code>db.c</code> - Validating the database&#8217;s options and default options initialization</a> that the code validates the provided settings and copy them to our own <code>db_options_t</code> struct.</p>
</div>
<div class="paragraph">
<p>The user can also just pass null for the <code>options</code> and we&#8217;ll use the default ones. In <a href="#db_validate_options"><code>db.c</code> - Validating the database&#8217;s options and default options initialization</a> you can also see that I&#8217;m using <code>implementation_detail</code> macro. This
is just to let the compiler know that this is a hidden function which shouldn&#8217;t be exported from the library.
<a href="#db_validate_options"><code>db.c</code> - Validating the database&#8217;s options and default options initialization</a> also shows the default options initialization. Right now we don&#8217;t have much there, but it will grow over time.</p>
</div>
<div class="paragraph">
<p>After handling the <code>options</code>, <a href="#create_db"><code>db.c</code> - Creating an database instance</a> then uses our PAL interface to create the file, ensure that it is a match to the minimum size we require and map it to memory. You&#8217;ll note
that there is actually quite a few resources that are involved in the process. The use of <code>ensure</code> and <code>try_defer</code> allows us to dramatically reduce the amount of error handing code that
we would other need to manage. We actually have multiple <code>try_defer</code> calls and we use <code>done</code> to indicate that the function completed successfully and we should <em>not</em> clean up those
resources. Otherwise, everything gets cleaned up. The <code>try_defer</code> calls are guaranteed to be called in reversed order of declaration, so we can be sure of the destruction order.</p>
</div>
<div id="db_validate_options" class="listingblock">
<div class="title"><code>db.c</code> - Validating the database&#8217;s options and default options initialization</div>
<div class="content">
<pre class="highlight"><code>implementation_detail result_t db_validate_options(
    db_options_t *user_options, db_options_t *default_options) {
  if (user_options-&gt;minimum_size)
    default_options-&gt;minimum_size = user_options-&gt;minimum_size;

  if (default_options-&gt;minimum_size &lt; 128 * 1024) {
    failed(EINVAL,
           msg("The minimum_size cannot be less than the minimum "
               "value of 128KB"),
           with(default_options-&gt;minimum_size, "%lu"));
  }

  return success();
}

implementation_detail void db_initialize_default_options(
    db_options_t *options) {
  memset(options, 0, sizeof(db_options_t));
  options-&gt;minimum_size = 1024 * 1024;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next chapter, we are going to focus on <code>db_init()</code> and do a lot of work there, but for now, I want to focus on transactions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_transactions">Implementing transactions</h3>
<div class="paragraph">
<p>You already saw the raw structs to create a transaction in <a href="#create_db"><code>db.c</code> - Creating an database instance</a>, now we want to actually build real transactions API. Before we can do that, I want to go over what
transactions <em>are</em>. A transaction in the context of Gavran is a set of changes that are applied to the database. Until they are applied, they are not visible to any
other transactions.</p>
</div>
<div class="paragraph">
<p>Before we dive into the details of how a transaction is implemented in code, I want to talk about what we are trying to <em>do</em>. The transactions that we&#8217;ll build in this
chapter is mostly concerned with managing a list of modified pages. The idea is that you&#8217;ll always go through the transaction to modify pages, it will manage them for
you and eventually commit them. The overall structure can be seen in <a href="#tx-modified-pages">The layout of a transaction with 2 modified pages</a>.</p>
</div>
<div class="paragraph">
<p>Using the Copy On Write mode tha we discussed earlier, whenever we want to modify a page, we&#8217;ll copy it to the side and make the modifications. Once all the changes
in the transaction are completed, we&#8217;ll persist them all at once. Consider the implications of such a system. How would a rollback look in this case?
Simply free the copies, no one else had any access to them, so nothing needs to be done.</p>
</div>
<div id="tx-modified-pages" class="imageblock">
<div class="content">
<img src="../imgs/tx-modified-pages.png" alt="tx modified pages">
</div>
<div class="title">Figure 3. The layout of a transaction with 2 modified pages</div>
</div>
<div class="paragraph">
<p>As for commit, once all the changes has been written to the file, we are done. We saw in the previous chapter that it takes significant effort to make sure that a
change to the file metadata is persisted. Changes to the file&#8217;s data are by no means easier. We are going to deal with a single facet of the ACID properties in
this chapter, and atomic commit.</p>
</div>
<div class="paragraph">
<p><a href="#txn_create"><code>txn.c</code> - Creating a transaction</a> shows how we create a transaction. A <code>txn_t</code> is mostly just a pointer to <code>txn_state_t</code>, which holds the details about the transaction as well as the hash table to hold
the modified pages. This is initialized by the <code>pagesmap_new()</code> call. You&#8217;ll note that we are passing a <code>flags</code> parameter to the <code>txn_create()</code>, but not doing much of it. I&#8217;m currently
ignoring that but we&#8217;ll use that to set various behaviors on the transaction, such as whatever it is read only or allowed to write.</p>
</div>
<div class="paragraph">
<p>One of the key responsibilities of the transaction is managing the work of <code>txn_modify_page</code>, to handle that properly, we need to store the modified
pages in the transaction and be able to access them quickly.  Listing 4.7 has the details on how we manage that.</p>
</div>
<div id="txn_create" class="listingblock">
<div class="title"><code>txn.c</code> - Creating a transaction</div>
<div class="content">
<pre class="highlight"><code>result_t txn_create(db_t *db, db_flags_t flags, txn_t *tx) {
  errors_assert_empty();

  size_t cancel_defer = 0;
  txn_state_t *state;
  ensure(mem_calloc((void *)&amp;state, sizeof(txn_state_t)));
  try_defer(free, state, cancel_defer);

  ensure(pagesmap_new(8, &amp;state-&gt;modified_pages));

  state-&gt;flags = flags | db-&gt;state-&gt;options.flags;
  state-&gt;db = db-&gt;state;
  state-&gt;map = db-&gt;state-&gt;map;
  state-&gt;number_of_pages = db-&gt;state-&gt;number_of_pages;

  tx-&gt;state = state;
  cancel_defer = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#txn_create"><code>txn.c</code> - Creating a transaction</a> shows the setup of a new transaction, but it probably wouldn&#8217;t make sense without looking at the most common actions that we&#8217;ll have in a transaction <code>txn_raw_get_page()</code>
and <code>txn_raw_modify_page()</code>. Let&#8217;s look at them first now.
When using a transaction, <code>txn_raw_get_page()</code> is initially very similar to using <code>pages_get()</code>, so why do we have two layers of the API? The key difference is that <code>pages_get()</code> has
global scope, while <code>txn_raw_get_page()</code> is scoped to a transaction. Look back at <a href="#tx-modified-pages">The layout of a transaction with 2 modified pages</a> and consider how that works. When we are calling <code>txn_raw_get_page()</code>, we first
need to check if this transaction has a modified copy of the page in question and only if it does will we go to the data file. You can see how that looks like in <a href="#txn_raw_get_page"><code>txn.c</code> - Get a page in the scope of the transaction, either locally modified copy or directly from the data file.</a>.</p>
</div>
<div id="txn_raw_get_page" class="listingblock">
<div class="title"><code>txn.c</code> - Get a page in the scope of the transaction, either locally modified copy or directly from the data file.</div>
<div class="content">
<pre class="highlight"><code>result_t txn_raw_get_page(txn_t *tx, page_t *page) {
  errors_assert_empty();
  page-&gt;address = 0;
  if (pagesmap_lookup(tx-&gt;state-&gt;modified_pages, page))
    return success();

  if (!page-&gt;address) {
    if (!page-&gt;number_of_pages) page-&gt;number_of_pages = 1;
    ensure(pages_get(tx, page));
  }

  return success();
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note about multi threading</div>
<div class="paragraph">
<p>We don&#8217;t have any at this point, we&#8217;ll deal with them at a much later part of this book. Right now, the code isn&#8217;t going to be able to handle multiple threads.
The atomic property that we&#8217;ll have is about sequential or interleaved transactions. Gavran <em>will</em> have all of the ACID properties, including safe usage under multi threaded code,
mind you. I&#8217;m just building things one stage at a time, otherwise we&#8217;ll drown in too much complexity, all at once.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>With <code>txn_raw_get_page()</code> our of the way, let&#8217;s look at how we are going to implement <code>txn_raw_modify_page()</code>. We are going to use a structure very similar to <a href="#create_and_write_file"><code>test.c</code> - Reading and writing using the paging API</a>.
The fact that we are never modifying the page directly is of enormous importance to the design of Gavran. This strategy is called Copy On Write (COW) and it will serve as the basis for
implementing one of the core ACID properties, Isolation.</p>
</div>
<div class="paragraph">
<p>In <a href="#txn_raw_modify_page"><code>txn.c</code> - Implementing Copy on Write in the transaction for page modifications.</a> <code>txn_raw_modify_page()</code> will first look in the <code>modified_pages</code> of the transaction and if we haven&#8217;t already modified the page in question, we&#8217;ll get it from
the data file. I&#8217;m building <code>txn_raw_modify_page()</code> on top of <code>txn_raw_get_page()</code> so it will benefit from any changes that we&#8217;ll make to the <code>txn_raw_get_page()</code> in the future. Once we
have the original page, we allocate a buffer, copy the memory to the new location and register the new page in the transaction&#8217;s <code>modified_pages</code>.</p>
</div>
<div class="paragraph">
<p>IN <a href="#txn_raw_modify_page"><code>txn.c</code> - Implementing Copy on Write in the transaction for page modifications.</a> we are also setting up the modified page with a pointer to the <em>old</em> version of the data. In other words, we are able to look into what this page used to be
like, before any modifications. This will become very important when the times come to do proper committing of the transaction&#8217;s data.</p>
</div>
<div id="txn_raw_modify_page" class="listingblock">
<div class="title"><code>txn.c</code> - Implementing Copy on Write in the transaction for page modifications.</div>
<div class="content">
<pre class="highlight"><code>result_t txn_raw_modify_page(txn_t *tx, page_t *page) {
  errors_assert_empty();
  if (pagesmap_lookup(tx-&gt;state-&gt;modified_pages, page)) {
    return success();
  }

  page_t original = {.page_num = page-&gt;page_num};
  ensure(txn_raw_get_page(tx, &amp;original));
  if (!page-&gt;number_of_pages) page-&gt;number_of_pages = 1;
  size_t done = 0;
  ensure(mem_alloc_page_aligned(&amp;page-&gt;address,
                                PAGE_SIZE * page-&gt;number_of_pages));
  try_defer(free, page-&gt;address, done);

  memcpy(page-&gt;address, original.address,
         (PAGE_SIZE * page-&gt;number_of_pages));
  page-&gt;previous = original.address;
  ensure(pagesmap_put_new(&amp;tx-&gt;state-&gt;modified_pages, page),
         msg("Failed to allocate entry"));
  done = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to note that calling <code>txn_raw_get_page()</code>, <code>txn_raw_modify_page()</code> and then <code>txn_raw_get_page()</code> on the same page is something
that you need to be aware of. The first and last <code>txn_raw_get_page</code> will return <em>different</em> values. I haven&#8217;t found this a real issue in practice, but something
that you might want to keep in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="_managing_the_transaction_state_with_a_hash_table">Managing the transaction state with a hash table</h3>
<div class="paragraph">
<p>The most important piece in <code>txn_raw_modify_page()</code> is the management of the <code>modified_pages</code> on the transaction. This is a pointer to <code>pages_map_t</code>, which is a hash table for
the modified pages in the transaction.
I have to admit, given that I write databases for a living, I was highly amused by how reluctant I was to implement a hash table. I have written
a few, so it isn&#8217;t a new task. I&#8217;m also doing that while implementing a <em>storage engine</em>, which is closely related.</p>
</div>
<div class="paragraph">
<p>The good news here is that this hash table only need to support <code>pagesmap_put_new</code> and <code>pagesmap_lookup</code>, we don&#8217;t need to handle deletions at all. That makes the overall complexity much easier.</p>
</div>
<div class="paragraph">
<p>Given that the readers of this book are likely interested, I&#8217;m going to go for an open addressing with linear probing model. And one of the
key features that I care about is avoiding the usual pointer caching that you&#8217;ll typically see in hash tables. Data locality is a huge performance boost and I want some of that. This
is not meant to be a generic hash table, I created it specifically to hold <code>page_t</code> values indexed by their <code>page_num</code>.
Since <code>page_t</code> already contain the key, I can simplify my implementation significantly and the cost of lookup is likely very small. That might seems strange if you are coming from a language
where you&#8217;ll have more separation between the data containers and the values.</p>
</div>
<div class="paragraph">
<p><code>Dictionary&lt;K,V&gt;</code> is a prime example of that. You have the container data and the data held by the container and they can live very far apart. That is not the case here, we always keep them
 very close by. You can see how the <code>pages_map_t</code> is defined in <a href="#pages_map_t"><code>gavran/internal.h</code> - The hash table definition</a></p>
</div>
<div id="pages_map_t" class="listingblock">
<div class="title"><code>gavran/internal.h</code> - The hash table definition</div>
<div class="content">
<pre class="highlight"><code>typedef struct pages_hash_table {
  size_t number_of_buckets;
  size_t count;
  size_t resize_required;
  page_t entries[];
} pages_map_t;

result_t pagesmap_put_new(pages_map_t **table_p, page_t *page);
bool pagesmap_lookup(pages_map_t *table, page_t *page);
bool pagesmap_get_next(
    pages_map_t *table, size_t *state, page_t **page);
result_t pagesmap_new(
    size_t initial_number_of_elements, pages_map_t **table);</code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;m going to skip explaining <a href="https://en.wikipedia.org/wiki/Hash_table">how hash tables work</a>, I assume that you either have a grasp on that
or is able to learn that from other sources. I&#8217;ll mention that I&#8217;m using a hash table implementation strategy called
<a href="https://en.wikipedia.org/wiki/Linear_probing">linear probing</a>. This refers to how the hash table handles collisions. Instead of creating a
linked list of values on hash collision, we&#8217;ll move to the next location in the array. That means that we are going to have good locality
of reference when doing the search, the entire hash table is typically a single allocation and the <code>pagesmap_lookup</code> and <code>pagesmap_put_new</code> implementations
are straightforward.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Recommended reading</div>
<div class="paragraph">
<p>If you want to really dig down into hash table, you might want to read <a href="https://www.amazon.com/dp/B07NKYSSR1/">The Joys of Hashing</a> which does a great job of covering most aspects
of hash tables design and implementation with very clear code and the background details that explain the <em>why</em> of certain decisions.</p>
</div>
<div class="paragraph">
<p>You may also want to read <a href="http://craftinginterpreters.com/hash-tables.html">the excellent hash table chapter</a> in Crafting Interpreters, which is much shorter, but does a great job
explaining how hash tables work.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The downside of linear probing and open addressing in general is that the deletes tend to be more complex to implement than an
implementation that uses chaining. The good news is that we don&#8217;t need to worry about that here, so the complexity is greatly reduced.</p>
</div>
<div class="paragraph">
<p>There are a few other things to consider for this case:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The key for the hash is the page number, these are <code>uint64_t</code> values and it is very likely that you&#8217;ll get consecutive values.
As such, we don&#8217;t try to be fancy with the hash function, we simply modulus the page number with the number of buckets in the
hash table and start the search there.</p>
</li>
<li>
<p>The rule on collision goes like this. Whenever a put is attempted that collided, we&#8217;ll move to the next available spot that
is free. In other words, the worst case scenario for this sort of hash table is having to scan through all the buckets.</p>
</li>
<li>
<p>This is where the load factor comes into play. Given that the page numbers are likely to cluster around specific values, the
empty buckets that remain act as backstop to avoid iterating through all the buckets.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In <a href="#pagesmap_new_and_lookup"><code>hashtable.h</code> - Creating a hash table and looking up a single value</a> you can see how we create a new hash table using <code>pagesmap_new()</code> and looking up a single value using <code>pagesmap_lookup()</code>. The
transaction&#8217;s <code>modified_pages</code> field is setup via <code>pagesmap_new()</code> in <code>txn_create()</code>. We are going to be using this hash table a <em>lot</em>. It is going
to serve as one of the most fundamental pieces in the transaction&#8217;s implementation.</p>
</div>
<div class="paragraph">
<p>One thing to note about the implementation here, I have chosen to favor readability over performance. There are several low hanging
fruits that we can utilize here that will likely help performance to some degree. Using shifts instead of modulus (since our <code>number_of_entries</code>
can be assumed to be a power of two) is a simple one. We might get to that when we get to the benchmarks portion of this book, for now, simpler
code is the key.</p>
</div>
<div id="pagesmap_new_and_lookup" class="listingblock">
<div class="title"><code>hashtable.h</code> - Creating a hash table and looking up a single value</div>
<div class="content">
<pre class="highlight"><code>result_t pagesmap_new(
    size_t initial_number_of_elements, pages_map_t **table) {
  size_t initial_size = sizeof(pages_map_t) +
                        initial_number_of_elements * sizeof(page_t);
  ensure(mem_calloc((void *)table, initial_size));
  (*table)-&gt;number_of_buckets = initial_number_of_elements;
  return success();
}

bool pagesmap_lookup(pages_map_t *table, page_t *page) {
  if (!table) return false;
  uint64_t page_num = page-&gt;page_num;
  if (!table-&gt;number_of_buckets) return false;
  size_t starting_pos = (size_t)(page_num % table-&gt;number_of_buckets);
  for (size_t i = 0; i &lt; table-&gt;number_of_buckets; i++) {
    size_t index = (i + starting_pos) % table-&gt;number_of_buckets;
    if (!table-&gt;entries[index].address) {
      // empty value, so there is no match
      return false;
    }
    if (table-&gt;entries[index].page_num == page_num) {
      memcpy(page, &amp;table-&gt;entries[index], sizeof(page_t));
      return true;
    }
  }
  return false;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#pagesmap_new_and_lookup"><code>hashtable.h</code> - Creating a hash table and looking up a single value</a> you can see that creating a new hash table is simple, we allocate a single buffer, for the <code>pages_map_t</code> as well
as the <code>entries</code> immediately following it. That is why we have an "empty" array at the end of <code>pages_map_t</code>, that indicates to the compiler
that the value of the field is the area immediately following the struct.</p>
</div>
<div class="paragraph">
<p>For lookups, we simply scan through the <code>entries</code> array, the starting location depends on the page that we are looking for. But if we found a value
that isn&#8217;t the page we are looking for, we know that we need to continue scanning. This is what open address means, that the value can be (because
of collisions) further away from where it is meant to be.</p>
</div>
<div class="paragraph">
<p>This might make more sense when we&#8217;ll look into how we are going to implement <em>putting</em> a value into the hash table.
This is the more complex operation because we may need to resize the hash table if the load factor grows big enough. The details are in <a href="#pagesmap_put_new"><code>hashtable.h</code> - Put a new value inside the hash table</a>.</p>
</div>
<div class="paragraph">
<p><a href="#pagesmap_put_new"><code>hashtable.h</code> - Put a new value inside the hash table</a> starts by expanding the hash table if needed, then scans through the table for an empty location that we can place the new value in,
starting with the <code>page_num</code> modulus the size of the table. It is an error to add a value that already exists in the table. When we add a value, we
check if the <em>next</em> call to <code>pagesmap_put_new()</code> should expand the table. This is done by checking if we are over 75% full. As mentioned, I&#8217;m not going to
explain how hash tables work, if you have questions on the implementation, there are more than enough resources about hash tables available.</p>
</div>
<div id="pagesmap_put_new" class="listingblock">
<div class="title"><code>hashtable.h</code> - Put a new value inside the hash table</div>
<div class="content">
<pre class="highlight"><code>result_t pagesmap_put_new(pages_map_t **table_p, page_t *page) {
  if ((*table_p)-&gt;resize_required) {
    ensure(pagesmap_expand_table(table_p));
  }
  pages_map_t *state  = *table_p;
  uint64_t page_num   = page-&gt;page_num;
  size_t starting_pos = (size_t)(page_num % state-&gt;number_of_buckets);
  for (size_t i = 0; i &lt; state-&gt;number_of_buckets; i++) {
    size_t index = (i + starting_pos) % state-&gt;number_of_buckets;
    if (state-&gt;entries[index].page_num == page_num &amp;&amp;
        state-&gt;entries[index].address) {
      failed(EINVAL, msg("Page already exists in table"),
          with(page_num, "%lu"));
    }

    if (!state-&gt;entries[index].address) {
      state-&gt;entries[index].page_num = page_num;
      memcpy(&amp;state-&gt;entries[index], page, sizeof(page_t));
      state-&gt;count++;
      size_t load_factor     = (state-&gt;number_of_buckets * 3 / 4);
      state-&gt;resize_required = (state-&gt;count &gt; load_factor);
      return success();
    }
  }
  failed(ENOSPC, msg("No room for entry, should not happen"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s look how expanding the table works. We are going to use simple doubling of the hash table whenever we get to 75% load factor. In other words, if we
start with 8 entries by default, we&#8217;ll increase to 16 when we get to the 7th entry, to 32 when we get to 13, and 64 when we get to 25.
Note that since we are actually using <code>page_t</code> as our entries, we have to take into account it is somewhat large, on 64 bits, it is going to
be 32 bytes.</p>
</div>
<div class="paragraph">
<p><a href="#pagesmap_expand_table"><code>hashtable.h</code> - Doubling the size of the hash table</a> shows how we double the size of the table. We allocate a new buffer, twice as large, iterate over the old hash table using <code>pagesmap_get_next()</code>
and add to the new hash table using <code>pagesmap_put_new()</code>, pretty simple, overall.
We are using <code>mem_calloc()</code> to allocate the memory, but couldn&#8217;t we use <code>mem_realloc()</code> instead, to reallocate the buffer without
needing to copy the data gain? The answer is no. Part of the expansion of the hash table means that we need to hash the entries <em>again</em>, placing them in
new locations, based on the new size.</p>
</div>
<div id="pagesmap_expand_table" class="listingblock">
<div class="title"><code>hashtable.h</code> - Doubling the size of the hash table</div>
<div class="content">
<pre class="highlight"><code>static result_t pagesmap_expand_table(pages_map_t **state_ptr) {
  pages_map_t *state           = *state_ptr;
  size_t new_number_of_entries = state-&gt;number_of_buckets * 2;
  size_t new_size =
      sizeof(pages_map_t) + (new_number_of_entries * sizeof(page_t));
  pages_map_t *new_state;
  ensure(mem_calloc((void *)&amp;new_state, new_size));
  size_t done = 0;
  try_defer(free, new_state, done);
  new_state-&gt;number_of_buckets = new_number_of_entries;
  size_t iter_state            = 0;
  page_t *p;
  while (pagesmap_get_next(state, &amp;iter_state, &amp;p)) {
    ensure(pagesmap_put_new(&amp;new_state, p));
  }
  *state_ptr = new_state;  // update caller's reference
  free(state);
  done = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few interesting implications to the way we built <code>pagesmap_expand_table()</code>. First, any <code>pagesmap_put_new()</code> may cause the table to shift, that is why
we send an indirect pointer to the function.
You cannot mix <code>pagesmap_get_next()</code> and <code>pagesmap_put_new()</code>, iteration and mutations generally don&#8217;t mix with one another.</p>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s look at <code>pagesmap_get_next()</code>, shown in <a href="#pagesmap_get_next"><code>hashtable.h</code> - Iterating over the hash table</a>.
The implementation simple scans through the table, but we use the externally provided <code>state</code> variable to hold our state between calls.
We expect <code>pagesmap_get_next()</code> to be used as it is used in <a href="#pagesmap_expand_table"><code>hashtable.h</code> - Doubling the size of the hash table</a>. Initialize the <code>iter_state</code> value to <code>0</code> and call <code>pagesmap_get_next()</code> until it returns <code>false</code>.</p>
</div>
<div class="paragraph">
<p>The hash table implementation we have here is a pretty basic one, intentionally. You can see more options on how I could have implemented it in
<a href="https://www.amazon.com/dp/20/B07NKYSSR1">The Joys of Hashing</a>, but the idea is to get this working properly and fix any performance issues later. That said, I don&#8217;t expect to
have too many problems around the hash table implementation, but I was surprised in the past&#8230;&#8203;</p>
</div>
<div id="pagesmap_get_next" class="listingblock">
<div class="title"><code>hashtable.h</code> - Iterating over the hash table</div>
<div class="content">
<pre class="highlight"><code>bool pagesmap_get_next(
    pages_map_t *table, size_t *state, page_t **page) {
  if (!table) return false;
  for (; *state &lt; table-&gt;number_of_buckets; (*state)++) {
    if (!table-&gt;entries[*state].address) continue;
    *page = &amp;table-&gt;entries[*state];
    (*state)++;
    return true;
  }
  *page = 0;
  return false;
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Memory management in Linux</div>
<div class="paragraph">
<p>By default, Linux will never fail a <code>malloc()</code>. In other words, when calling <code>malloc()</code>, you&#8217;ll never get <code>NULL</code> back. If you care to know more about
this behavior, search for <a href="https://lwn.net/Articles/317814/">over commit and the OOM killer</a>. A good paper on why over commit is required is
<a href="https://www.microsoft.com/en-us/research/publication/a-fork-in-the-road/">"A fork() in the road"</a>.</p>
</div>
<div class="paragraph">
<p>In essence, too much software simply assume that all memory allocations will succeed. Even the Linux kernel has this an issue with
<a href="https://lwn.net/Articles/627419/">this kind of expectation</a>.</p>
</div>
<div class="paragraph">
<p>The problem with not failing <code>malloc()</code> is that Linux cannot just magic some more RAM, and even with swap, you&#8217;ll eventually run out. The issue
is how it <em>handles</em> this scenario. And the way Linux work is that when you use too much memory, Linux will select a victim process and <em>kill</em> it
to reutilize the memory it uses. The situation is worse because the triggering event that would cause the OOM killer to run and select a victim
to kill can be a totally unrelated process.</p>
</div>
<div class="paragraph">
<p>That has serious implications for people building robust software. I can&#8217;t catch a <code>SIGKILL</code> and ignore it, after all. But I could change
my system behavior to handle memory allocation failure. There are configuration flag that you can use to avoid this behavior, but they
have their own side effects and they are global. In other words, they impact the whole system. If you are running a single process, or
as we are doing now, a library, that isn&#8217;t going to be useful for you.</p>
</div>
<div class="paragraph">
<p>The code I&#8217;m writing here assume that it is possible to get memory allocation failures and handle them appropriately. We are currently
allocating directly from the system, but that is likely to change as the implementation proceeds. We&#8217;ll start managing the memory much
more closely and will be able to react properly to low memory events.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_committing_and_closing_the_transaction">Committing and closing the transaction</h3>
<div class="paragraph">
<p>Now that we have a way to keep track of the modified pages in the transaction, the next stage is to figure out how to commit those changes to disk. It turns out
that most of the work was already done for us. Listing 4.11 shows how to "commit" a transaction.
I&#8217;m using commit in quotes here because this is not respecting any of the transaction properties, but we are laying down the foundation for actual transactions.</p>
</div>
<div class="paragraph">
<p>There really isn&#8217;t much to do in <a href="#txn_commit"><code>txn.c</code> - Implementing commit transaction by writing modified pages to disk and closing it by freeing the memory of the transaction</a>, to be honest. We scan through the table of modified pages and write them to the file using the <code>pal_write_file()</code> function
we looked at in the previous chapter. If there is an error, we return, and that is about it. Note that we don&#8217;t have any attempt to for durability, atomicity, etc.</p>
</div>
<div class="paragraph">
<p>After calling <code>txn_commit()</code>, we need to call <code>txn_close()</code> to cleanup all the resources for the transaction. If we want to rollback the transaction, we can call <code>txn_close()</code>
without calling <code>txn_commit()</code>.</p>
</div>
<div id="txn_commit" class="listingblock">
<div class="title"><code>txn.c</code> - Implementing commit transaction by writing modified pages to disk and closing it by freeing the memory of the transaction</div>
<div class="content">
<pre class="highlight"><code>result_t txn_commit(txn_t *tx) {
  errors_assert_empty();

  size_t iter_state = 0;
  page_t *p;
  while (
      pagesmap_get_next(tx-&gt;state-&gt;modified_pages, &amp;iter_state, &amp;p)) {
    ensure(pages_write(tx-&gt;state-&gt;db, p));
  }

  return success();
}

result_t txn_close(txn_t *tx) {
  if (!tx || !tx-&gt;state) return success();

  size_t iter_state = 0;
  page_t *p;
  while (
      pagesmap_get_next(tx-&gt;state-&gt;modified_pages, &amp;iter_state, &amp;p)) {
    free(p-&gt;address);
    p-&gt;address = 0;
  }
  free(tx-&gt;state-&gt;modified_pages);
  free(tx-&gt;state);

  tx-&gt;state = 0;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more sophisticated system will allow us to reuse the allocated memory from one transaction to the next, but I&#8217;m reserving those kind of behavior for the
future, when I can see benchmark results. Get it working, get it working <em>right</em> and only then get it working fast.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_transaction_api">Using the transaction API</h3>
<div class="paragraph">
<p>The last thing that we&#8217;ll do in this chapter is put everything together. <a href="#create_and_write_with_tx_api"><code>test.c</code> - Reading and writing using the transaction API</a> shows how we can now write <a href="#create_and_write_file"><code>test.c</code> - Reading and writing using the paging API</a> using the new API.</p>
</div>
<div id="create_and_write_with_tx_api" class="listingblock">
<div class="title"><code>test.c</code> - Reading and writing using the transaction API</div>
<div class="content">
<pre class="highlight"><code>static result_t validate_message(db_t* db, bool expected_value) {
  txn_t read_tx;
  ensure(txn_create(db, TX_READ, &amp;read_tx));
  defer(txn_close, read_tx);
  page_t page = {.page_num = 3};
  ensure(txn_raw_get_page(&amp;read_tx, &amp;page));
  bool actual_value_match =
      strcmp("Hello Gavran!", page.address) == 0;
  ensure(actual_value_match == expected_value);
  return success();
}

static result_t create_and_write_with_tx_api(const char* path) {
  db_t db;
  db_options_t options = {.minimum_size = 128 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  defer(db_close, db);

  ensure(validate_message(&amp;db, false));  // no value
  {
    txn_t write_tx;
    ensure(txn_create(&amp;db, TX_WRITE, &amp;write_tx));
    defer(txn_close, write_tx);
    page_t page = {.page_num = 3};
    ensure(txn_raw_modify_page(&amp;write_tx, &amp;page));
    strcpy(page.address, "Hello Gavran!");

    ensure(validate_message(&amp;db, false));  // no value after write
    ensure(txn_commit(&amp;write_tx));
    ensure(validate_message(&amp;db, true));  // value there after commit
  }

  ensure(validate_message(&amp;db, true));  // value there after tx_close
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#create_and_write_with_tx_api"><code>test.c</code> - Reading and writing using the transaction API</a>, you&#8217;ll note that we are using multiple transactions. One to do the writes and one for the reads. We actually got a <em>very</em> limited form
of isolation. Until the <code>write_tx</code> is committed, the transactions created in <code>validate_message()</code> not see any of its changes and it is committed. I wrote it in this manner to show
how we are starting to get real features.</p>
</div>
<div class="paragraph">
<p>The reason the code in <a href="#create_and_write_with_tx_api"><code>test.c</code> - Reading and writing using the transaction API</a> is able to create isolation between transactions is that the <code>write_tx</code> doesn&#8217;t modify the file directly, it modifies a
<em>copy</em> of the page and the act of committing the transaction make it apparent to the next transaction.</p>
</div>
<div class="paragraph">
<p>You can also see that I&#8217;m passing <code>TX_WRITE</code> and <code>TX_READ</code> flags to the <code>txn_create</code> function. At the moment, it does nothing, but it will become important down the line.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit tests</h3>
<div class="paragraph">
<p>Finally, before we close this chapter, we need to make sure that the software <em>works</em>.
Our next topic is going to be&#8230;&#8203; managing the pages and disk space.</p>
</div>
<div id="tests_ch04" class="listingblock">
<div class="title"><code>test.c</code> - Testing the transactions API and copy of write</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">describe(db_basic_tests) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("can read and write to files using paging") {
    assert(create_and_write_file("/tmp/db/phones"));
  }

  it("can read and write to files using transactions") {
    assert(create_and_write_with_tx_api("/tmp/db/phones"));
  }

  it("can create db and tx") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/phones", &amp;options, &amp;db));
    defer(db_close, db);
    txn_t read_tx;
    assert(txn_create(&amp;db, TX_READ, &amp;read_tx));
    defer(txn_close, read_tx);
  }

  it("can write data") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/phones", &amp;options, &amp;db));
    defer(db_close, db);
    {
      txn_t write_tx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;write_tx));
      defer(txn_close, write_tx);
      page_t p = {.page_num = 3};
      assert(txn_raw_modify_page(&amp;write_tx, &amp;p));
      strcpy(p.address, "Hello Gavran");
      assert(txn_commit(&amp;write_tx));
    }
    {
      txn_t read_tx;
      assert(txn_create(&amp;db, TX_READ, &amp;read_tx));
      defer(txn_close, read_tx);
      page_t p = {.page_num = 3};
      assert(txn_raw_get_page(&amp;read_tx, &amp;p));

      assert(strcmp(p.address, "Hello Gavran") == 0);
    }
  }

  it("can persist changes across restarts") {
    {
      db_t db;
      db_options_t options = {.minimum_size = 128 * 1024};
      assert(db_create("/tmp/db/phones", &amp;options, &amp;db));
      defer(db_close, db);
      {
        txn_t write_tx;
        assert(txn_create(&amp;db, TX_WRITE, &amp;write_tx));
        defer(txn_close, write_tx);
        page_t p = {.page_num = 3};
        assert(txn_raw_modify_page(&amp;write_tx, &amp;p));
        strcpy(p.address, "Hello Gavran");
        assert(txn_commit(&amp;write_tx));
      }
    }
    {
      db_t db;
      db_options_t options = {.minimum_size = 128 * 1024};
      assert(db_create("/tmp/db/phones", &amp;options, &amp;db));
      defer(db_close, db);
      {
        txn_t read_tx;
        assert(txn_create(&amp;db, TX_READ, &amp;read_tx));
        defer(txn_close, read_tx);
        page_t p = {.page_num = 3};
        assert(txn_raw_get_page(&amp;read_tx, &amp;p));

        assert(strcmp(p.address, "Hello Gavran") == 0);
      }
    }
  }

  it("without commit, no data is changed") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/phones", &amp;options, &amp;db));
    defer(db_close, db);
    {
      txn_t write_tx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;write_tx));
      defer(txn_close, write_tx);
      page_t p = {.page_num = 3};
      assert(txn_raw_modify_page(&amp;write_tx, &amp;p));
      strcpy(p.address, "Hello Gavran");
      // explicitly not committing
      // assert(txn_commit(&amp;write_tx));
    }
    {
      txn_t read_tx;
      assert(txn_create(&amp;db, TX_READ, &amp;read_tx));
      defer(txn_close, read_tx);
      page_t p = {.page_num = 3};
      assert(txn_raw_get_page(&amp;read_tx, &amp;p));

      assert(*(uint64_t*)p.address == 0);
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
  <ul style="list-style-type: none;">
    <li><a class="footer-text" href="../index.html">Table of contents</a></li>
    <li><a class="footer-text" href="./ch03.html">Previous chapter</a></li>
    <li><a class="footer-text" href="./ch05.html">Next chapter</a></li>
  </ul>
</div>
</body>
</html>