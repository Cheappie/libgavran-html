<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Dynamic file growth</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_dynamic_file_growth">Dynamic file growth</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We are in Chapter 10 and we still have a fairly big limit in Gavran. We have to define, upfront, the size of the data file. Once we hit the limit of the file size, we
will start getting <code>ENOSPC</code> errors when we try to allocate new pages. We are currently using a default of 1MB file, which means that we have merely 128 pages to work
with. That is&#8230;&#8203; not ideal. Let&#8217;s see how we can fix that.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Considerations for file size growth</div>
<div class="paragraph">
<p>It turns out that there is a <em>lot</em> of things to consider when thinking about how Gavran should increase its file size. These range from technical considerations
to social ones.</p>
</div>
<div class="paragraph">
<p>For example, one easy option is to specify what would be the maximum size of the file. We can specify a high value, such as 10 GB or a 100 GB and be done with it.
That is how LMDB works, for example. That has a limit in the sense that you must restart the DB when the maximum size is hit. Another issue is how you allocate
disk space.</p>
</div>
<div class="paragraph">
<p>LMDB uses a neat trick. On Linux it use <code>mmap()</code> with a size that is much larger than the actual file size, then when it need more pages, it will <code>write()</code> to the end of
the file, extending it. That will allow the new file to be accessed via the original map. That has the disadvantage of asking the file system for disk space
one page at a time, which is not efficient. Allocating the whole file at once, on the other hand, cause users to complain.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_increasing_the_size_of_the_data_file">Increasing the size of the data file</h3>
<div class="paragraph">
<p>Gavran is going to have the following behavior regarding extending the file:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We will allow to increase the file on the fly.</p>
</li>
<li>
<p>We will pre-allocate disk space in advance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These two requirements are contradictory to one another, but we can make them work. Instead of allocating the file one page at a time, we are going to use
the following formula to increase file size:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Increase by 10% of the existing file size, rounded to the next power of two.</p>
</li>
<li>
<p>A minimum of 1 MB and a maximum of 1GB.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logic behind this is that we want to maintain reasonable file size as we grow, while balancing how much we need to grow the file. Growing the file is
an expensive operation. We need to increase the file size itself, which means that the file system needs to allocate it size on disk. We are intentionally
asking for larger increases, so the file system can allocate us continuous ranges as much as possible.
Then there is the work that Gavran needs to do, remapping of the memory and setting up the new free space accounting.</p>
</div>
<div class="paragraph">
<p>On the one hand, we want to reduce the number of times that we grow the file, but we also have to take into account the fact that users expect the file
to be as small as possible. <a href="#db_find_next_db_size"><code>db.c</code> - Computing the next size fo the file when it is needed</a> shows the logic behind increasing the file size.</p>
</div>
<div id="db_find_next_db_size" class="listingblock">
<div class="title"><code>db.c</code> - Computing the next size fo the file when it is needed</div>
<div class="content">
<pre class="highlight"><code>implementation_detail uint64_t
db_find_next_db_size(uint64_t current, uint64_t requested_size) {
  uint64_t uint_of_growth = next_power_of_two(current / 10);
  uint64_t suggested = uint_of_growth;
  if (suggested &gt; 1024 * 1024 * 1024) suggested = 1024 * 1024 * 1024;
  while (suggested &lt;= requested_size) {
    suggested += uint_of_growth;
  }
  if (suggested &lt; (1024 * 1024)) suggested = 1024 * 1024;

  uint64_t next_p2_file = next_power_of_two(current + suggested);
  if (next_p2_file &lt; current + uint_of_growth * 2)
    return next_p2_file;
  return current + suggested;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll increase the file by 10% each time, rounded to power of two, except when we are near a power of two of the file. Then we&#8217;ll prefer that. This is mostly
for my peace of mind, because I like seeing round numbers in the file size. It doesn&#8217;t have any meaningful difference from a technical perspective.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll currently fail with <code>ENOSPC</code> in the <code>txn_allocate_page()</code>, which we can&#8217;t find enough free pages. Let&#8217;s see what we need to do in order to increase the
file size. I modified the end of <code>txn_allocate_page()</code> to attempt to increase the size of the file, as shown in <a href="#txn_allocate_page_10"><code>txn.alloc.c</code> - Increasing the size of the file if we have no more room available</a>.</p>
</div>
<div id="txn_allocate_page_10" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Increasing the size of the file if we have no more room available</div>
<div class="content">
<pre class="highlight"><code>result_t txn_allocate_page(
    txn_t *tx, page_t *page, uint64_t nearby_hint) {

  // redacted

  if (flopped(db_try_increase_file_size(tx, page-&gt;number_of_pages))) {
    failed(ENOSPC, msg("No more room left in the file to allocate"),
        with(tx-&gt;state-&gt;db-&gt;handle-&gt;filename, "%s"));
  }
  return txn_allocate_page(tx, page, nearby_hint);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, we&#8217;ll try to increase the size by calling <code>db_try_increase_file_size()</code>, if we are successful, we&#8217;ll recurse into <code>txn_allocate_page()</code> again
to perform the actual allocation. If the file extension flopped, we&#8217;ll return <code>ENOSPC</code> as we previously did.</p>
</div>
<div class="paragraph">
<p>The fact that we need to handle file size growth lead to a bunch of complication for the code. We currently have a single <code>span_t</code> instance that
is kept on the <code>global_state</code> field in both <code>db_state_t</code> and <code>txn_state_t</code>. This was done in preparation of this moment.
We haven&#8217;t explicitly stated it, but there is a great importance in managing the state of the system in particular place and order. While the <code>span_t</code>
was the same for the duration of the database lifetime, that caused no issues. But now we need to modify it, and that brings a whole set of trouble.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The responsibilities of components in Gavran</div>
<div class="paragraph">
<p>The <code>db_state_t</code> holds the global state of the system, generally things that either never change (like the file we use) for the duration of the database
instance or modified and used only by the current write transaction.</p>
</div>
<div class="paragraph">
<p>The <code>txn_state_t</code> holds the state for a particular transaction. If it is a read transaction, it is a frozen state, which cannot be altered. We intend to
allow the use of a single state from multiple concurrent threads, so that is a hard requirement.
For the write transaction, we allow to modify the state, but we take into account that the transaction may be rolled back. So any change that we do in the
write transaction cannot be made public to the rest of the system until the transaction commits.</p>
</div>
<div class="paragraph">
<p>That means that we have a cycle. There is some state that is modified by the write transaction, and on commit becomes the state of the whole system. It then
become the (frozen) state of the read transaction that is created from the committed write transaction.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Before we get into exactly why the <code>span_t</code> being modified is problematic, let&#8217;s take one step back. <em>Why</em> do we need to modify it in the first place?
Take a look at <a href="#extending-file">A file whose size was expanded, with the old and new memory mapping</a>, where we see a file that was expanded.</p>
</div>
<div id="extending-file" class="imageblock">
<div class="content">
<img src="../imgs/extending-file.png" alt="extending file">
</div>
<div class="title">Figure 1. A file whose size was expanded, with the old and new memory mapping</div>
</div>
<div class="paragraph">
<p>In <a href="#extending-file">A file whose size was expanded, with the old and new memory mapping</a>, we have two memory mapping for the same file. The first one (on the top) maps the first 1MB of the file. Then we expanded the file and need
to have access to the newly allocated space, how do we get it? We map the whole file <em>again</em>. That is the second map (on the bottom). The first 1 MB of
the file is <em>shared</em> between those two mappings. There are two virtual address ranges that will point to the same place. That will be the same physical memory page
if the page is resident in memory. If the page isn&#8217;t in memory, then a page fault on <em>either</em> map will setup <em>both</em> addresses to point to the same page when it is
accessed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Can&#8217;t we map the new data at the end of the old range?</div>
<div class="paragraph">
<p>Linux and Windows both have APIs that allow you to ask to map a file at a particular address. We can use that to map the new portions of the file at the
end of the old mapping, effectively extending it. In fact, Linux has a dedicated system call for this <code>mremap()</code>. The problem is that this may fail, and we
need to write the code to handle the scenario when there isn&#8217;t enough virtual memory available at the current location to expand the file.</p>
</div>
<div class="paragraph">
<p>Since we need to write this code anyway, it reduces the complexity for us to just have one way of expanding the memory, by remapping it to another location
in the new size. We waste a bit of virtual address space, but we can usually treat that as "large enough that we don&#8217;t care" anyway.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Virtual memory is a wonderful thing, we map the same range in the file twice, and changes that happened there will be reflected in both. A good post
on the matter in <a href="https://devblogs.microsoft.com/oldnewthing/20031007-00/?p=42263">Raymond Chen talking about Stupid memory-mapping tricks</a>. The ability
to retain the old mapping is important, we have read transactions that are actively working against that old mapping. If we were to drop the memory
mapping, they would suddenly try to access invalid memory. That leads to the crux of our problem. With the <code>span_t</code> no longer being static, we need
to think about how to manage the new state of the system.</p>
</div>
<div class="paragraph">
<p>The idea behind <code>db_global_state_t</code> is that a read transaction has a frozen view of the world, including all the state that we have on the system.
That includes the memory map that was effective at the time of the transaction. Let&#8217;s take a look at <a href="#txn_state_t_10"><code>gavran/db.h</code> - The <code>txn_state_t</code> struct, the heart of all transactions</a> to refresh out memory about how
the <code>txn_state_t</code> struct looks like.</p>
</div>
<div id="txn_state_t_10" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The <code>txn_state_t</code> struct, the heart of all transactions</div>
<div class="content">
<pre class="highlight"><code>typedef struct txn_state {
  uint64_t tx_id;
  db_state_t *db;
  span_t map;
  uint64_t number_of_pages;
  pages_map_t *modified_pages;
  cleanup_callback_t *on_forget;
  cleanup_callback_t *on_rollback;
  txn_state_t *prev_tx;
  txn_state_t *next_tx;
  void *shipped_wal_record;
  uint64_t can_free_after_tx_id;
  struct {
    reusable_buffer_t buffer;
    btree_stack_t stack;
  } tmp;
  uint32_t usages;
  db_flags_t flags;
} txn_state_t;
typedef struct cleanup_callback {
  void (*func)(void *state);
  struct cleanup_callback *next;
  char state[];
} cleanup_callback_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Take note in <a href="#txn_state_t_10"><code>gavran/db.h</code> - The <code>txn_state_t</code> struct, the heart of all transactions</a> to the <code>on_forget</code> and <code>on_rollback</code> fields. What are those? The <code>cleanup_act_t</code> is shown
on <a href="#txn_state_t_10"><code>gavran/db.h</code> - The <code>txn_state_t</code> struct, the heart of all transactions</a>  as well. This is used to hold the required state for cleanups, which is something that we now need to take into account.</p>
</div>
<div class="paragraph">
<p>Consider the case of trying to create a new mapping for the file size increase as part of a transaction. And then that transaction fails for some other
reason. Because the transaction did not commit, we must discard all its state, including the new file mapping. That is the purpose of the <code>on_rollback</code>
callback field, to allow to invoke cleanup code if the transaction has been rolled back.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What about rolling back changes to the file size?</div>
<div class="paragraph">
<p>One thing that we are <em>not</em> going to do is to roll back a change to the file size. If a transaction has extended the size of the file, we&#8217;ll not truncate
it again. The reason for this is that there is no real need to do so. We aren&#8217;t actually relying on the size of the data file for anything, we have the
<code>number_of_pages</code> value in the file header for that. And it is likely that we&#8217;ll need to extend the file shortly anyway, so no need to do extra work
in this regard.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Conversely, when we have successfully committed a transaction after increasing the file size, we need to <code>unmap()</code> the <em>old</em> mapping. We can&#8217;t do that
immediately, because there are older read transactions that may be using it. We are going to reuse the same cleanup concept we have for writing for the
disk. If there are no transactions that are old enough to want to look at old pages, we can write them to disk. In the same vein, we can wait until all
the active transactions are newer than the current write transaction and then close the old mapping. All the current transactions are now looking only
at the new one. That is the purpose of the <code>on_forget</code> callback back.</p>
</div>
<div class="paragraph">
<p>With all of this background in place, let&#8217;s look at the code to actually increase the file size, shown in <a href="#db_try_increase_file_size"><code>db.c</code> - Increasing the data file size</a>.</p>
</div>
<div id="db_try_increase_file_size" class="listingblock">
<div class="title"><code>db.c</code> - Increasing the data file size</div>
<div class="content">
<pre class="highlight"><code>static void db_clear_old_mmap(void *state) {
  // no way to report state, will use errors_push for that
  (void)pal_unmap((span_t *)state);
}
static result_t db_new_size_can_fit_free_space_bitmap(
    uint64_t current_size, uint64_t *new_size) {
  uint32_t required_pages =
      TO_PAGES(ROUND_UP(*new_size / PAGE_SIZE, BITS_IN_PAGE)) * 2;
  if (*new_size - current_size &gt; required_pages * PAGE_SIZE)
    return success();
  *new_size += required_pages * PAGE_SIZE;
  return success();
}
implementation_detail result_t
db_increase_file_size(txn_t *tx, uint64_t new_size) {
  ensure(db_new_size_can_fit_free_space_bitmap(tx-&gt;state-&gt;map.size,
                                               &amp;new_size));
  ensure(new_size &lt; tx-&gt;state-&gt;db-&gt;options.maximum_size,
         msg("Unable to grow the database beyond the maximum size"),
         with(new_size, "%lu"),
         with(tx-&gt;state-&gt;db-&gt;options.maximum_size, "%lu"));
  file_handle_t *handle = tx-&gt;state-&gt;db-&gt;handle;
  ensure(pal_set_file_size(handle, new_size, UINT64_MAX));
  span_t new_map = {.size = new_size};
  ensure(pal_mmap(handle, 0, &amp;new_map),
         msg("Unable to map the file again"),
         with(new_map.size, "%lu"));
  {
    size_t cancel_defer = 0;
    try_defer(pal_unmap, new_map, cancel_defer);
    // discard new map if we failed to commit
    ensure(txn_register_cleanup_action(&amp;tx-&gt;state-&gt;on_rollback,
                                       db_clear_old_mmap, &amp;new_map,
                                       sizeof(span_t)));
    cancel_defer = 1;
  }
  // discard old map when no one is looking at this tx
  ensure(txn_register_cleanup_action(
      &amp;tx-&gt;state-&gt;on_forget, db_clear_old_mmap, &amp;tx-&gt;state-&gt;map,
      sizeof(span_t)));
  tx-&gt;state-&gt;map = new_map;
  tx-&gt;state-&gt;number_of_pages = new_size / PAGE_SIZE;
  return success();
}

implementation_detail result_t
db_try_increase_file_size(txn_t *tx, uint64_t pages) {
  page_metadata_t *metadata;
  ensure(txn_get_metadata(tx, 0, &amp;metadata));
  uint64_t from = metadata-&gt;file_header.number_of_pages;
  uint64_t new_size =
      db_find_next_db_size(from * PAGE_SIZE, pages * PAGE_SIZE);
  ensure(db_increase_file_size(tx, new_size));
  return db_finalize_file_size_increase(tx, from,
                                        new_size / PAGE_SIZE);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We compute the new size of the file and map it again. Note that there is a small dance here with the error handling to make sure that in all cases,
we&#8217;ll cleanup the resources if there was an error.
After we map the file we use <code>try_defer</code> to ensure that a failure to register the rollback will not cause us to leak the new memory map. We register
a deletion of the <em>existing</em> memory map when the transaction is forgotten. When no one is using this transaction or any older transaction, as we saw
in the previous chapter.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">The free space bitmap also need some space</div>
<div class="paragraph">
<p>In <a href="#db_try_increase_file_size"><code>db.c</code> - Increasing the data file size</a>, you can see a call to <code>db_new_size_can_fit_free_space_bitmap()</code>, this is meant to handle a very specific edge case.
When we increase the size of the file, we also need to update the free space bitmap. Usually we can do that by marking the bits in the bitmap, but if
the size of the file grew beyond the capacity of the bitmap, we need to move it. And we have to assume that there is <em>no</em> available free space in the
existing file for the bitmap.</p>
</div>
<div class="paragraph">
<p>We limit our file growth to 1 GB in size, but that can cause us issues. If the size of the <em>free space bitmap</em> is more than 1 GB and we need to move
it, we may run into a case where we increase the file and then fail because there is not enough free space for the new free space bitmap. Given a
maximum size of 1 GB, it means that the file would need to have over 64 TB in size before we&#8217;ll actually have to deal with it. But I&#8217;m not planning
on having limits that I don&#8217;t absolutely have to have. Therefor, <code>db_new_size_can_fit_free_space_bitmap()</code> is here to ensure that any growth in the
file will have enough space to accommodate the free space bitmap. That is also why the call to <code>db_try_increase_file_size()</code> is immediately followed
by a recursion into <code>txn_allocate_page()</code>. It is possible (although unlikely) that we&#8217;ll need to increase the file <em>twice</em> before we can satisfy the
allocation request. First to move the free space bitmap and then to allocate the actual pages requested.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#txn_register_cleanup_action"><code>txn.c</code> - Registering callbacks on the transaction</a> shows how we handle the registration on the transaction.</p>
</div>
<div id="txn_register_cleanup_action" class="listingblock">
<div class="title"><code>txn.c</code> - Registering callbacks on the transaction</div>
<div class="content">
<pre class="highlight"><code>result_t txn_register_cleanup_action(cleanup_callback_t **head,
    void (*action)(void *), void *state_to_copy,
    size_t size_of_state) {
  cleanup_callback_t *cur;
  ensure(mem_calloc(
      (void *)&amp;cur, sizeof(cleanup_callback_t) + size_of_state));
  memcpy(cur-&gt;state, state_to_copy, size_of_state);
  cur-&gt;func = action;
  cur-&gt;next = *head;
  *head     = cur;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a couple of things that are very important to note here. First, we maintain a <em>copy</em> of the state that was passed to us, instead of maintainin a
reference to it. That means that we can discard the value after we call the register function. Second, we use a single allocation to hold the new
<code>cleanup_act_t</code> and its state. These two behaviors simplify memory handling significantly, both inside the registration / invocation code
paths and for the callers. You can see how they are being used in <a href="#txn_commit_10"><code>txn.c</code> - Freeing rollback callback state on commit</a>.</p>
</div>
<div id="txn_commit_10" class="listingblock">
<div class="title"><code>txn.c</code> - Freeing rollback callback state on commit</div>
<div class="content">
<pre class="highlight"><code>result_t txn_commit(txn_t *tx) {
  errors_assert_empty();
  if (!tx-&gt;state-&gt;modified_pages-&gt;count) return success();
  page_metadata_t *header;
  ensure(txn_modify_metadata(tx, 0, &amp;header));
  header-&gt;file_header.last_tx_id = tx-&gt;state-&gt;tx_id;

  ensure(wal_append(tx-&gt;state));

  tx-&gt;state-&gt;flags  = TX_COMMITED;
  tx-&gt;state-&gt;usages = 1;

  // <b class="conum">(1)</b>
  // Update global references to the current span on commit
  tx-&gt;state-&gt;db-&gt;last_write_tx-&gt;next_tx = tx-&gt;state;
  tx-&gt;state-&gt;db-&gt;last_write_tx          = tx-&gt;state;
  tx-&gt;state-&gt;db-&gt;last_tx_id             = tx-&gt;state-&gt;tx_id;
  tx-&gt;state-&gt;db-&gt;map                    = tx-&gt;state-&gt;map;
  tx-&gt;state-&gt;db-&gt;number_of_pages        = tx-&gt;state-&gt;number_of_pages;

  // <b class="conum">(2)</b>
  while (tx-&gt;state-&gt;on_rollback) {
    cleanup_callback_t *cur = tx-&gt;state-&gt;on_rollback;
    tx-&gt;state-&gt;on_rollback  = cur-&gt;next;
    free(cur);
  }
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New code, when we update the mapping we work on after increasing the file size, we do that only on the local transaction. On commit, we publish this to
the rest of the system. In this case, the <code>global_state</code> on the <code>default_read_tx</code> and the <code>db_state_t</code>. Note that this is safe to do even for running
transactions. The mapping overlap and you can access the same memory using both the old and new mapping to get the same values.</p>
</li>
<li>
<p>New code, when we successfully committed the transaction, we can free the rollback state immediately.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#txn_commit_10"><code>txn.c</code> - Freeing rollback callback state on commit</a> shows what happens when we successfully committed. We can immediately free all the memory around rollback callbacks. Since rollback is now
no longer possible. There is still the issue with the <code>on_forget</code> callback. That is called from the <code>txn_free_single_tx_state()</code> function, showing in
<a href="#txn_free_single_tx_state_10"><code>txn.c</code> - Executing <code>on_forget</code> callback when the transaction is being discarded</a>.</p>
</div>
<div id="txn_free_single_tx_state_10" class="listingblock">
<div class="title"><code>txn.c</code> - Executing <code>on_forget</code> callback when the transaction is being discarded</div>
<div class="content">
<pre class="highlight"><code>implementation_detail void txn_free_single_tx_state(
    txn_state_t *state) {
  size_t iter_state = 0;
  page_t *p;
  while (pagesmap_get_next(state-&gt;modified_pages, &amp;iter_state, &amp;p)) {
    free(p-&gt;address);
  }
  // <b class="conum">(1)</b>
  while (state-&gt;on_forget) {
    cleanup_callback_t *cur = state-&gt;on_forget;
    cur-&gt;func(cur-&gt;state);
    state-&gt;on_forget = cur-&gt;next;
    free(cur);
  }
  free(state-&gt;modified_pages);
  free(state);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The new code, just before we free the transaction, call all the registered callbacks to ensure that the entire state is cleaned up.</p>
</li>
</ol>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The identity function of a page is its <code>page_num</code>, nothing else!</div>
<div class="paragraph">
<p>Gavran makes the following promises with regards to pages and their memory.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Once you accessed a page, you can continue to access the page using the same memory address for the duration of the transaction.</p>
</li>
<li>
<p>It is <em>invalid</em> to store that pointer after the transaction has closed.</p>
</li>
<li>
<p>Two calls to <code>txn_get_page()</code> may return <em>different</em> pointers in the same transaction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last one is interesting, let&#8217;s see how that can happen. We start a transaction and then call <code>txn_get_page(2) &#8594; 0xF68000</code> for the duration
of the transaction, we&#8217;ll always be able to use <code>0xF68000</code> to get to the page. However, we allocate a new page and the data file grow, resulting
in new mapping. We call <code>txn_get_page(2) &#8594; 0xB8439000</code> and we get a <em>different</em> pointer. This is because each one of the calls was served from
a different mapping.</p>
</div>
<div class="paragraph">
<p>In this case, both <code>0xF68000</code> and <code>0xB8439000</code> are going to be <em>identical</em> in content. They are pointing to the same physical memory location.</p>
</div>
<div class="paragraph">
<p>This isn&#8217;t a problem in practice, because we observe the exact same thing when we use <code>txn_modify_page()</code>, because of Copy on Write, we get a
different memory from the one that we got from the <code>txn_get_page()</code> call. Note that inside a single transaction, all calls to <code>txn_modify_page()</code>
will return the <em>same</em> pointer. Indeed, <code>txn_modify_page()</code> will simply return the previous value when called on a page for the second time.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, there is the <code>txn_close()</code> function, which we had to modify to take into account the new callbacks. As a reminder, when we close a transaction that
hasn&#8217;t been committed, this is considered a rollback, there is no explicit rollback mechanism in Gavran. You can see the changes we made to <code>txn_close()</code> in
<a href="#txn_close_10"><code>txn.c</code> - Handling rollback of transactions in <code>txn_close()</code></a>.</p>
</div>
<div id="txn_close_10" class="listingblock">
<div class="title"><code>txn.c</code> - Handling rollback of transactions in <code>txn_close()</code></div>
<div class="content">
<pre class="highlight"><code>result_t txn_close(txn_t *tx) {
  if (!tx || !tx-&gt;state) return success();
  db_state_t *db = tx-&gt;state-&gt;db;
  if (tx-&gt;state-&gt;tx_id == db-&gt;active_write_tx) {
    db-&gt;active_write_tx = 0;
  }
  if (!(tx-&gt;state-&gt;flags &amp; TX_COMMITED)) {  // rollback
    // <b class="conum">(1)</b>
    while (tx-&gt;state-&gt;on_rollback) {
      cleanup_callback_t *cur = tx-&gt;state-&gt;on_rollback;
      cur-&gt;func(cur-&gt;state);
      tx-&gt;state-&gt;on_rollback = cur-&gt;next;
      free(cur);
    }
    // <b class="conum">(2)</b>
    while (tx-&gt;state-&gt;on_forget) {
      // we didn't commit, can just discard this
      cleanup_callback_t *cur = tx-&gt;state-&gt;on_forget;
      tx-&gt;state-&gt;on_forget    = cur-&gt;next;
      free(cur);
    }
    txn_free_single_tx_state(tx-&gt;state);
    tx-&gt;state = 0;
    return success();
  }
  if (!db-&gt;transactions_to_free &amp;&amp; tx-&gt;state != db-&gt;default_read_tx)
    db-&gt;transactions_to_free = tx-&gt;state;

  if (--tx-&gt;state-&gt;usages == 0) {
    ensure(txn_gc(tx-&gt;state));
  }

  tx-&gt;state = 0;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#txn_close_10"><code>txn.c</code> - Handling rollback of transactions in <code>txn_close()</code></a> there is a careful dance in the case of rollback. We need to invoke <em>just</em> the <code>on_rollback</code> callback, to discard the new memory map and
<em>not</em> invoke the <code>on_forget</code> callback (which should be invoked only for committed transactions). Because <code>txn_free_single_tx()</code> will call the <code>on_forget</code> callback,
we free all the <code>on_forget</code> callbacks before we call to <code>txn_free_single_tx()</code>.
The reason we don&#8217;t want to call <code>on_forget</code> in the case of a rolled back transaction is that it will remove the <em>existing</em> memory map, which will leave
us hanging badly.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Transactions apply their state on commit, or rollback atomically</div>
<div class="paragraph">
<p>One of the design principles of Gavran is that the transaction is the unit of all changes in the system. We use that to modify the data file safely. We
also use that to modify the internal structure of Gavran itself. Using this model of pushing all changes through the transaction and accepting them via
the commit simplify a great deal of state management inside of Gavran.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The fact that all the modifications to the system state are done on an isolated copy of the <code>global_state</code> is a huge relief. We don&#8217;t need to
carefully orchestrate modifying things, we can do everything locally, on a copy, and only publish this as part of the commit. If you are finding
similarities in the approach to the Copy on Write system we use for page modifications, that is by no means an accident. Being able to reuse
concepts and having a single line of thinking simplify the code base significantly.</p>
</div>
<div class="paragraph">
<p>Just increasing the file size and mapping the memory again isn&#8217;t enough, I&#8217;m afraid to say. We also need to make sure that the free space bitmap
knows about the new size, that the file header is updated, etc. This is handled in <code>db_finalize_file_size_increase()</code>, called as the last step
in  <code>db_try_increase_file_size()</code>. You can see its behavior in <a href="#db_finalize_file_size_increase"><code>db.c</code> - After increasing the actual file size, we need to update our internal structures about the file size and free space usage.</a>.</p>
</div>
<div id="db_finalize_file_size_increase" class="listingblock">
<div class="title"><code>db.c</code> - After increasing the actual file size, we need to update our internal structures about the file size and free space usage.</div>
<div class="content">
<pre class="highlight"><code>static result_t db_increase_free_space_bitmap(txn_t *tx,
                                              uint64_t from,
                                              uint64_t to) {
  page_metadata_t *file_header_metadata;
  ensure(txn_modify_metadata(tx, 0, &amp;file_header_metadata));
  uint64_t free_space_page =
      file_header_metadata-&gt;file_header.free_space_bitmap_start;
  page_metadata_t *metadata;
  ensure(txn_modify_metadata(tx, free_space_page, &amp;metadata));
  page_t free_space = {.page_num = free_space_page};
  ensure(txn_modify_page(tx, &amp;free_space));
  if (metadata-&gt;free_space.number_of_pages * BITS_IN_PAGE &gt; to) {
    // can do an in place update
    for (uint64_t i = from; i &lt; to; i++) {
      bitmap_set(free_space.address, i, false);
    }
    return success();
  }
  // need to move to a new location
  return db_move_free_space_bitmap(tx, from, to, metadata,
                                   &amp;free_space);
}
static result_t db_finalize_file_size_increase(txn_t *tx,
                                               uint64_t from,
                                               uint64_t to) {
  ensure(db_increase_free_space_bitmap(tx, from, to));
  page_metadata_t *file_header_metadata;
  ensure(txn_modify_metadata(tx, 0, &amp;file_header_metadata));
  tx-&gt;state-&gt;number_of_pages = to;
  file_header_metadata-&gt;file_header.number_of_pages = to;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the common case, we can simply mark the newly available pages in the <code>db_increase_free_space_bitmap()</code> function. Each free space bitmap page can
mark 512 MB of data, so growing the free space bitmap should be a rare event, most of the time, we just need to mark the new pages as free and that
would be it. We&#8217;ll see how we deal with growing the free space bitmap in <code>db_move_free_space_bitmap()</code> in a bit.</p>
</div>
<div class="paragraph">
<p>The rest of <code>db_finalize_file_size_increase()</code> is just setting the new <code>number_of_pages</code> on the page header on the first metadata entry of the file,
and that is that. The changes are made to modified pages, which go through the usual Copy on Write, being written to the WAL, copied to the data
file when there are no read transactions that may observe this, etc. In other words, this part is also part of the transaction, like the <code>global_state</code>
behavior, but it is done using the usual mechanism that we have setup, no need for any special behaviors here.</p>
</div>
<div class="paragraph">
<p>The behavior is much more involved when we need to actually move the free space bitmap. This is shown in <a href="#db_move_free_space_bitmap"><code>db.c</code> - Moving the free space bitmap to a new location when it is unable to fit in its current location.</a>. What it <em>does</em> in essence is
to create a new bitmap in memory, with the new size, based on the old bitmap. It uses the new bitmap to find the new location of the bitmap and then
move the bitmap there. See the notes in the code for the full details.</p>
</div>
<div id="db_move_free_space_bitmap" class="listingblock">
<div class="title"><code>db.c</code> - Moving the free space bitmap to a new location when it is unable to fit in its current location.</div>
<div class="content">
<pre class="highlight"><code>static result_t db_move_free_space_bitmap(
    txn_t *tx, uint64_t from, uint64_t to,
    page_metadata_t *old_metadata, page_t *old) {
  // <b class="conum">(1)</b>
  uint32_t pages = (uint32_t)ROUND_UP(to, BITS_IN_PAGE);
  pages += next_power_of_two(pages / 10);
  // <b class="conum">(2)</b>
  void *new_map;
  ensure(mem_alloc_page_aligned(&amp;new_map, pages * PAGE_SIZE));
  defer(free, new_map);
  // <b class="conum">(3)</b>
  size_t old_bitmap_size =
      old_metadata-&gt;free_space.number_of_pages * PAGE_SIZE;
  memcpy(new_map, old-&gt;address, old_bitmap_size);
  memset(new_map + old_bitmap_size, INT32_MAX,
         pages * PAGE_SIZE - old_bitmap_size);
  // <b class="conum">(4)</b>
  for (uint64_t i = from; i &lt; to; i++) {
    bitmap_set(new_map, i, false);  // new pages are free
  }
  bitmap_search_state_t search = {
      .input = {.bitmap = new_map,
                .bitmap_size = pages * PAGE_SIZE / sizeof(uint64_t),
                .near_position = 0,  // anywhere is good
                .space_required = pages}};
  // <b class="conum">(5)</b>
  if (!bitmap_search(&amp;search)) {
    failed(ENOSPC,
           msg("No place for free space bitmap after resize!"),
           with(pages, "%u"));
  }
  // <b class="conum">(6)</b>
  for (uint64_t i = 0; i &lt;= pages; i++) {  // new bitmap page are busy
    bitmap_set(new_map, search.output.found_position + i, true);
  }
  page_t new_page = {.page_num = search.output.found_position,
                     .number_of_pages = pages};
  // <b class="conum">(7)</b>
  ensure(txn_raw_modify_page(tx, &amp;new_page));
  memcpy(new_page.address, new_map, pages * PAGE_SIZE);
  // <b class="conum">(8)</b>
  page_metadata_t *free_space_metadata;
  ensure(txn_modify_metadata(tx, search.output.found_position,
                             &amp;free_space_metadata));
  free_space_metadata-&gt;free_space.page_flags =
      page_flags_free_space_bitmap;
  // <b class="conum">(9)</b>
  free_space_metadata-&gt;free_space.number_of_pages = pages;
  // <b class="conum">(10)</b>
  ensure(txn_free_page(tx, old));  // release the old space
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the new size of the bitmap in pages, based on the new file size. We actually use <em>more</em> space than is needed, to reduce the number of times
that we need to move the free space bitmap.</p>
</li>
<li>
<p>Allocate <em>in memory</em> buffer for the bitmap.</p>
</li>
<li>
<p>Copy the old bitmap and then mark the rest of the bitmap as busy.</p>
</li>
<li>
<p>Set the newly available space as free in the new bitmap.</p>
</li>
<li>
<p>Search <em>the new bitmap</em> for available space for the new bitmap. This may be in the new file range or in the old one. We ensure that the new space
will have at least enough space for the free space bitmap in <code>db_new_size_can_fit_free_space_bitmap()</code>.</p>
</li>
<li>
<p>Mark the new free space bitmap pages as busy.</p>
</li>
<li>
<p>Modify the bitmap pages and copy the new bitmap to them.</p>
</li>
<li>
<p>Update the metadata of the new free space bitmap.</p>
</li>
<li>
<p>Update the transaction&#8217;s state to point to the new free space bitmap.</p>
</li>
<li>
<p>Free the pages of the old free space bitmap, we are not freeing them in the <em>new</em> bitmap, because we already set <code>free_space_bitmap_start</code> in the
transaction&#8217;s <code>global_state.header</code> so that will already use the new bitmap.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#db_move_free_space_bitmap"><code>db.c</code> - Moving the free space bitmap to a new location when it is unable to fit in its current location.</a> is the most complex piece in the data file growth, it ensures that the free space bitmap moves without issue and it has to do quite a lot
to get things working. Probably the most tricky part is that we copy the bitmap to memory, including the newly available pages and then use that in
memory bitmap to find the location of the bitmap. This is a bit recursive, but it ends up working quite nicely in the end.</p>
</div>
<div class="paragraph">
<p>I&#8217;m actually copying the new bitmap twice, once to an in memory buffer where I&#8217;ll run my checks and once from the in memory buffer to the page buffer
held by the transaction.  At small sizes, it won&#8217;t matter. But as the size of the data file grows, so would the free space. At 512 GB, if you&#8217;ll recall,
the free space bitmap would take 64 MB. It is possible to avoid this cost by making the code more complex, but that is probably not worth it.
At 512GB, the free space bitmap would not be 64 MB, we&#8217;ll actually reserve <em>70</em> MB for that. Meaning that the next time we&#8217;ll need to move it will be when
we grow the file by another 48 GB. That far apart, it isn&#8217;t really worth it to try to optimize the double memory copy.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What did all of this get us?</div>
<div class="paragraph">
<p>We can now extend the size of the file on the fly, while transactions are still running. The internal metadata will be updated and if needed changed to
reflect the new change. We also take care to reduce those costs by allocating a bit more than is required when we increase the size of the free space
bitmap.</p>
</div>
<div class="paragraph">
<p>There is some complexity involved, the rest of the architecture and behavior remained the same and we even have better understanding of how these sort of
constraints are going to impact our system in the future.</p>
</div>
<div class="paragraph">
<p>The fact that the read transactions are immutable and that we need to keep their state around until they are no longer being used is going to be <em>huge</em> when
we start to implement multi threading support. And the fact that we are spending so much time at the lowest levels of the system means that we don&#8217;t need to
worry about these details at higher levels. We&#8217;ll see how all of those play out in the next part of the book.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There is still one failure mode that we haven&#8217;t handled yet. Handling recovery of a file where the WAL contains pages that are beyond the end of the file. That
can happen if we committed a transaction but failed to preserve the new size of the file. Technically, that isn&#8217;t something that we should be concerned about.
When we increase the size of the file, we do so using <code>pal_set_file_size()</code>, which will do the appropriate <code>fsync()</code> dance with the parent directory to ensure
that the size of the file is properly recorded. This happens <em>immediately</em>, not when the transaction commits, so if the transaction got to the WAL, we can be
sure that the file size was already increased.</p>
</div>
<div class="paragraph">
<p>There are several reasons why I want to handle this scenario:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We may want to defer the file size increase to the transaction commit (or maybe even when we write the modified pages to the data file).</p>
</li>
<li>
<p>Scenarios such as log shipping or incremental backups may cause us to get a WAL transaction that has pages beyond the end of the current file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To handle this scenario, I&#8217;ve added a call to <code>wal_ensure_data_file_size()</code> to the <code>wal_recover_tx()</code> function. You can see what this looks like in <a href="#wal_ensure_data_file_size"><code>wal.c</code> - Increasing the size of the data file when applying recover</a>.</p>
</div>
<div id="wal_ensure_data_file_size" class="listingblock">
<div class="title"><code>wal.c</code> - Increasing the size of the data file when applying recover</div>
<div class="content">
<pre class="highlight"><code>// in wal_recover_tx()
ensure(wal_ensure_data_file_size(db,
    tx-&gt;pages[i].page_num + tx-&gt;pages[i].number_of_pages));

static result_t wal_ensure_data_file_size(
    db_t *db, uint64_t min_pages) {
  if (db-&gt;state-&gt;handle-&gt;size &gt; min_pages * PAGE_SIZE) {
    return success();
  }
  ensure(pal_set_file_size(
      db-&gt;state-&gt;handle, min_pages * PAGE_SIZE, UINT64_MAX));
  span_t *map = &amp;db-&gt;state-&gt;map;
  ensure(pal_unmap(map));
  map-&gt;size = db-&gt;state-&gt;handle-&gt;size;
  ensure(pal_mmap(db-&gt;state-&gt;handle, 0, map));
  db-&gt;state-&gt;default_read_tx-&gt;map = *map;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just calling <code>wal_ensure_data_file_size()</code> from <code>wal_recover_tx()</code> isn&#8217;t enough, however. The WAL contains only the <em>modified</em> pages, we need to take into account the
fact that when we increase the size of the data file we tend to do that in large chunks. We record the <code>number_of_pages</code> in the file in the file header, and I&#8217;ve added
another call to <code>wal_ensure_data_file_size()</code> at the end of the complete recovery process, where we ensure that the file is large enough to fit all the pages we think
we have.</p>
</div>
</div>
<div class="sect2">
<h3 id="_increasing_the_size_of_the_wal">Increasing the size of the WAL</h3>
<div class="paragraph">
<p>We spent a lot of time working on extending the size of the data file, but what about the size of the WAL? We currently define the size of the WAL on
startup based on the <code>db_options_t.wal_size</code> value. What happens if we aren&#8217;t able to clear the WAL quickly enough and we reach the end?
You might expect that we&#8217;ll get an error, something like the <code>ENOSPC</code> that we got when reaching the limits of the data file before we fixed that, but
that isn&#8217;t the case.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Avoiding unnecessary limits</div>
<div class="paragraph">
<p>It is very common in databases to have values such as <code>max_buffer_size</code> or the like. I don&#8217;t like these because they are usually set in advance are
are not related to the actual resources available on the machine. If I&#8217;m writing to disk, but I have 2 TB of hard disk free, I don&#8217;t really
care to stop after 512MB because that is the size of the WAL configuration.</p>
</div>
<div class="paragraph">
<p>Such values are bad if the common reaction when you find them is to just bump them upward. I would much rather have configuration that guide us,
not one that blocks us. Remember that principle when it comes to designing your system configuration.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As it is currently written, we&#8217;re using <code>pwrite()</code> to write to the WAL, and we are going to increment the position to which we write on each call.
If we get to the end of the file, the operating system will simply increase the size of the file. The problem with doing this is that we haven&#8217;t
updated the parent directory to make sure that the metadata change on the WAL file will be persisted. So this sort of works, but it isn&#8217;t safe.
There is also the chance of hitting the limits of the disk, which means that you may get a <code>ENOSPC</code> error at any time. I would much rather do
things in a more structured manner.</p>
</div>
<div class="paragraph">
<p>Just like the manner in which we increase the size of the data file, we can detect and increase the size of the WAL. However, that leads to an
interesting question, how should we actually handle the WAL? Right now we have a single file and we reset it occasionally. That isn&#8217;t
necessarily the best way to handle things. We could create a <em>new</em> file when we reach the limits of the WAL. That is how Voron works, for
example, as well as RocksDB and many other databases.</p>
</div>
<div class="paragraph">
<p>Using multiple files means that we can more easily handle the WAL reset that we are currently managing by resetting the position we write to the
file. We&#8217;ll simply use a new file and we can use the file <em>name</em> as an indication of sequence. So we&#8217;ll have <code>db-00001.wal</code>, <code>db-00002.wal</code>, etc.
That works, but it has a few caveats. First, allocating new files all the time requires that you&#8217;ll create them and have the file system allocate
space for them. That isn&#8217;t ideal.</p>
</div>
<div class="paragraph">
<p>We can keep these files around, reusing the allocated disk space. Again, this is what Voron is doing, but it takes an effort. We also need to rename the
files whenever we create a new WAL. That requires I/O operation for the rename as well as updating the parent directory. We also need to keep track
of what WAL file we are currently using, what files we can reuse, etc.</p>
</div>
<div class="paragraph">
<p>The big advantage of having a single file is the simplicity of implementation. But it has a fatal issue. Consider the timeline shown in <a href="#endless-tx-in-wal">A time line of concurrent read and write transactions</a>.</p>
</div>
<div id="endless-tx-in-wal" class="imageblock">
<div class="content">
<img src="../imgs/endless-tx-in-wal.png" alt="endless tx in wal">
</div>
<div class="title">Figure 2. A time line of concurrent read and write transactions</div>
</div>
<div class="paragraph">
<p>In order to reset the WAL, we need to have <em>no</em> active transactions. If at any given point we have active transactions, we&#8217;ll never be able to
reset the WAL and it will grow without bound. When using multiple files, we can easily handle that because at some point the current transaction
will be beyond the oldest WAL file, which means that it can be deleted or repurposed. That is not possible to do when you have a single file.</p>
</div>
<div class="paragraph">
<p>So we need to change our WAL to use multiple files. Let&#8217;s see what changes are required to make this happen&#8230;&#8203; The first thing to realize is
that working with files in C simply sucks. My first attempt to get a listing of the relevant files from the directory (files with format of
<code>&lt;database-name&gt;-&lt;number&gt;.wal</code> went on for over a 125 lines! Instead of trying to use multiple dynamic files, I decided to use a static set
of files. We&#8217;ll have the following files in a Gavran database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>db/phones</code> - The actual database file.</p>
</li>
<li>
<p><code>db/phone-a.wal</code> - The first WAL file.</p>
</li>
<li>
<p><code>db/phone-b.wal</code> - The second WAL file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All three of them together are going to compose our database. Note that the first &amp; second designation are arbitrary. There isn&#8217;t any intrinsic
order in the use of the WAL files.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Avoiding esoteric features</div>
<div class="paragraph">
<p>Linux actually includes support for <code>FALLOC_FL_COLLAPSE_RANGE</code>, which does exactly what we want. We can give it a range at the start of the
file and it will truncate it from the <em>start</em>. That is just perfect for our situation, but it is sadly really bad idea to actually make use
of such a feature. Why is that?</p>
</div>
<div class="paragraph">
<p><code>FALLOC_FL_COLLAPSE_RANGE</code> exists only on Linux, it has no equivalent on Windows or macOS. It is also limited to specific file systems. And
one of the key things that I have learned is that people do all <em>sort</em> of crazy things with their systems. You may be running Gavran on
Linux on top of ext4 (supporting <code>FALLOC_FL_COLLAPSE_RANGE</code>) but you may be running this in a docker instance running on Windows, in which
case the volume you use is actually using CIFS (<strong>not</strong> supporting <code>FALLOC_FL_COLLAPSE_RANGE</code>). Or you have a user that put a Gavran database on
a USB stick (usually formatted with FAT32, with no supporting <code>FALLOC_FL_COLLAPSE_RANGE</code>).</p>
</div>
<div class="paragraph">
<p>It pays to be <em>really</em> conservative with features that we seek to rely on at the file system level. There is a <em>lot</em> of variance between the
various systems and it is easy to get yourself snagged by those details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In <code>wal_recover()</code> we are using <code>wal_recovery_operation_t</code> and a whole bunch of functions to iterate through the WAL. Up until now, it didn&#8217;t
really make sense to have all of this complexity. Now it should be clearer why I went this route. This allows us to abstract how we iterate
over the data in the WAL. We provide functions to get the next valid transaction as well as the next range, which may be an old transaction,
The key is that the transaction in question may come from <em>either</em> WAL files, and the higher level code isn&#8217;t really going to care about that.</p>
</div>
<div class="paragraph">
<p>Having a single file for the WAL is a simple to get started, but it isn&#8217;t the only reason I chose it. There are some have some important properties
that we get by having a single file, we don&#8217;t keep messing with the file system, by allocating
new files and deleting them as we create new WAL files. That can be surprisingly expensive. Another consideration is that it is common for users
to want to move split the data and the WAL to different locations. Why would a user want to do something like that? Well, consider the <em>physical</em>
architecture that they may have.</p>
</div>
<div class="paragraph">
<p>If the user have two disks attached to a machine, they may want to have the data reside on one disk and the WAL on another. The requirements that
we place on the WAL and the data files are <em>very</em> different. The WAL is all about sequential writes and is almost never read (only on recovery)
while the data file is about random reads and writes, buffered by memory. However, the data file writes are <em>not</em> critical for us. We are currently
in single threaded mode, but in the future, they will be done in a background thread. The WAL performance, on the other hand, is critical, because
we cannot complete a transaction until the write to the WAL has successfully completed.</p>
</div>
<div class="paragraph">
<p>Given these requirements, it is common to have a big and somewhat slow disk for the data file, which is mostly backed by memory anyway and a smaller
but faster disk for the WAL. Separating the data disk and WAL disk also gives us better throughput overall, since we don&#8217;t have competition on the
same resource.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">How do you configure multiple disk layout?</div>
<div class="paragraph">
<p>Multiple disk layout for a database is both an advanced option and something that database administrators are well familiar with and will try to
apply. It is also a PITA to define in code, because there are so many places that you need to reference it and the root cause of many bugs because
the code didn&#8217;t account for the "WAL is in another location" issue.</p>
</div>
<div class="paragraph">
<p>Instead, Gavran takes the position that the user can run a <code>ln -s /db/phones-a.wal /mnt/fast/wals/phones.wal</code> and everything will work as expected
because we are carefully <em>not</em> doing anything to prevent that scenario when we are opening the WAL file.</p>
</div>
<div class="paragraph">
<p>This means that we have to have <em>predictable</em> file names for the WAL file(s), or use a directory for them.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I would much rather have a single file, but we can&#8217;t have that and allow for continuously opened read transactions, as we saw in <a href="#endless-tx-in-wal">A time line of concurrent read and write transactions</a>. Creating
many WAL files has its issues, so we&#8217;ll avoid it as well. Instead, we&#8217;ll use double buffering approach. Gavran will have <em>two</em> WAL files. For the
database <code>/db/phones</code> we&#8217;ll have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/db/phones-a.wal</code></p>
</li>
<li>
<p><code>/db/phones-b.wal</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are going to be used as the backing store for the WAL, and we&#8217;ll switch between them as needed. Because we can switch between them, we can
clear the one that isn&#8217;t being used when there are active transactions and then switch to it, and so on. You can see how that would work in <a href="#two-wal-files">Two WAL files used to store the transaction history of a database</a>.</p>
</div>
<div id="two-wal-files" class="imageblock">
<div class="content">
<img src="../imgs/two-wal-files.png" alt="two wal files">
</div>
<div class="title">Figure 3. Two WAL files used to store the transaction history of a database</div>
</div>
<div class="paragraph">
<p><a href="#two-wal-files">Two WAL files used to store the transaction history of a database</a> shows the two files and the transactions that are stored in them. Let&#8217;s consider the recovery process from such a state.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We open both files and test the first transaction on both of them.</p>
</li>
<li>
<p>We start with the file with the <em>oldest</em> transaction id.</p>
</li>
<li>
<p>We run through the file normally, applying the diffs from the transaction.</p>
</li>
<li>
<p>When we are done with the valid transactions, we validate the end of the file, as we did before.</p>
</li>
<li>
<p>When we are done with the first file, we do the same on the second one. Again with validation at the end.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the case of <a href="#two-wal-files">Two WAL files used to store the transaction history of a database</a>, we&#8217;ll have the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compare tx 14 from the <code>B</code> file to tx 17 from <code>A</code> file and decide to use <code>B</code> first.</p>
</li>
<li>
<p>Read transactions 14, 15 and 16 from the <code>B</code> file.</p>
</li>
<li>
<p>Read transaction 12 from the file, discard it as old (previously written).</p>
</li>
<li>
<p>Switch to <code>A</code> file.</p>
</li>
<li>
<p>Read transactions 17, 18 from the <code>A</code> file.</p>
</li>
<li>
<p>Discard transaction 8 from <code>A</code> file because it is old.</p>
</li>
<li>
<p>Discard garbage data at the end of <code>A</code> file.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_recovery_with_dual_wal_files">Recovery with dual WAL files</h4>
<div class="paragraph">
<p>How would the checkpoint process work with two files, then? Previously, we could only do a real checkpoint when there were no other active transactions.
Now, we can do a checkpoint when the oldest active transaction is beyond the oldest WAL file. We&#8217;ll <code>fsync()</code> the data file and then write a zero page
at the beginning of the oldest WAL file. That ensures that we&#8217;ll no need to apply any of the data in the WAL file. We&#8217;ll still need to
consider the <em>other</em> file, of course, but that is already handled by the steps above.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how that is actually going to work. I&#8217;m going to start by implementing the recovery changes. Because we have an abstraction over the iteration
of transactions data, we won&#8217;t need to change the <code>wal_recover</code> function. We&#8217;ll start with looking into the data structures that are used during recovery.
<a href="#wal_state_t_10"><code>gavran/db.h</code> - The data structures we use to manage the WAL</a> has the details.</p>
</div>
<div id="wal_state_t_10" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The data structures we use to manage the WAL</div>
<div class="content">
<pre class="highlight"><code>typedef struct wal_file_state {
  file_handle_t *handle;
  span_t span;
  uint64_t last_write_pos;
  uint64_t last_tx_id;
} wal_file_state_t;

typedef struct wal_state {
  size_t current_append_file_index;
  wal_file_state_t files[2];
} wal_state_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#wal_state_t_10"><code>gavran/db.h</code> - The data structures we use to manage the WAL</a> you can see the <code>wal_state_t</code>, which is held by <code>db_state_t</code>. The <code>wal_state_t</code> has an array of two <code>wal_file_state_t</code> and the
<code>current_append_file_index</code> field that selects the one that is currently in use. When calling <code>wal_append()</code> we&#8217;ll always write to the WAL file indicated
by <code>current_append_file_index</code>. We&#8217;ll switch between the WAL files after each checkpoint, because that is when the <em>other</em> file has been cleared of all
previous transactions and is able to accept new ones at the start of the file.</p>
</div>
<div class="paragraph">
<p>During the recovery, however, we use a different structure, the <code>wal_recovery_operation_</code>, shown in <a href="#wal_recovery_operation"><code>wal.c</code> - The data structures we use to recover the WAL</a>.</p>
</div>
<div id="wal_recovery_operation" class="listingblock">
<div class="title"><code>wal.c</code> - The data structures we use to recover the WAL</div>
<div class="content">
<pre class="highlight"><code>typedef struct wal_recovery_operation {
  db_t *db;
  wal_state_t *wal;
  wal_file_state_t *files[2];
  size_t current_recovery_file_index;
  void *start;
  void *end;
  uint64_t last_recovered_tx_id;
  reusable_buffer_t tmp_buffer;
} wal_recovery_operation_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few differences between <code>wal_recovery_operation_t</code> and the <code>wal_state_t</code>. In particular, the <code>files</code> array in the <code>wal_recovery_operation_t</code> is
<em>not</em> necessarily in the same order as the one in <code>wal_state_t</code>. For the <code>wal_state_t</code>, the order is that the <code>A</code> file is first and <code>B</code> file is second.
For the <code>struct wal_recovery_operation</code>, the order is dependant on the value of the earliest transaction recorded.
The <code>current_recovery_file_index</code> is also different from <code>current_append_file_index</code>. That should be clear from the naming, but I&#8217;m making sure to point it
out explicitly.</p>
</div>
<div class="paragraph">
<p>The first step on the recovery process with dual WAL files is to select which one of them come before the other. This is done in the <code>wal_init_recover_state()</code>
function, shown in <a href="#wal_init_recover_state_10"><code>wal.c</code> - Initialize the state of the recovery process and select which file we&#8217;ll process first</a>.</p>
</div>
<div id="wal_init_recover_state_10" class="listingblock">
<div class="title"><code>wal.c</code> - Initialize the state of the recovery process and select which file we&#8217;ll process first</div>
<div class="content">
<pre class="highlight"><code>static void wal_init_recover_state(
    db_t *db, wal_state_t *wal, wal_recovery_operation_t *state) {
  memset(state, 0, sizeof(wal_recovery_operation_t));
  state-&gt;db                   = db;
  state-&gt;wal                  = wal;
  state-&gt;last_recovered_tx_id = 0;

  // find the appropriate order to scan through the WAL records
  uint64_t tx_ids[2] = {0, 0};
  for (size_t i = 0; i &lt; 2; i++) {
    void *start = wal-&gt;files[i].span.address;
    void *end   = start + wal-&gt;files[i].span.size;
    wal_txn_t *tx;
    if (flopped(wal_validate_transaction(
            &amp;state-&gt;tmp_buffer, start, end, &amp;tx)))
      continue;
    if (tx) {
      tx_ids[i] = tx-&gt;tx_id;
    }
  }
  errors_clear();  // errors expected, txs did not pass validation?
  if (!tx_ids[0] &amp;&amp; !tx_ids[1]) {
    state-&gt;current_recovery_file_index = 1;
    return;  // nothing to do here, no need to recover
  }
  if (tx_ids[0] &gt; tx_ids[1]) {
    if (tx_ids[1]) {
      state-&gt;files[1] = &amp;wal-&gt;files[1];
    } else {
      state-&gt;current_recovery_file_index = 1;
    }
    state-&gt;files[state-&gt;current_recovery_file_index] = &amp;wal-&gt;files[0];
  } else {
    if (tx_ids[0]) {
      state-&gt;files[1] = &amp;wal-&gt;files[0];
    } else {
      state-&gt;current_recovery_file_index = 1;
    }
    state-&gt;files[state-&gt;current_recovery_file_index] = &amp;wal-&gt;files[1];
  }
  wal_file_state_t *cur =
      state-&gt;files[state-&gt;current_recovery_file_index];
  wal-&gt;current_append_file_index =
      !state-&gt;current_recovery_file_index;
  state-&gt;start = cur-&gt;span.address;
  state-&gt;end   = state-&gt;start + cur-&gt;span.size;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a significant amount of code in <code>wal_init_recover_state()</code>, but that is mostly to handle all possible options. We start by checking the first
transaction in each file and then ordering them based on the earliest transaction id. We need to handle the case of <code>tx_id</code> being <code>0</code>, which indicate
that there are no valid transactions in the file, which is the indicator that the WAL file was reset.
We do that by only using one element in the <code>files</code> array and setting things up so the recovery process will only consider that file.</p>
</div>
<div class="paragraph">
<p>Of particular importance is the setting of <code>current_append_file_index</code> and <code>current_recovery_file_index</code>. These will always be inverse of one another.
The <code>current_recovery_file_index</code> is the first file that we&#8217;ll start the recover from and <code>current_append_file_index</code> is the file that the next call
to <code>wal_append()</code> will write to.</p>
</div>
<div class="paragraph">
<p>After the setup in <code>wal_init_recover_state()</code>, let&#8217;s take a look at how we iterate transactions. The <code>wal_recover()</code> function no longer deals with the
mechanics of iteration, that is handled by <code>wal_next_valid_transaction()</code> which knows how to merge the valid transactions across the different files.
The code for that is shown in <a href="#wal_next_valid_transaction_10"><code>wal.c</code> - Finding the next valid transaction (among multiple files)</a>.</p>
</div>
<div id="wal_next_valid_transaction_10" class="listingblock">
<div class="title"><code>wal.c</code> - Finding the next valid transaction (among multiple files)</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_next_valid_transaction(
    struct wal_recovery_operation *state, wal_txn_t **txp) {
  if (state-&gt;start &gt;= state-&gt;end ||
      !wal_validate_transaction(
          &amp;state-&gt;tmp_buffer, state-&gt;start, state-&gt;end, txp) ||
      !*txp || state-&gt;last_recovered_tx_id &gt;= (*txp)-&gt;tx_id) {
    *txp = 0;
    // <b class="conum">(1)</b>
    void *end_of_valid_tx = state-&gt;start;
    ensure(wal_validate_after_end_of_transactions(state));
    // <b class="conum">(2)</b>
    if (state-&gt;current_recovery_file_index) {
      *txp = 0;
      if (state-&gt;files[1]) {
        state-&gt;files[1]-&gt;last_write_pos = (uint64_t)(
            end_of_valid_tx - state-&gt;files[1]-&gt;span.address);
      }
      return success();
    }
    // <b class="conum">(3)</b>
    state-&gt;files[0]-&gt;last_write_pos =
        (uint64_t)(end_of_valid_tx - state-&gt;files[0]-&gt;span.address);
    state-&gt;current_recovery_file_index++;
    state-&gt;start = state-&gt;files[1]-&gt;span.address;
    state-&gt;end   = state-&gt;start + state-&gt;files[1]-&gt;span.size;
    // <b class="conum">(4)</b>
    return wal_next_valid_transaction(state, txp);
  } else {
    state-&gt;last_recovered_tx_id = (*txp)-&gt;tx_id;
    state-&gt;start = state-&gt;start + (*txp)-&gt;page_aligned_tx_size;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We now need to check to the end of the file, to see if there are valid transactions after an invalid one (meaning, disk corruption).
We now run it here, because it needs to run on <em>both</em> files.</p>
</li>
<li>
<p>If we are at the second file, we are done and can stop the iteration, there are no more possible transactions.</p>
</li>
<li>
<p>There is still a file that we need to run through, let&#8217;s setup the required fields to start iterating there.</p>
</li>
<li>
<p>Recursively call ourselves so we&#8217;ll do validation on the next file transaction, etc.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The rules we setup for the WAL say that if there is an invalid transaction, after that transaction there may be only:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invalid data of any kind.</p>
</li>
<li>
<p>Transactions that are valid (have proper hash), but have a transaction id that is lower than the last valid transaction id.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We validate this by scanning through the rest of the file one page at a page (transactions are always written on page boundary).
If we find a valid (but old) transaction, we can abort the scan because we know that we didn&#8217;t stop the recovery process due to a data corruption issue.
If we find a valid transaction that has a transaction id that is larger than the highest valid transaction id we have, we know that there is a problem.
At this point, we run into something that broke the chain, there is a missing transaction that we can&#8217;t apply. That is a cause for alarm and will abort the
recovery process with an error. We saw the details of how this work in the previous chapter and there has been no change in this regard.</p>
</div>
<div class="paragraph">
<p>Such steps may seem paranoid at time, but there is a very important rule that we have is:
<a href="https://docs.microsoft.com/en-us/archive/blogs/larryosterman/one-in-a-million-is-next-tuesday">"One in a million is next Tuesday"</a>. Even the
most unlikely of things are <em>bound</em> to happen, and we have to write the code to handle them. This particular validation check was written when Voron
gained the ability to reuse WAL files (Voron maintains a pool of them, in a more complex format, rather than just the two we have here). We have to
rely on the file system and the hardware to maintain data integrity, but we have bitten enough times to be very cautious about it.</p>
</div>
<div class="paragraph">
<p>The final part of the recovery process is handled by <code>wal_complete_recovery</code>, where we update the database&#8217;s in memory data structures.
This is shown in Listing <a href="#wal_complete_recovery"><code>wal.c</code> - Completing the recovery process by updating the in memory state of the database.</a>.</p>
</div>
<div id="wal_complete_recovery" class="listingblock">
<div class="title"><code>wal.c</code> - Completing the recovery process by updating the in memory state of the database.</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_complete_recovery(
    wal_recovery_operation_t *state) {
  txn_t recovery_tx;
  ensure(txn_create(state-&gt;db, TX_READ, &amp;recovery_tx));
  defer(txn_close, recovery_tx);
  page_t header_page = {.page_num = 0};
  ensure(txn_raw_get_page(&amp;recovery_tx, &amp;header_page));
  page_metadata_t *header = header_page.address;

  state-&gt;db-&gt;state-&gt;number_of_pages =
      header-&gt;file_header.number_of_pages;
  if (state-&gt;last_recovered_tx_id == 0) {  // empty db / no recovery
    if (header-&gt;file_header.last_tx_id != 0) {  // no recovery needed
      state-&gt;last_recovered_tx_id = header-&gt;file_header.last_tx_id;
    }

    state-&gt;db-&gt;state-&gt;number_of_pages =
        state-&gt;db-&gt;state-&gt;map.size / PAGE_SIZE;
  } else {
    ensure(header-&gt;common.page_flags == page_flags_file_header,
        msg("First page was not a metadata page?"));
  }
  ensure(
      header-&gt;file_header.last_tx_id == state-&gt;last_recovered_tx_id,
      msg("The last recovered tx id does not match the header tx id"),
      with(header-&gt;file_header.last_tx_id, "%lu"),
      with(state-&gt;last_recovered_tx_id, "%lu"));

  ensure(wal_ensure_data_file_size(
      state-&gt;db, state-&gt;db-&gt;state-&gt;number_of_pages));

  state-&gt;db-&gt;state-&gt;default_read_tx-&gt;number_of_pages =
      state-&gt;db-&gt;state-&gt;number_of_pages;
  state-&gt;db-&gt;state-&gt;default_read_tx-&gt;map = state-&gt;db-&gt;state-&gt;map;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_complete_recovery()</code> manages the last few details of setting up the in memory state of the database after the WAL recover, from here
on, it is the database that will complete its own setup.</p>
</div>
<div class="sect4">
<h5 id="_implementing_checkpoint_with_dual_wal_files">Implementing checkpoint with dual WAL files</h5>
<div class="paragraph">
<p>The checkpoint behavior of Gavran has changed with the introduction of dual WAL files. Now, instead of waiting until we reached half the WAL
and then checkpoint the file, we&#8217;ll have a slightly more sophisticated behavior, shown in Listing 10.20.
The <code>(cur_file_index + 1) &amp; 1</code> in <a href="#wal_will_checkpoint_10"><code>wal.c</code> - Deciding when to checkpoint when using double buffering between the files</a> is used to refer to the <em>other</em> WAL file, regardless of what the current one it. This basically
implements overflow addition in the range [0,1].</p>
</div>
<div id="wal_will_checkpoint_10" class="listingblock">
<div class="title"><code>wal.c</code> - Deciding when to checkpoint when using double buffering between the files</div>
<div class="content">
<pre class="highlight"><code>bool wal_will_checkpoint(db_state_t *db, uint64_t tx_id) {
  if (!db) return false;

  size_t cur_file_index   = db-&gt;wal_state.current_append_file_index;
  size_t other_file_index = (cur_file_index + 1) &amp; 1;
  bool cur_full = db-&gt;wal_state.files[cur_file_index].last_write_pos &gt;
                  db-&gt;options.wal_size / 2;
  bool other_ready =
      tx_id &gt; db-&gt;wal_state.files[other_file_index].last_tx_id;

  return cur_full &amp;&amp; other_ready;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_will_checkpoint()</code> function will return <code>true</code> under the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>current</em> WAL file is over half full.</p>
</li>
<li>
<p>The other WAL file latest transaction is old enough to ensure that no one is looking at the data from it (meaning we wrote it to disk).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that this may also trigger for the <em>current</em> file, if there haven&#8217;t been enough transactions to fill both WAL files before a checkpoint can occur.
You can see how this works in <a href="#wal_checkpoint_10"><code>wal.c</code> - On checkpoint, either reset both WAL files (if possible) or reset one and switch future transactions to append to it.</a>.</p>
</div>
<div id="wal_checkpoint_10" class="listingblock">
<div class="title"><code>wal.c</code> - On checkpoint, either reset both WAL files (if possible) or reset one and switch future transactions to append to it.</div>
<div class="content">
<pre class="highlight"><code>result_t wal_checkpoint(db_state_t *db, uint64_t tx_id) {
  size_t other_index =
      (db-&gt;wal_state.current_append_file_index + 1) &amp; 1;
  wal_file_state_t *cur =
      &amp;db-&gt;wal_state.files[db-&gt;wal_state.current_append_file_index];

  // avoid resetting if nothing is written here
  if (db-&gt;wal_state.files[other_index].last_write_pos)
    ensure(wal_reset_file(db, &amp;db-&gt;wal_state.files[other_index]));

  if (tx_id &gt;= cur-&gt;last_tx_id) {
    // can reset the current WAL as well
    ensure(wal_reset_file(db, cur));
  } else {
    // the current log is still in use, switch to the other one
    db-&gt;wal_state.current_append_file_index = other_index;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Why bother resetting the WAL files early?</div>
<div class="paragraph">
<p>We are going into some trouble to allow the code to reset both WAL files. In fact, unless there are read transactions that prevent it, the
behavior in <a href="#wal_checkpoint_10"><code>wal.c</code> - On checkpoint, either reset both WAL files (if possible) or reset one and switch future transactions to append to it.</a> will make sure that we have just a single WAL file in use. Why bother?</p>
</div>
<div class="paragraph">
<p>Having to read through the WAL files can add significantly to the startup overhead. By being eager to clear the WAL file when we <code>fsync()</code>
the data, we make sure that our startup times is reduced.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I&#8217;m currently using a fairly simplistic metric of half the WAL file being full is enough to trigger an <code>fsync()</code>. Other strategies may involve
time (say, do a checkpoint every N seconds) or size (checkpoint every 4 MB). I&#8217;m assuming that the WAL size is going to be reasonably small,
based on actual needs. A WAL size that is 16MB in size will cause us to do a checkpoint every 8MB of WAL writes. That is likely to be a good
number, but we&#8217;ll have to wait for benchmarking to confirm it.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">What happens if we can&#8217;t checkpoint?</div>
<div class="paragraph">
<p>A read transaction being open will prevent us from being able to write the data to disk. That in turn means that we can&#8217;t checkpoint. New
writes will accumulate and go to the current WAL file. We&#8217;ll increase the WAL file as needed, to accommodate the requirement. Eventually,
the read transaction will close and we&#8217;ll be able to proceed with the checkpoint process. At this point, we&#8217;ll also truncate the WAL files
back to their maximum size.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the WAL file is too large, we&#8217;ll need to truncate it, you can see that in use inside <a href="#wal_reset_file"><code>wal.c</code> - Resetting a WAL file on checkpoint</a>.</p>
</div>
<div id="wal_reset_file" class="listingblock">
<div class="title"><code>wal.c</code> - Resetting a WAL file on checkpoint</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_reset_file(
    db_state_t *db, wal_file_state_t *file) {
  (void)db;
  void *zero;
  ensure(mem_alloc_page_aligned(&amp;zero, PAGE_SIZE));
  defer(free, zero);
  memset(zero, 0, PAGE_SIZE);
  // reset the start of the log, preventing recovery from proceeding
  ensure(pal_write_file(file-&gt;handle, 0, zero, PAGE_SIZE),
      msg("Unable to reset WAL first page"));
  // <b class="conum">(1)</b>
  if (file-&gt;span.size &gt; db-&gt;options.wal_size) {
    ensure(pal_set_file_size(file-&gt;handle, 0, db-&gt;options.wal_size));
    file-&gt;span.size = db-&gt;options.wal_size;
  }
  file-&gt;last_write_pos = 0;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New code, if the WAL file is too big, we&#8217;ll trim it to the WAL size when the checkpoint allows it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In <code>wal_reset_file()</code> we are writing a page full of zeros as the first page of the file. That ensures that we won&#8217;t consider this file as
able to hold valid transactions. If the file size is bigger than the configured values, we&#8217;ll truncate the file. This might be a good place
to add more refined behavior such as waiting a cycle or two to see if the extra space is actually needed. For now, I"m going with the simplest
option.</p>
</div>
</div>
<div class="sect4">
<h5 id="_appending_to_the_wal">Appending to the WAL</h5>
<div class="paragraph">
<p>Appending to the WAL using dual WAL files didn&#8217;t change all that much. We just need to be careful not to exceed the size of the file,
most of the work of preparing the transaction to <code>wal_prepare_txn_buffer</code> (diffing the pages, compressing, building the hash, etc). That allows
us to focus solely on what <code>wal_append</code> is doing, shown in <a href="#wal_append_10"><code>wal.c</code> -  Appending a transaction to the current WAL file</a>.</p>
</div>
<div id="wal_append_10" class="listingblock">
<div class="title"><code>wal.c</code> -  Appending a transaction to the current WAL file</div>
<div class="content">
<pre class="highlight"><code>// <b class="conum">(1)</b>
static result_t wal_increase_file_size_if_needed(
    wal_file_state_t *cur_file, uint64_t size_to_write) {
  if (cur_file-&gt;last_write_pos + size_to_write &gt;
      cur_file-&gt;span.size) {
    // we need to increase the WAL size
    uint64_t wal_size =
        cur_file-&gt;span.size +
        MAX(next_power_of_two(cur_file-&gt;span.size / 10),
            size_to_write * 2);
    ensure(pal_set_file_size(cur_file-&gt;handle, wal_size, UINT64_MAX));
    cur_file-&gt;span.size = wal_size;
  }
  return success();
}

result_t wal_append(txn_state_t *tx) {
  wal_txn_t *txn_buffer;
  ensure(wal_prepare_txn_buffer(tx, &amp;txn_buffer));
  defer(free, txn_buffer);

  const size_t size = crypto_generichash_BYTES;
  ensure(!crypto_generichash(txn_buffer-&gt;hash_blake2b, size,
             (uint8_t *)txn_buffer + size,
             txn_buffer-&gt;page_aligned_tx_size - size, 0, 0),
      msg("Unable to compute hash for transaction"),
      with(txn_buffer-&gt;tx_id, "%lu"));

  wal_state_t *wal = &amp;tx-&gt;db-&gt;wal_state;

  // <b class="conum">(2)</b>
  wal_file_state_t *cur_file =
      &amp;wal-&gt;files[wal-&gt;current_append_file_index];
  ensure(wal_increase_file_size_if_needed(
      cur_file, txn_buffer-&gt;page_aligned_tx_size));
  ensure(pal_write_file(cur_file-&gt;handle, cur_file-&gt;last_write_pos,
      (char *)txn_buffer, txn_buffer-&gt;page_aligned_tx_size));
  cur_file-&gt;last_write_pos += txn_buffer-&gt;page_aligned_tx_size;
  cur_file-&gt;last_tx_id = tx-&gt;tx_id;
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Check if we need to increase the size of the WAL to accommodate the next write and increase the file if needed.</p>
</li>
<li>
<p>New code here, we select the current file to append to, check if we need to increase the size of the file and then write to the file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In <code>wal_append()</code> we generate the hash for the transaction and then check if there is space in the current WAL file and increase the
size if needed. It <em>always</em> write to the current WAL file. Switching between them is the responsibility of <code>wal_checkpoint()</code>.</p>
</div>
<div class="paragraph">
<p>This turned out to be a much longer chapter than expected. We have learned how to extend the size of the data file safely and how to build double
buffering for the WAL file to handle continuously running transactions.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit Tests</h3>
<div class="paragraph">
<p>I actually run into a problem with the unit tests here. In Chapter 5, we tested that we&#8217;ll get <code>ENOSPC</code> if we allocate beyond the size limit. We
now have the ability to extend the file, so we actually got a test failure because of this issue. I added a <code>maximum_size</code> option to the
<code>database_option_t</code> structure to allow us to make such a limit.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Why not change the test?</div>
<div class="paragraph">
<p>There are actually reasonable scenarios where you might want to have an enforced size limit. For example, assume that you have many databases
being used, one for each user, and you want to ensure that there is some fairness in using the disk space among all of these. LevelDB, for example,
was originally intended for use in Chrome, and there you have a size limit per website for how much you can store. That is a use case for this feature
and it took very little code (add the field, and add a check on <code>db_try_increase_file_size</code>), so I implemented it rather than change the test.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You can see the tests in <a href="#test_10"><code>test.c</code> - Unit testing growing the size of the database</a>.</p>
</div>
<div id="test_10" class="listingblock">
<div class="title"><code>test.c</code> - Unit testing growing the size of the database</div>
<div class="content">
<pre class="highlight"><code>static result_t write_a_lot(db_t* db) {
  for (size_t i = 0; i &lt; 3; i++) {
    txn_t wtx;
    ensure(txn_create(db, TX_WRITE, &amp;wtx));
    defer(txn_close, wtx);
    for (size_t j = 0; j &lt; 14; j++) {
      page_t p = {.number_of_pages = 1};
      ensure(txn_allocate_page(&amp;wtx, &amp;p, 0));
      p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
      p.metadata-&gt;overflow.number_of_pages = 1;
      randombytes_buf(p.address, PAGE_SIZE);
    }
    ensure(txn_commit(&amp;wtx));
  }
  return success();
}

describe(size_growth) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("Can allocate and grow the data file") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    uint64_t old_size = db.state-&gt;handle-&gt;size;
    assert(write_a_lot(&amp;db));
    uint64_t new_size = db.state-&gt;handle-&gt;size;

    assert(new_size &gt; old_size);
  }

  it("WAL will stay within the specified limit") {
    db_t db;
    db_options_t options = {
        .minimum_size = 128 * 1024, .wal_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    uint64_t old_size = db.state-&gt;wal_state.files[0].span.size;
    assert(write_a_lot(&amp;db));
    uint64_t new_size = db.state-&gt;wal_state.files[0].span.size;

    assert(new_size == old_size);
  }

  it("can grow WAL size") {
    db_t db;
    db_options_t options = {
        .minimum_size = 128 * 1024, .wal_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_READ, &amp;tx));
    defer(txn_close, tx);

    uint64_t old_size = db.state-&gt;wal_state.files[0].span.size;
    assert(write_a_lot(&amp;db));
    uint64_t new_size = db.state-&gt;wal_state.files[0].span.size;

    assert(new_size &gt; old_size);
  }

  it("will use both WAL files and reset the size") {
    db_t db;
    db_options_t options = {
        .minimum_size = 128 * 1024, .wal_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx1;
    assert(txn_create(&amp;db, TX_READ, &amp;tx1));
    defer(txn_close, tx1);

    uint64_t old_size_a = db.state-&gt;wal_state.files[0].span.size;
    assert(write_a_lot(&amp;db));  // no checkpoint due to tx1, will grow
    uint64_t new_size_a = db.state-&gt;wal_state.files[0].span.size;
    assert(new_size_a &gt; old_size_a);

    // now we have a new transaction prevent complete clear
    txn_t tx2;
    assert(txn_create(&amp;db, TX_READ, &amp;tx2));
    defer(txn_close, tx2);

    // reason to stop checkpointing A is gone
    assert(txn_close(&amp;tx1));
    // should now switch to B
    uint64_t old_size_b = db.state-&gt;wal_state.files[1].span.size;
    assert(write_a_lot(&amp;db));  // no checkpoint due to tx2, will grow
    uint64_t new_size_b = db.state-&gt;wal_state.files[1].span.size;
    assert(new_size_b &gt; old_size_b);

    assert(txn_close(&amp;tx2));
    // can now switch back to A
    // when this happens, we reset A

    uint64_t newest_size_a = db.state-&gt;wal_state.files[0].span.size;
    assert(new_size_a &gt; newest_size_a);
  }

  it("can recover data fila changes that has been truncated") {
    uint64_t page;
    {
      db_t db;
      db_options_t options = {
          .minimum_size = 128 * 1024, .wal_size = 128 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);

      txn_t leaked;
      assert(txn_create(&amp;db, TX_READ, &amp;leaked));
      assert(write_a_lot(&amp;db));

      txn_t wtx;
      assert(txn_create(&amp;db, TX_WRITE, &amp;wtx));
      page_t p = {.number_of_pages = 1};
      assert(txn_allocate_page(&amp;wtx, &amp;p, 0));
      p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
      p.metadata-&gt;overflow.number_of_pages = 1;
      strcpy(p.address, "Hello Gavran");
      assert(txn_commit(&amp;wtx));
      page = p.page_num;
    }
    {
      // truncate the file
      file_handle_t* handle;
      assert(pal_create_file(
          "/tmp/db/try", &amp;handle, pal_file_creation_flags_none));
      defer(pal_close_file, handle);
      assert(pal_set_file_size(handle, 0, 64 * 1024));
      assert(handle-&gt;size == 64 * 1024);
    }
    {
      db_t db;
      db_options_t options = {
          .minimum_size = 128 * 1024, .wal_size = 128 * 1024};
      assert(db_create("/tmp/db/try", &amp;options, &amp;db));
      defer(db_close, db);

      txn_t r;
      assert(txn_create(&amp;db, TX_READ, &amp;r));
      defer(txn_close, r);
      page_t p = {.page_num = page};
      assert(txn_get_page(&amp;r, &amp;p));
      assert(strcmp("Hello Gavran", p.address) == 0);
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
  <ul style="list-style-type: none;">
    <li><a class="footer-text" href="../index.html">Table of contents</a></li>
    <li><a class="footer-text" href="./ch09.html">Previous chapter</a></li>
    <li><a class="footer-text" href="./ch11.html">Next chapter</a></li>
  </ul>
</div>
</body>
</html>