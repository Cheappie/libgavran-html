<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Implementing durable writes</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_implementing_durable_writes">Implementing durable writes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We now have transactions that support Atomicity and Isolation, but all our writes are done using buffered I/O. That means that we are subject to a whole
<em>host</em> of potential issues. The most obvious one is power loss. If we pull the plug on the system immediately after a transaction is committed, we&#8217;ll
lose data.</p>
</div>
<div class="paragraph">
<p>For that matter, we only write data to disk after all existing transactions are no longer looking at it. If we have a long running transaction, that may
prevent us from writing to the disk for a <em>while</em>, significantly increasing the risk of data lose. <a href="#data_loss"><code>test.c</code> - Losing committed writes because of a rude abort</a> shows an example of losing data.</p>
</div>
<div id="data_loss" class="listingblock">
<div class="title"><code>test.c</code> - Losing committed writes because of a rude abort</div>
<div class="content">
<pre class="highlight"><code>static result_t write_to_page(db_t* db, const void* msg,
                              size_t size) {
  txn_t wtx;
  ensure(txn_create(db, TX_WRITE, &amp;wtx));
  defer(txn_close, wtx);
  page_t page = {.page_num = 3};
  ensure(txn_raw_modify_page(&amp;wtx, &amp;page));
  memcpy(page.address, msg, size);
  ensure(txn_commit(&amp;wtx));
  return success();
}

static result_t data_loss(const char* path) {
  db_t db;
  db_options_t options = {.minimum_size = 4 * 1024 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  // <b class="conum">(1)</b>
  txn_t rtx;
  ensure(txn_create(&amp;db, TX_READ, &amp;rtx));
  // <b class="conum">(2)</b>
  ensure(write_to_page(&amp;db, "Hello Gavran", strlen("Hello Gavran")));

  // <b class="conum">(3)</b>
  rude_shutdown_db(&amp;db);

  // <b class="conum">(4)</b>
  ensure(db_create("/tmp/db/try", &amp;options, &amp;db));
  defer(db_close, db);
  ensure(txn_create(&amp;db, TX_READ, &amp;rtx));
  page_t p = {.page_num = 3};
  ensure(txn_raw_get_page(&amp;rtx, &amp;p));
  ensure(strcmp("Hello Gavran", p.address) == 0);
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Opening a read transaction which will prevent us from writing to disk.</p>
</li>
<li>
<p>Crete write transaction, write to a page and <strong>commit</strong> the transaction.</p>
</li>
<li>
<p>Simulate a crash by simply closing all the resources of the database rudely.</p>
</li>
<li>
<p>Open the database again and try to read the committed data.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you&#8217;ll run the code in <a href="#data_loss"><code>test.c</code> - Losing committed writes because of a rude abort</a> you&#8217;ll see that after we open the database the second time, the committed data was lost. The changes never made it to disk.
There are valid reasons why you&#8217;ll want to have a storage engine with this behavior. Performance is usually the cited concern, and for some systems, that
is an appropriate choice. Not for Gavran, I want it to be <em>transactional</em>, which means full durability. If a transaction commit was successful, it needs to be
there through anything short of actual hardware failure that corrupted the data on disk.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">It doesn&#8217;t end with a <code>write()</code></div>
<div class="paragraph">
<p>In <a href="#data_loss"><code>test.c</code> - Losing committed writes because of a rude abort</a>, the issue is that we aren&#8217;t writing to the disk. If we <em>were</em> to write to the disk, however, it would only mask the problem. Writing to the
disk is anything but easy, if you care about durability. We talked about this a bit in Chapter 3, when we had to jump through hoops to get the file creation
to persist regardless of what is going on.</p>
</div>
<div class="paragraph">
<p>When writing to a file, we need to take into account that calling <code>write()</code> is just the start. The OS may decide to arbitrarily delay the actual write to disk
and even the disk may buffer the writes. The order in which you issue writes and the order in which they are persisted is not guaranteed. And writes to the
disk are <em>not</em> atomic.</p>
</div>
<div class="paragraph">
<p><a href="https://danluu.com/deconstruct-files/">Files are fraught with peril</a> and <a href="http://danluu.com/file-consistency/">Files are hard</a> posts sum up the situation
quite nicely. I also referred to the <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-pillai.pdf">All File Systems Are Not Created Equal</a>
paper (also called ALICE paper) in Chapter 3. In the paper, a whole bunch of applications (including multiple database engines) were tested and
almost all of them had some issues around properly writing to disk. We clearly need more than a simple <code>write()</code> to help us.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll be testing Gavran with <a href="https://github.com/madthanu/alice">ALICE tracing</a> later in this book.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We know that calling <code>write()</code> won&#8217;t be sufficient, but before we can start on fixing this, we need to first understand where we&#8217;ll be writing <em>to</em>. We
can&#8217;t write to the data file, there are transactions that are looking at the data there. We have to write to some other location.</p>
</div>
<div class="sect2">
<h3 id="_writing_to_a_write_ahead_log">Writing to a Write Ahead Log</h3>
<div class="paragraph">
<p>Instead of writing to the database file directly, we&#8217;ll write all the changes that we <em>want</em> to make to another file. The technique is also called
Write Ahead Log (WAL) and is used by the vast majority of databases that want to achieve durability. There are two exceptions that I can think of with
regards to the use of WAL to allow durability of transactions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LDMB - Instead of using using WAL, it uses Copy on Write to other pages in the same data file. In other words, you don&#8217;t have stable page numbers, but
each time you <code>modify</code> a page, a new page number will be allocated for you. That has implications for the amount of data that changes whenever a
modification occurs. You have to <code>modify</code> not just that particular page but any that references it. On large databases, that can cause a single byte
change to require dozens of KB to be written to disk. The upside of this approach is that LMDB requires no startup logic or recovery phase.</p>
</li>
<li>
<p>CouchDB - Instead of a WAL, it uses an append only mode. Writes are always done at the end of the file. Similarly to LMDB, a <code>modify</code> will cause the
data as well as anything that reference it to be written to the end of the file again. On startup, the database scans from the end of the file to find
a commit marker and start from there. An additional downside is that the database needs to run occasional compactions to free wasted disk space.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The idea of a WAL is that we&#8217;ll write what we <em>intend</em> to do, so if we crash, we can can replay our actions and end up in the same situation as we
were before the crash.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start working on the WAL by looking at the interface it exposes, shown in <a href="#wal_api"><code>gavran/internal.h</code> - The internal API for the WAL in Gavran</a>.</p>
</div>
<div id="wal_api" class="listingblock">
<div class="title"><code>gavran/internal.h</code> - The internal API for the WAL in Gavran</div>
<div class="content">
<pre class="highlight"><code>result_t wal_open_and_recover(db_t *db);
result_t wal_append(txn_state_t *tx);
bool wal_will_checkpoint(db_state_t *db, uint64_t tx_id);
result_t wal_checkpoint(db_state_t *db, uint64_t tx_id);
result_t wal_close(db_state_t *db);
enable_defer(wal_close);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The roles of these functions are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>wal_open_and_recover()</code> function is called from <code>db_init()</code>, to run over the WAL and apply any changes from committed transactions.</p>
</li>
<li>
<p>The <code>wal_append()</code> is called from <code>txn_commit()</code>, that is what ensures that the data is durable.</p>
</li>
<li>
<p>And <code>wal_checkpoint()</code> (and <code>wal_will_checkpoint()</code>) is called from <code>txn_write_state_to_disk()</code> to tell the WAL that the transactions up to the specified <code>tx_id</code> have been safely stored in the disk
and can be cleared from the WAL.</p>
</li>
<li>
<p>And <code>wal_close()</code> is called from <code>db_close()</code> to safely shut down the WAL (note that is explicitly not required for things to continue working). The whole <em>point</em> of the WAL
is to ensure that a crash / failure will not cause us to lose data that was previously committed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ll start looking at the WAL logic from the data structures that are here to support it, shown in <a href="#wal_data_structs"><code>gavran/db.h</code> - In memory structures used to manage the WAL behavior while the database is running</a>.</p>
</div>
<div id="wal_data_structs" class="listingblock">
<div class="title"><code>gavran/db.h</code> - In memory structures used to manage the WAL behavior while the database is running</div>
<div class="content">
<pre class="highlight"><code>typedef struct wal_file_state {
  file_handle_t *handle;
  span_t span;
  uint64_t last_write_pos;
  uint64_t last_tx_id;
} wal_file_state_t;

typedef struct wal_state {
  size_t current_append_file_index;
  wal_file_state_t files[2];
} wal_state_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_state_t</code> is used to manage the overall WAL state, it is an in memory structure only, held by the <code>db_state_t</code>. This is used to manage the WAL interactions
while we are running the database. In addition to the in memory data, there is also <em>persistent</em> data that is written to the WAL itself. Those are shown in <a href="#wal_txn_t"><code>wal.c</code> - Persistent structures used to store transactions data to disk</a>.
Note that in the case of both <a href="#wal_txn_t"><code>wal.c</code> - Persistent structures used to store transactions data to disk</a> and <a href="#wal_data_structs"><code>gavran/db.h</code> - In memory structures used to manage the WAL behavior while the database is running</a>, we are showing the <em>end</em> result. In this chapter we are going to work with some of the data in these
structs, and we&#8217;ll complete the WAL work in the next chapter.</p>
</div>
<div id="wal_txn_t" class="listingblock">
<div class="title"><code>wal.c</code> - Persistent structures used to store transactions data to disk</div>
<div class="content">
<pre class="highlight"><code>enum wal_txn_page_flags {
  wal_txn_page_flags_none = 0,
  wal_txn_page_flags_diff = 1,
};

typedef struct wal_txn_page {
  uint64_t page_num;
  uint64_t offset;
  uint32_t number_of_pages;
  uint32_t flags;
} wal_txn_page_t;

enum wal_txn_flags {
  wal_txn_flags_none       = 0,
  wal_txn_flags_compressed = 1,
};

typedef struct wal_txn {
  uint8_t hash_blake2b[32];
  uint64_t tx_id;
  uint64_t page_aligned_tx_size;
  uint64_t tx_size;
  uint64_t number_of_modified_pages;
  enum wal_txn_flags flags;
  uint8_t padding[4];
  struct wal_txn_page pages[];
} wal_txn_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_txn_t</code> represents a single transaction that was written to the WAL. And the <code>wal_tx_page_t</code> structure holds information about a single page modified in that transaction.
Those can all be considered as the <em>metadata</em> of the transaction in the WAL. Let&#8217;s see how we are using this in the WAL, <a href="#wal_append"><code>wal.c</code> - Appending the transaction&#8217;s data to the WAL</a> shows the <code>wal_append()</code> function, which persists
the transaction&#8217;s operations. We call this function from <code>txn_commit()</code>, and a successful call to <code>wal_append()</code> ensures that if there is any kind of failure, when we start the database
we&#8217;ll be able to recover any changes made by the transaction.</p>
</div>
<div id="wal_append" class="listingblock">
<div class="title"><code>wal.c</code> - Appending the transaction&#8217;s data to the WAL</div>
<div class="content">
<pre class="highlight"><code>result_t wal_append(txn_state_t *tx) {
  wal_txn_t *txn_buffer;
  ensure(wal_prepare_txn_buffer(tx, &amp;txn_buffer));
  defer(free, txn_buffer);

  wal_state_t *wal = &amp;tx-&gt;db-&gt;wal_state;

  wal_file_state_t *cur_file = &amp;wal-&gt;files[0];
  ensure(pal_write_file(cur_file-&gt;handle, cur_file-&gt;last_write_pos,
      (char *)txn_buffer, txn_buffer-&gt;page_aligned_tx_size));
  cur_file-&gt;last_write_pos += txn_buffer-&gt;page_aligned_tx_size;
  cur_file-&gt;last_tx_id = tx-&gt;tx_id;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_append()</code> function isn&#8217;t actually doing much. It ask <code>wal_prepare_txn_buffer()</code> to do the work, then it writes the data to the <code>cur_file</code> using <code>pal_write_file()</code>. There is
some bookkeeping to manage where the next write will go to, but that is about it. For now, I&#8217;m ignoring things like <code>files</code> being an array with two values and WAL file management in
general, these will be explained in the next chapter. What is important right now is to understand that we gather all the data from the transaction and write it to disk. Later on we
can use this information to recover on startup, repeating any committed transaction.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Gavran is using a "blind" WAL model</div>
<div class="paragraph">
<p>There are many ways to structure a WAL, but I have chosen to use a WAL model that sits <em>very</em> low in the stack. The WAL we use has <em>no</em> idea about what kind of data is stored or how
to manipulate persistent data structure. The only thing that the WAL does is store the <em>raw binary</em> page data. Aside from understanding the concept of pages (page number and the number
of pages), the WAL was have is unaware of anything built on top it.</p>
</div>
<div class="paragraph">
<p>That means that we can add more features to Gavran without considering the impact on the WAL. Other features can be built on top of the WAL as well, log shipping and incremental
backups can both be built on top of this infrastructure.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This ability to replay transaction by writing the modifications they made to the disk is a <em>really</em> important property of the WAL. It means that we can mostly be free from considerations
of what changes happened, what is the <em>meaning</em> of them, etc. We are dealing with the raw pages and look at the data as binary changes that we can operate on.
The interesting work in appending to the WAL is happening in <code>wal_prepare_txn_buffer()</code>, which is shown in <a href="#wal_prepare_txn_buffer"><code>wal.c</code> - Preparing the buffer to write to the WAL</a>.</p>
</div>
<div id="wal_prepare_txn_buffer" class="listingblock">
<div class="title"><code>wal.c</code> - Preparing the buffer to write to the WAL</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_prepare_txn_buffer(
    txn_state_t *tx, wal_txn_t **txn_buffer) {
  uint64_t pages = tx-&gt;modified_pages-&gt;count;
  size_t tx_header_size =
      TO_PAGES(sizeof(wal_txn_t) + pages * sizeof(wal_txn_page_t)) *
      PAGE_SIZE;
  uint64_t total_size = tx_header_size + pages * PAGE_SIZE;
  size_t cancel_defer = 0;
  wal_txn_t *wt;
  ensure(mem_alloc_page_aligned((void *)&amp;wt, total_size));
  try_defer(free, wt, cancel_defer);
  memset(wt, 0, total_size);
  wt-&gt;number_of_modified_pages = pages;
  wt-&gt;tx_id                    = tx-&gt;tx_id;
  void *end                    = wal_setup_transaction_data(
      tx, wt, ((char *)wt) + tx_header_size);
  wt-&gt;tx_size              = (uint64_t)((char *)end - (char *)wt);
  wt-&gt;page_aligned_tx_size = TO_PAGES(wt-&gt;tx_size) * PAGE_SIZE;
  *txn_buffer              = wt;
  cancel_defer             = 1;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The purpose of <code>wal_prepare_txn_buffer()</code> is to prepare the buffer, and it is well named, because the <em>real</em> work is done in <code>wal_setup_transaction_data()</code> while <code>wal_prepare_txn_buffer()</code>
will just&#8230;&#8203; prepare the buffer. The first thing that happens is that we compute the size of the buffer. In addition to <code>wal_txn_t</code>, we also have an array of <code>wal_tx_page_t</code> that will hold
the metadata of the transaction, followed by the actual pages we need to write.
Notice that we use <code>mem_alloc_page_aligned()</code> to allocate the memory. As a reminder, the term "page" in this context means OS memory page, which is 4KB in
size, not the internal pages we have in Gavran. Using page aligned memory is not really important at this point, but will become crucial later, when we start issuing direct I/O operations.</p>
</div>
<div class="paragraph">
<p>We record the transaction number and the number of pages and then call to <code>wal_setup_transaction_data()</code> to move the data to the prepared buffer. Note that we pass it the buffer <em>after</em> the
<code>tx_header_size</code> and that the <code>tx_header_size</code> is page aligned so the buffer that is sent to <code>wal_setup_transaction_data()</code> will also be page aligned. Afterward, we record the size used as well
as the <code>page_aligned_tx_size</code>. Our job done, we can return to <code>wal_append()</code>, which will write the data to disk directly. Let&#8217;s dig into what is going on when we setup the WAL transaction
data, you can see what is going on in <a href="#wal_setup_transaction_data"><code>wal.c</code> - Copying the data from the transaction <code>modified_pages</code> to the WAL transaction buffer</a>.</p>
</div>
<div id="wal_setup_transaction_data" class="listingblock">
<div class="title"><code>wal.c</code> - Copying the data from the transaction <code>modified_pages</code> to the WAL transaction buffer</div>
<div class="content">
<pre class="highlight"><code>static void *wal_setup_transaction_data(
    txn_state_t *tx, wal_txn_t *wt, void *output) {
  size_t iter_state = 0;
  page_t *entry;
  size_t index = 0;
  while (pagesmap_get_next(tx-&gt;modified_pages, &amp;iter_state, &amp;entry)) {
    wt-&gt;pages[index].number_of_pages = entry-&gt;number_of_pages;
    wt-&gt;pages[index].page_num        = entry-&gt;page_num;
    size_t size = wt-&gt;pages[index].number_of_pages * PAGE_SIZE;
    memcpy(output, entry-&gt;address, size);
    void *end               = output + size;
    wt-&gt;pages[index].flags  = wal_txn_page_flags_none;
    wt-&gt;pages[index].offset = (uint64_t)(output - (void *)wt);
    output                  = end;
    index++;
  }
  return output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>wal_setup_transaction_data()</code> we are simply going to iterate over the <code>modified_pages</code> in the transaction and copy them to the buffer that was setup for us. We also update the <code>pages</code>
array on the <code>wal_txn_t</code> with the offset of the page from the beginning of the transaction, the page number and the number of pages written.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Using <code>pwritev()</code> instead of <code>write()</code>?</div>
<div class="paragraph">
<p>In <code>wal_append()</code> we are writing from many memory locations (all the modified pages) to a single location on disk. That is a feature tailored made
for the <code>pwritev()</code> call, which allows us to coalesce multiple buffers into a single write. It would allow us to save the single buffer allocation and
the cost associated with copying the memory to a single buffer.</p>
</div>
<div class="paragraph">
<p>There are a few reasons why we <em>want</em> to have a single buffer for the transaction, we&#8217;ll look at them in depth in the next chapter, for now, I want to
focus on the implications of using <code>pwritev()</code> in a storage engine like Gavran.</p>
</div>
<div class="paragraph">
<p>In particular, I wanted to touch on cross platform compatibility with advanced API. For many database operations, <code>pwritev()</code> is the right tool for the job.
On Windows, on the other hand, you have <code>WriteFileGather</code> which allows you to pass an array of pages. Slightly more complex, but works fairly well.</p>
</div>
<div class="paragraph">
<p>For the most part, you can assume that most operating systems will have similar API at the file system level. They all have to work with the
same constraints, after all. MacOS, however, doesn&#8217;t seem to have this API, it has <code>writev()</code>, though.</p>
</div>
<div class="paragraph">
<p>That said, <code>WriteFileGather</code> is available from 2003 and <code>pwritev</code> exists only from 2009. The <code>writev</code> system call, on the other hand, goes
to about 2001 or so. As a database developer, I love to use API that has been around for a decade or two. It means that most of the bugs
have been shaken out.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We wrote the transaction to the WAL file, but what did we actually write? <a href="#wal_tx_structure">The structure of a single transaction inside the WAL</a> shows the structure of a single transaction in the WAL.</p>
</div>
<div id="wal_tx_structure" class="imageblock">
<div class="content">
<img src="../imgs/wal_tx_structure.png" alt="wal tx structure">
</div>
<div class="title">Figure 1. The structure of a single transaction inside the WAL</div>
</div>
<div class="paragraph">
<p>The purpose of the WAL is to make sure that committed transactions aren&#8217;t lost. In other databases, it is also responsible for rollback uncommitted
transactions, but Gavran is using a different model and doesn&#8217;t have to worry about that. We can now reconstruct committed transactions by looking
at the WAL for the pages that they modified.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note on error handling</div>
<div class="paragraph">
<p>The PAL code probably deserve some additional checks for error handling. For example, we need to take into account that we may get <code>EINTR</code> and
need to retry the operation again. There is a <em>lot</em> that goes into proper writing to files, I&#8217;m afraid.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Recovering a committed transaction is easy, take the copy of the pages in the WAL and put them in the data file, done. As simple as this is, that
is all we need to get proper recovery in this scenario.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The format of write ahead log</div>
<div class="paragraph">
<p>One of the things that make it <em>hard</em> to build a database is that there are so many interconnected details. Consider the impact of the WAL on the
database design, or how the specifics of an MVCC implementation affect the on disk data format.</p>
</div>
<div class="paragraph">
<p>Write ahead logs aren&#8217;t new, they have been around for as long as there have been transactional databases. They are one of the few ways to <em>achieve</em>
durability and usually the only way that can meet realistic performance goals. A common algorithm that uses WAL is called
<a href="https://dl.acm.org/doi/10.1145/128765.128770">ARIES</a> - Algorithms for Recovery and Isolation Exploiting Semantics. It is used by SQL Server, DB2, etc.
It is an involved system, requiring Redo and Undo logs and a fairly complex dance on startup to ensure that you are back in the same place as you were
before.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ll notice, we aren&#8217;t doing anything so complicated. We record the pages in the WAL and can apply them in place to recover committed transactions.
The entire recovery code fits inside a single page and there is no need for an Undo step, because uncommitted changes never hit the WAL. This is one of
the advantages of having an embedded system, we don&#8217;t have to cater to the latency inherit to most networked database where transactions may span many
seconds or even minutes and hours.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#data_loss"><code>test.c</code> - Losing committed writes because of a rude abort</a> we have a scenario where a read transaction prevents us from writing to the data file, and then we simulate a crash rudely aborting
the database and transaction. Now that we have <code>wal_append()</code>, we have written the changes in the committed write transaction to disk. The next step is
to see how we can recover from such a scenario. Take a look at <a href="#wal_open_and_recover"><code>wal.c</code> - Opening the WAL and calling <code>wal_recover()</code> on startup</a>, where we explore the <code>wal_open_and_recover()</code>.</p>
</div>
<div id="wal_open_and_recover" class="listingblock">
<div class="title"><code>wal.c</code> - Opening the WAL and calling <code>wal_recover()</code> on startup</div>
<div class="content">
<pre class="highlight"><code>result_t wal_open_and_recover(db_t *db) {
  memset(&amp;db-&gt;state-&gt;wal_state, 0, sizeof(wal_state_t));
  wal_state_t *wal = &amp;db-&gt;state-&gt;wal_state;
  {
    ensure(wal_open_single_file(&amp;wal-&gt;files[0], db, 'a'));
    defer(pal_unmap, wal-&gt;files[0].span);
    defer(pal_close_file, wal-&gt;files[0].handle);
    ensure(wal_recover(db, wal));
  }
  ensure(wal_open_file(
      &amp;wal-&gt;files[0], db, 'a', pal_file_creation_flags_durable));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wal_open_and_recover()</code> function is called by <code>db_create()</code> just before <code>db_init()</code>. The <code>wal_open_and_recover()</code> isn&#8217;t really doing much. It setup
the opens the WAL file using <code>wal_open_single_file()</code> and calls to <code>wal_recover()</code> which does the actual work. Before we dive into that, let&#8217;s look into
what does it means, to open a WAL file, you can see the code in <a href="#wal_open_single_file"><code>wal.c</code> - Opening a WAL file</a>.</p>
</div>
<div id="wal_open_single_file" class="listingblock">
<div class="title"><code>wal.c</code> - Opening a WAL file</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_get_wal_filename(
    const char *db_file_name, char wal_code, char **wal_file_name) {
  size_t db_name_len = strlen(db_file_name);  // \0 + -a.wal
  ensure(mem_alloc((void *)wal_file_name, db_name_len + 1 + 6));
  memcpy(*wal_file_name, db_file_name, db_name_len);
  (*wal_file_name)[db_name_len++] = '-';
  (*wal_file_name)[db_name_len++] = wal_code;
  memcpy((*wal_file_name) + db_name_len, ".wal", 5);  // include \0
  return success();
}
static result_t wal_open_file(struct wal_file_state *file_state,
    db_t *db, char wal_code, enum pal_file_creation_flags flags) {
  char *wal_file_name;
  ensure(wal_get_wal_filename(
      db-&gt;state-&gt;handle-&gt;filename, wal_code, &amp;wal_file_name));
  defer(free, wal_file_name);
  ensure(pal_create_file(wal_file_name, &amp;file_state-&gt;handle, flags));
  return success();
}
static result_t wal_open_single_file(
    struct wal_file_state *file_state, db_t *db, char wal_code) {
  ensure(wal_open_file(
      file_state, db, wal_code, pal_file_creation_flags_none));
  ensure(pal_set_file_size(
      file_state-&gt;handle, db-&gt;state-&gt;options.wal_size, UINT64_MAX));
  file_state-&gt;span.size = file_state-&gt;handle-&gt;size;
  ensure(pal_mmap(file_state-&gt;handle, 0, &amp;file_state-&gt;span));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#wal_open_single_file"><code>wal.c</code> - Opening a WAL file</a> setup the WAL file name, which is just the <code>&lt;db_name&gt;-a.wal</code> and then opens it, set its minimum size (with the database
option <code>wal_size</code>) and maps the file to memory. The real fun happens in <code>wal_recover()</code>, shown in <a href="#wal_recover"><code>wal.c</code> -  Recovering committed transactions from the WAL</a>, where we start the actual recovery
process.</p>
</div>
<div id="wal_recover" class="listingblock">
<div class="title"><code>wal.c</code> -  Recovering committed transactions from the WAL</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_recover(db_t *db, wal_state_t *wal) {
  wal_recovery_operation_t recovery_state;
  wal_init_recover_state(db, wal, &amp;recovery_state);
  pages_map_t *recovered_pages;
  ensure(pagesmap_new(16, &amp;recovered_pages));
  defer(free, recovered_pages);

  while (true) {
    wal_txn_t *tx;
    ensure(wal_next_valid_transaction(&amp;recovery_state, &amp;tx));
    if (!tx) break;
    ensure(wal_recover_tx(db, tx, &amp;recovered_pages));
  }
  ensure(wal_complete_recovery(&amp;recovery_state));
  ensure(wal_validate_recovered_pages(db, recovered_pages));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>wal_recover</code>, we scan through the WAL file using the <code>wal_next_valid_transaction()</code> function, which we&#8217;ll see shortly. Then recover the transaction
using <code>wal_recover_tx()</code>. You can see the details of <code>wal_recover_tx()</code> in <a href="#wal_recover_tx"><code>wal.c</code> -  Recovering a single transaction from the WAL</a>.
Whereas <code>wal_recover()</code> runs through all the transactions in the WAL, <code>wal_recover_tx()</code> is concerned with recovering a single transaction. The function runs
over the <code>pages</code> in the transaction and write each one of them to the data file.</p>
</div>
<div id="wal_recover_tx" class="listingblock">
<div class="title"><code>wal.c</code> -  Recovering a single transaction from the WAL</div>
<div class="content">
<pre class="highlight"><code>static result_t free_hash_table_and_contents(pages_map_t **pages) {
  size_t iter_state = 0;
  page_t *p;
  while (pagesmap_get_next(*pages, &amp;iter_state, &amp;p)) {
    free(p-&gt;address);
  }
  free(*pages);
  return success();
}
enable_defer(free_hash_table_and_contents);

static result_t wal_recover_tx(
    db_t *db, wal_txn_t *tx, pages_map_t **recovered_pages) {
  void *input = (void *)tx + sizeof(wal_txn_t) +
                sizeof(wal_txn_page_t) * tx-&gt;number_of_modified_pages;
  pages_map_t *pages;
  ensure(pagesmap_new(
      next_power_of_two(tx-&gt;number_of_modified_pages +
                        tx-&gt;number_of_modified_pages / 2),
      &amp;pages));
  defer(free_hash_table_and_contents, pages);
  for (size_t i = 0; i &lt; tx-&gt;number_of_modified_pages; i++) {
    size_t end_offset = i + 1 &lt; tx-&gt;number_of_modified_pages
                            ? tx-&gt;pages[i + 1].offset
                            : tx-&gt;tx_size;
    ensure(wal_recover_page(db, &amp;pages, tx-&gt;pages + i,
        ((void *)tx) + end_offset, tx, &amp;input));
  }
  size_t iter_state = 0;
  page_t *p;
  while (pagesmap_get_next(pages, &amp;iter_state, &amp;p)) {
    page_t existing = {.page_num = p-&gt;page_num};
    if (!pagesmap_lookup(*recovered_pages, &amp;existing)) {
      ensure(pagesmap_put_new(recovered_pages, p));
    }
    ensure(pal_write_file(db-&gt;state-&gt;handle, p-&gt;page_num * PAGE_SIZE,
        p-&gt;address, p-&gt;number_of_pages * PAGE_SIZE));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#wal_recover_tx"><code>wal.c</code> -  Recovering a single transaction from the WAL</a> you can see that <code>wal_recover_tx()</code> is using a hash table to keep track of the modified <code>pages</code>. For each page in the transaction <code>wal_recover_tx()</code>
will call to <code>wal_recover_page()</code> to actually put the value from the WAL into the <code>pages</code> hash table. After we run through the entire transaction in the WAL, we&#8217;ll write
all those pages to the data file using <code>pal_write_file()</code>. The idea is that we&#8217;ll only write to the data file <em>after</em> we finished processing the whole transaction. This
gives us the chance to run additional validations during the transaction recovery. <a href="#wal_recover_page"><code>wal.c</code> -  Recover a single page from the WAL to the <code>pages</code> hash table</a> shows how we manage a single page recovery using <code>wal_recover_page()</code>.</p>
</div>
<div id="wal_recover_page" class="listingblock">
<div class="title"><code>wal.c</code> -  Recover a single page from the WAL to the <code>pages</code> hash table</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_recover_page(db_t *db, pages_map_t **pages,
    wal_txn_page_t *page, void *end, const void *src, void **input) {
  (void)db;
  (void)end;
  size_t size  = page-&gt;number_of_pages * PAGE_SIZE;
  page_t final = {.page_num = page-&gt;page_num,
      .number_of_pages      = page-&gt;number_of_pages};
  ensure(mem_alloc_page_aligned((void *)&amp;final.address, size));
  size_t done = 0;
  try_defer(free, final.address, done);
  memcpy(final.address, src + page-&gt;offset, size);
  ensure(pagesmap_put_new(pages, &amp;final));
  done = 1;
  *input += size;

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are passing more data to <code>wal_recover_page()</code> than we currently need. In particular, we are passing the end of the current page&#8217;s buffer to the function. It isn&#8217;t used
right now, but will be of great help in the next chpater.</p>
</div>
<div class="paragraph">
<p>Once we are done running through the valid transactions, we can complete the recovery and validate the recovered pages. For the purpose of validating the recovered pages, we use
the <code>recovered_pages</code> hash table we pass to <code>wal_recover_tx()</code>.  The idea behind  the <code>recovered_pages</code> is that we&#8217;ll use it as a hash <em>set</em> for all the page
numbers that were modified in all the transactions. In this case, we aren&#8217;t interested in the pages' values, only the page numbers. We use the <code>recovered_pages</code>
to validate that the pages we recovered are valid and that there are no issues with them. Let&#8217;s look how we get the next valid transaction in <a href="#wal_next_valid_transaction"><code>wal.c</code> - Getting the next transaction from the WAL, while ensuring that it is valid</a>.</p>
</div>
<div id="wal_next_valid_transaction" class="listingblock">
<div class="title"><code>wal.c</code> - Getting the next transaction from the WAL, while ensuring that it is valid</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_validate_transaction(reusable_buffer_t *buffer,
    void *start, void *end, wal_txn_t **tx_p) {
  (void)buffer;
  wal_txn_t *tx = start;
  if (!tx-&gt;tx_id || tx-&gt;page_aligned_tx_size + start &gt; end) {
    *tx_p = 0;
  } else {
    *tx_p = tx;
  }
  return success();
}
static result_t wal_next_valid_transaction(
    struct wal_recovery_operation *state, wal_txn_t **txp) {
  if (state-&gt;start &gt;= state-&gt;end ||
      !wal_validate_transaction(
          &amp;state-&gt;tmp_buffer, state-&gt;start, state-&gt;end, txp) ||
      !*txp || state-&gt;last_recovered_tx_id &gt;= (*txp)-&gt;tx_id) {
    *txp = 0;
  } else {
    state-&gt;last_recovered_tx_id = (*txp)-&gt;tx_id;
    state-&gt;start = state-&gt;start + (*txp)-&gt;page_aligned_tx_size;
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <a href="#wal_next_valid_transaction"><code>wal.c</code> - Getting the next transaction from the WAL, while ensuring that it is valid</a> is a bit complex at this point, because we have <code>wal_next_valid_transaction()</code> and <code>wal_validate_transaction()</code>.
It would actually be easier to merge them into a single function, but we&#8217;ll soon add more complex behavior to the WAL and there would be meaningful separation
between those two functions.</p>
</div>
<div class="paragraph">
<p>The stop condition for <code>wal_next_valid_transaction()</code> is interesting. Either we run through the entire WAL or we found a transaction whose id is lower than the current
transaction id. That would indicate to us that we are looking at old transactions. This can happen if we reset the file because we got to a checkpoint, which we&#8217;ll discuss shortly.
We are checking that the <code>tx_id</code> is not empty, but that is the sum total of the validation we do. We could use a marker value to verify that the value is a transaction, but that wouldn&#8217;t
give us much. If we want proper validation, we need to verify that <em>entire</em> transaction has been saved properly. In order to handle that, we&#8217;ll need to compute a hash and validate it.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Is this a toy implementation?</div>
<div class="paragraph">
<p>You might have noticed that I&#8217;m doing the minimum necessary to get things working here. Surprisingly enough, you can take this kind of implementation quite
far, in real world scenarios. However, we will patch in all the holes in the behavior in the next chapter. There are enough moving wheels in building a proper
storage engine that I would rather introduce something simple that works and then expand on it rather than try to show you the whole thing all at once.</p>
</div>
<div class="paragraph">
<p>The WAL we are showing here is a trivial implementation. There are quite a few things that I&#8217;m leaving unhandled. I wanted to make sure that I show
a fully functional system that you can easily reason about before we go and do anything more complex.</p>
</div>
<div class="paragraph">
<p>For example, we aren&#8217;t handling partial writes to the WAL. We assume that writes to the WAL are okay, which is <em>not</em> a safe assumption to make. We&#8217;ll
deal with that in the next chapter.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>With just this code, if we run the code in <a href="#data_loss"><code>test.c</code> - Losing committed writes because of a rude abort</a>, we&#8217;ll see that after the crash, the data from a committed transaction is properly back in the database.
Can we shout hurray now? Not quite yet, I&#8217;m afraid. We need to also consider a few other things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we recover, we&#8217;ll run through the entire WAL. If a page has been modified multiple times, we&#8217;ll write to it multiple times.</p>
</li>
<li>
<p>There is no mechanism to trim the size of the log, as it currently stands, transactions will grow the log without any bound.</p>
</li>
<li>
<p>In other words, the more transactions a database has, the more expensive it is to restart it. That is&#8230;&#8203; not a good position to be in.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The answer for that is to let the WAL know when we are saving the pages to the database. This is typically called a checkpoint.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checkpoints_and_wal_trimming">Checkpoints and WAL trimming</h3>
<div class="paragraph">
<p>A checkpoint notify the WAL that the data file has properly persisted (and made durable) the data in the WAL up to a certain point. That allows the WAL to trim itself
from transactions that are known to be in the data file already. That is the role of the <code>wal_checkpoint()</code> function, which is called from <code>txn_write_state_to_disk()</code>. When called, it
will check to see if the transaction that was saved to the data file is the last transaction in effect, which will allow us to reset the WAL location.</p>
</div>
<div class="paragraph">
<p>Before we get to the impact of checkpoints on the WAL, let&#8217;s see what this means for the data file itself. <a href="#txn_write_state_to_disk_08"><code>txn.c</code> - Flushing the file data when the WAL says that it is a good idea</a> shows the changes to <code>txn_write_state_to_disk()</code>
to support checkpoints.</p>
</div>
<div id="txn_write_state_to_disk_08" class="listingblock">
<div class="title"><code>txn.c</code> - Flushing the file data when the WAL says that it is a good idea</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_write_state_to_disk(txn_state_t *s) {
  size_t iter_state = 0;
  page_t *current;
  while (
      pagesmap_get_next(s-&gt;modified_pages, &amp;iter_state, &amp;current)) {
    ensure(pages_write(s-&gt;db, current));
  }
  // <b class="conum">(1)</b>
  if (wal_will_checkpoint(s-&gt;db, s-&gt;tx_id)) {
    ensure(pal_fsync(s-&gt;db-&gt;handle));
    ensure(wal_checkpoint(s-&gt;db, s-&gt;tx_id));
  }
  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New code here, if the WAL says that it is time to checkpoint, we&#8217;ll call <code>fsync()</code> on the data file and then tell the WAL to checkpoint.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is important to understand what is going on in <code>txn_write_state_to_disk()</code>, we write the data to the WAL on <code>txn_commit()</code>, and the <code>txn_write_state_to_disk()</code> will write the data to the data
when there are no active transactions looking at it. However, writing to the data file is done in a non durable mode. We write to the data file using buffered I/O, which means that we
are <em>not</em> guaranteed to have the data persisted on disk. It is only after we call to <code>fsync()</code> that we can rest assured that the data has been properly stored in persistent medium.</p>
</div>
<div class="paragraph">
<p>Once that happens, we can let the WAL know about it. At this point, any WAL data for the transaction that was just flushed to disk (and any earlier transactions) are no longer needed. We kept
them around to ensure that we can recover in the case of an error, but now we have verified that they are properly stored. That means that it is time to clean up the WAL.</p>
</div>
<div class="paragraph">
<p>The <code>fsync()</code> call is <strong>expensive</strong>, if you&#8217;ll recall. We don&#8217;t want to run it too often. That means that the WAL will need to tell us when it is a good idea to call to <code>fsync()</code>. You can see
how that is done in <a href="#wal_will_checkpoint"><code>wal.c</code> - Deciding when to call <code>fsync()</code> on the data file needs to consider safety concern vs. performance</a>.</p>
</div>
<div id="wal_will_checkpoint" class="listingblock">
<div class="title"><code>wal.c</code> - Deciding when to call <code>fsync()</code> on the data file needs to consider safety concern vs. performance</div>
<div class="content">
<pre class="highlight"><code>bool wal_will_checkpoint(db_state_t *db, uint64_t tx_id) {
  if (!db) return false;
  bool at_end = tx_id &gt;= db-&gt;wal_state.files[0].last_tx_id;
  return at_end;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we call <code>fsync()</code> too often, we put a lot of load on the I/O and can hurt our performance. If we don&#8217;t call it often enough, on restart, we&#8217;ll have to go over all the transactions that we
aren&#8217;t <em>sure</em> were properly persisted to durable media. That may increase the startup time of the database.</p>
</div>
<div class="paragraph">
<p>In <code>wal_will_checkpoint()</code> we use a simple rule, a checkpoint is only meaningful if the transaction in <code>txn_write_state_to_disk()</code> is the latest transaction in the WAL. Let&#8217;s dig into this issue.
The <code>txn_write_state_to_disk()</code> is going to run on a transaction that is guaranteed to have no one looking at it. In practice, that means that we can run a checkpoint whenever there are no active
transactions at all. Why is that required?</p>
</div>
<div class="paragraph">
<p>If the transaction that was just written to disk is the same as the most recent one it means that the entire WAL file has been made redundant. Let&#8217;s see how we actually handle the checkpoint process
in <a href="#wal_checkpoint"><code>wal.c</code> - Discarding the WAL file that is no longer required</a>.</p>
</div>
<div id="wal_checkpoint" class="listingblock">
<div class="title"><code>wal.c</code> - Discarding the WAL file that is no longer required</div>
<div class="content">
<pre class="highlight"><code>static result_t wal_reset_file(
    db_state_t *db, wal_file_state_t *file) {
  (void)db;
  void *zero;
  ensure(mem_alloc_page_aligned(&amp;zero, PAGE_SIZE));
  defer(free, zero);
  memset(zero, 0, PAGE_SIZE);
  // reset the start of the log, preventing recovery from proceeding
  ensure(pal_write_file(file-&gt;handle, 0, zero, PAGE_SIZE),
      msg("Unable to reset WAL first page"));
  file-&gt;last_write_pos = 0;
  return success();
}

result_t wal_checkpoint(db_state_t *db, uint64_t tx_id) {
  (void)tx_id;
  ensure(wal_reset_file(db, &amp;db-&gt;wal_state.files[0]));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The WAL checkpoint process is actually really simple. We write a page of zeros to the start of the file, and set the <code>last_write_pos</code> to the start of the file, that is all.
What does <em>that</em> do? Let&#8217;s consider the implications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If we restart now, the first page will be zeroed and no recovery will be performed. The zero page will not pass <code>wal_validate_transaction()</code> and will stop the iteration on the WAL.</p>
</li>
<li>
<p>If we write another transaction, it will be written to the start of the WAL file. We&#8217;ll then read that transaction and then try to read the next.
The next transaction would either have lower id than the previous one (causing us to stop) or we&#8217;ll read into the middle of an old transaction, which will also
cause us to stop. In the later case (reading into the middle of an old transaction) we may get unlucky and think that this is a valid transaction, we&#8217;ll fix that in the next chapter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Either way, by overwriting the first page we have trimmed the recovery to only transactions that happened <em>after</em> the checkpoint, exactly what we wanted
to happen. Admittedly, in this case there are <em>no</em> transactions after the checkpoint at the time we actually checkpoint, but we need to take baby steps to get to end without getting
tangled with too many details at once.</p>
</div>
</div>
<div class="sect2">
<h3 id="_durability_concerns">Durability concerns</h3>
<div class="paragraph">
<p>We now have a WAL that help ensure that our commit isn&#8217;t lost, surely that is all we need, right? Almost. We still need to make sure that the following
things will happen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we write to the WAL, the wal file is <em>durable</em>.</p>
</li>
<li>
<p>When we checkpoint, the <em>data file</em> will be durable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s try to address these in order. We currently write to the WAL using buffered I/O. If the system suffer a power loss or a crash, our changes will <em>not</em>
be preserved. We need to ensure that the WAL writes will actually hit the disk. That turns out to be a rather hard thing to do. Disk I/O is <em>slow</em> and there
are multiple caches in the middle that are design to shield us from the reality of having to wait for the hardware.</p>
</div>
<div class="paragraph">
<p>One way to ensure that the data will hit the disk after the write is to use <code>fsync()</code> after each call to <code>write()</code>. That will ensure that data actually hits
the disk, right? This is also <em>atrociously</em> slow. The <a href="https://www.percona.com/blog/2018/02/08/fsync-performance-storage-devices/">blog post from Percona</a>
have some interesting numbers on the topic. A dozen years or so ago there was a huge furor
<a href="http://shaver.off.net/diary/2008/05/25/fsyncers-and-curveballs/">around <code>fsync()</code> after FireFox started to use this excessively</a>.</p>
</div>
<div class="paragraph">
<p>The story is quite interesting and touch on of the key issues with <code>fsync()</code>, it is a Big Hammer approach. It tells the file system and the disk to flush
the writes to the physical medium. However, even though <code>fsync()</code> is called with a file descriptor, what actually happens is that the <em>entire</em> drive cache
is flushed. In some cases, that may mean <em>seconds</em> of wait for the operation to complete. That is&#8230;&#8203; not ideal.</p>
</div>
<div class="paragraph">
<p>There are some way around it. the <code>fdatasync()</code> is much better, it flushes the <em>data</em> of the file, not the metadata. Remember how careful we were about
the file size? That is part of the reason why it is important. It saves us significant amount of time on an ongoing basis.
The <code>fdatasync()</code> call is still expensive, but pretty much <em>all</em> the calls that touch the real hardware are going to be slow. In the Percona post they
tested <em>NVMe</em> drives have meaningful latency for <code>fsync()</code> and <code>fdatasync()</code>.</p>
</div>
<div class="paragraph">
<p>The key issue is that we need to flush the drive buffers. First we write to the file, which does buffered I/O and then we flush it using <code>fdatasync()</code>.
These buffers may have already been flushed down to the drive / disk level, where the association to the actual file is lost. We now need to just issue
a "flush it all", which is expensive.</p>
</div>
<div class="paragraph">
<p>We can do better by bypassing the buffered mode entirely. If we could tell the operating system that we want to send the data directly to disk, that would
save the need to flush the entire cache. It turns out that there is a way to do so, when we open the file, we can mark is using <code>O_DIRECT | O_DSYNC</code>. That
would do just that, as far as the operating system is concerned. On Windows, we&#8217;ll need to use <code>FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH</code> in order
to get the same behavior.</p>
</div>
<div class="paragraph">
<p>Enabling those flags impose certain alignment requirements on the writes you can make. All you operations must be 4KB aligned. This is because using these
flags, you are using DMA (Direct Memory Transfer), so the write needs to be page aligned. The <code>O_DSYNC</code> or <code>FILE_FLAG_WRITE_THROUGH</code> will tell the system
to send a FUA (Force Unit Access) flag to the disk. This tells the disk that it needs to put the data on persistent medium. That applies to a particular
write and saves us from flushing caches. Note that you need <em>both</em> flags for the desired behavior, either one of them on its own will not get you the
right result. There are scenarios where using one of those flags independently is good, but not for our needs.</p>
</div>
<div class="paragraph">
<p>The issue of durable writes is <em>complex</em> and there are a lot of material about it.
The <a href="https://bobsql.com/sql-server-on-linux-forced-unit-access-fua-internals/">SQL Server On Linux: Forced Unit Access (Fua) Internals</a> post talks about this
extensively and can give you some idea about the challenges involved in making sure that data is properly durable.
The LWN article about <a href="https://lwn.net/Articles/457667/">Ensuring data reaches disk</a> is also a good read that is worth pursuing.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The design of the WAL and the hidden benefits</div>
<div class="paragraph">
<p>A <em>lot</em> of thought has gone into the design of the WAL. I know that it doesn&#8217;t <em>looks</em> like it, right now the whole WAL code is under a few hundreds lines of code, but
it was setup in such a way that we have major benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The WAL pre-allocates the file size. Which means that we will have reduce file fragmentation and likely have more sequential disk space allocated to us.</p>
</li>
<li>
<p>Not needing to modify the file size means that we can use data sync, not full sync, reducing the I/O costs substantively.</p>
</li>
<li>
<p>All writes are done on page boundary and are sequential in nature. That is the <em>best</em> way to get speed from the hardware.</p>
</li>
<li>
<p>There are no reads or any random I/O during normal operations and a simple sequential scan when recovery is running.</p>
</li>
<li>
<p>We are writing to the data file using buffered I/O as soon as we can, but calling <code>fsync()</code> only when the last transaction in the WAL has been committed.
That gives the file system <em>time</em>. Time to do background writes to disk so when we call <code>fsync()</code>, we won&#8217;t have a huge pile of data that needs to be sent
all at once. It isn&#8217;t a <em>massive</em> performance boost, but every little bit helps.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;ll look at <a href="#wal_open_single_file"><code>wal.c</code> - Opening a WAL file</a> you can see that I actually had a bit of foreshadowing. In <a href="#wal_open_single_file"><code>wal.c</code> - Opening a WAL file</a> we pass <code>pal_file_creation_flags_durable</code>
to <code>pal_create_file()</code>. When we send this flag to <code>pal_create_file()</code>, we will call <code>open()</code> on the file with <code>O_DIRECT | O_DSYNC</code> (I mentioned that we&#8217;ll talk about these flags
later when we looked into this function in chapter 3, now is that later). That means that writes to the WAL
<em>must</em> be aligned on 4KB boundary and the buffer we pass to <code>write()</code> should also be 4KB aligned in memory. The idea is that the <code>write()</code> will basically hand the buffer
we gave it directly to the disk drive and flag the write with the FUA flag (instructing the drive to bypass any cache and write to persistent medium).</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">Do you trust the hardware?</div>
<div class="paragraph">
<p>The fact that we sent the FUA flag to the disk doesn&#8217;t mean that it has to respect that. Some drives will ignore the FUA request because they are designed to run with
independent power source and will have time to flush any cache they have in the case of a failure. But some cheap consumer drives simply don&#8217;t implement this flag at all.</p>
</div>
<div class="paragraph">
<p>In such a case, there is usually no indication that the drive didn&#8217;t respect our wishes and no way to ensure durability of the data. That isn&#8217;t unique to Gavran, such
drives would render any database suspect, because it violate the invariants that we rely on. Most of the drives in the market today will respect the FUA flag and <em>any</em>
enterprise grade disk will handle that properly.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What is <em>actually</em> going on in this scenario is a bit more complex, but that is the key for ensuring that a write like that will be durable. Note that because we are sending
the write marked from the start as one that should be made durable, there is no flushing required of the the cache, we simply bypass these as we go through the layers of the
operating system, file system, disk driver and the disk controller itself.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Handling partial writes</div>
<div class="paragraph">
<p>We have durable writes to the WAL file, which ensure that our transaction data will be safe. That still isn&#8217;t enough. What happens if we crash midway
through writing a transaction? Since the call didn&#8217;t complete, we have no guarantees what will actually be on the device. We need to have insurance from
partial writes.</p>
</div>
<div class="paragraph">
<p>This time, there are no flags that we can set, we have to use our initiative and write some code to ensure everything will work. The way to <em>handle</em> that
is to run a hash on the data and then validate the result during recovery. Good options for hashing are either <code>xxHash64</code> or <code>BLAKE2b</code> hash. The major
difference between the two is that the first is non cryptographic hash while the <code>BLAKE2b</code> is a cryptographic hash.
The <code>xxHash64</code> produce an 8 bytes (64 bits) value while the <code>Blake2B</code> produce a 32 bytes (256 bits) value.</p>
</div>
<div class="paragraph">
<p>A cryptographic hash has a number of <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">required properties</a>, which boil down to what you think
is your threat vector. If you are concerned about the missing data or disk corruption, you can probably suffice with CRC or something similar, although
CRC is actually <em>slower</em> than <code>xxHash64</code>. The <code>xxHash64</code> is a fast algorithm, in the order of 10GB / sec and gives good indication that the data was modified.
The <code>BLAKE2b</code> function is also fast, but only in the company of other cryptographic hashes. It gets to 0.95 GB / sec, significantly slower that <code>xxHash64</code>.
The advantage is that you can safely assume that no one is going to be <em>able</em> to manufacture collisions for your data.</p>
</div>
<div class="paragraph">
<p>I&#8217;m just going to use <code>BLAKE2b</code> for now, unless I get a benchmark that change my mind. The fact that we are going to be doing durable writes to disk means that
the cost of I/O is likely <em>many</em> times higher than the hashing cost, after all. I&#8217;ll defer implementing hashing to the next chapter, however.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>A good tool to use is <code>strace</code>, which can tell you what system call are generated by a process. That is very useful when trying to understand what
your code is <em>actually</em> doing, rather than what you <em>think</em> it is doing. Looking into how Gavran is dealing with the disk can be quite interesting.
Running one the <code>"closing db with no active txs requires no recovery"</code> test shown in <a href="#test_08"><code>test.c</code> - Unit testing WAL behavior</a> with
<code>strace -e trace=mmap,openat,open,close,munmap,pwrite64,fsync,fdatasync,ftruncate</code>
gives us the following shown in <a href="#strace_output_db_open">The <code>strace</code> showing the system calls when opening a database for the first time</a> and <a href="#strace_output_tx">The <code>strace</code> showing the system calls for a single transaction</a>.</p>
</div>
<div class="paragraph">
<p>Just the act of opening the database requires quite a bit of work, as you can see in <a href="#strace_output_db_open">The <code>strace</code> showing the system calls when opening a database for the first time</a>.</p>
</div>
<div id="strace_output_db_open" class="listingblock">
<div class="title">The <code>strace</code> showing the system calls when opening a database for the first time</div>
<div class="content">
<pre class="highlight"><code>openat(AT_FDCWD, "/tmp/db/try", O_RDWR|O_CREAT|O_CLOEXEC, 0600) = 3
close(3)                                = 0
openat(AT_FDCWD, "/tmp/db/try", O_RDWR|O_CREAT|O_CLOEXEC, 0600) = 3
openat(AT_FDCWD, "/tmp/db", O_RDONLY)   = 4
fsync(4)                                = 0
close(4)                                = 0
ftruncate(3, 4194304)                   = 0
openat(AT_FDCWD, "/tmp/db", O_RDONLY)   = 4
fsync(4)                                = 0
close(4)                                = 0
mmap(NULL, 4194304, PROT_READ, MAP_SHARED, 3, 0) = 0x7f2b42ee0000
openat(AT_FDCWD, "/tmp/db/try-a.wal",
                  O_RDWR|O_CREAT|O_CLOEXEC, 0600) = 4
close(4)                                = 0
openat(AT_FDCWD, "/tmp/db/try-a.wal",
                  O_RDWR|O_CREAT|O_DSYNC|O_DIRECT|O_CLOEXEC, 0600) = 4
openat(AT_FDCWD, "/tmp/db", O_RDONLY)   = 5
fsync(5)                                = 0
close(5)                                = 0
ftruncate(4, 131072)                    = 0
openat(AT_FDCWD, "/tmp/db", O_RDONLY)   = 5
fsync(5)                                = 0
close(5)                                = 0
mmap(NULL, 131072, PROT_READ, MAP_SHARED, 4, 0) = 0x7f2b44cb0000
munmap(0x7f2b44cb0000, 131072)          = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see in <a href="#strace_output_db_open">The <code>strace</code> showing the system calls when opening a database for the first time</a> that we are opening and closing the data file and the WAL a few times. This happens becuase <code>pal_create_file()</code> will
call to <code>pal_ensure_path()</code> which will try to create the file to verify that it is possible for us to so, then call <code>fsync()</code> on the parent directory
if the file didn&#8217;t previous exist. We will also call <code>fsync()</code> after we set the size of the files using <code>ftruncate()</code>. Technically speaking, we could have done
all of the work and then call <code>fsync()</code> on the directory once, but given how rare this even is (opening a new database), it isn&#8217;t worth it.</p>
</div>
<div class="paragraph">
<p>You can also see in <a href="#strace_output_db_open">The <code>strace</code> showing the system calls when opening a database for the first time</a> that we are opening the WAL with <code>O_DSYNC|O_DIRECT</code> and that we <code>mmap()</code> it and then <code>unmap()</code> it. This is when
we run recovery on the empty database. On <a href="#strace_output_tx">The <code>strace</code> showing the system calls for a single transaction</a> you can see how a transaction looks like, in terms of system calls.</p>
</div>
<div id="strace_output_tx" class="listingblock">
<div class="title">The <code>strace</code> showing the system calls for a single transaction</div>
<div class="content">
<pre class="highlight"><code>pwrite64(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 24576, 0) = 24576
pwrite64(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 0) = 8192
pwrite64(3, "\3\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 8192) = 8192
fdatasync(3)                            = 0
pwrite64(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 0) = 8192</code></pre>
</div>
</div>
<div class="paragraph">
<p>There isn&#8217;t much in <a href="#strace_output_tx">The <code>strace</code> showing the system calls for a single transaction</a>, because from the operating system perspective, we aren&#8217;t doing much. There is one write to the WAL (fd: 4), the first
call on <a href="#strace_output_tx">The <code>strace</code> showing the system calls for a single transaction</a>. This is a durable write because the WAL was opened with <code>O_DSYNC|O_DIRECT</code>. Then there are two writes to the data file (fd: 3) to
pages 0 and 1, writing the actual data to the relevant pages. The transaction in <a href="#strace_output_tx">The <code>strace</code> showing the system calls for a single transaction</a> is writing to the data file because there are no other
active transactions to prevent it. This is also the transaction that happens in <code>db_init_file_structure()</code>. Finally, you can see that we flush the data to disk
and then reset the WAL by writing a page full of zeros at the start.</p>
</div>
<div class="paragraph">
<p>On <a href="#strace_2nd_txs">The <code>strace</code> output from the calls two calls to <code>write_to_page()</code> and the resetting of the WAL</a> we can see the system calls as a result of two separate transactions, modifying page 3.</p>
</div>
<div id="strace_2nd_txs" class="listingblock">
<div class="title">The <code>strace</code> output from the calls two calls to <code>write_to_page()</code> and the resetting of the WAL</div>
<div class="content">
<pre class="highlight"><code>// <b class="conum">(1)</b>
pwrite64(4, "\0\0\0\0\0\0\0\0\0\00\0\0\0\0"..., 24576, 0) = 24576
pwrite64(3, "\0\0\0\0\0\0\0\0\0\00\0\0\0\0"..., 8192, 0) = 8192
pwrite64(3, "Hi there\0\0\0\0\0\00"..., 8192, 24576) = 8192
// <b class="conum">(2)</b>
fdatasync(3)                            = 0
pwrite64(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 0) = 8192
// <b class="conum">(3)</b>
pwrite64(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 24576, 0) = 24576
pwrite64(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 0) = 8192
pwrite64(3, "2nd Try!\0\0\0\0\0\0"..., 8192, 24576) = 8192
// <b class="conum">(4)</b>
fdatasync(3)                            = 0
pwrite64(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 8192, 0) = 8192</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The system calls from the <code>write_to_page("Hi There")</code> call.</p>
</li>
<li>
<p>Resetting the WAL</p>
</li>
<li>
<p>The system calls from the <code>write_to_page("2nd Try!")</code> call.</p>
</li>
<li>
<p>Resetting of the WAL file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Finally, we can see how we close the database and reopen it in <a href="#strace_close_reopen">The <code>strace</code> output from closing and reopening the database with no transactions in the WAL</a>. You can see that there are no writes made to the data file
as part of the database recovery on startup, because we reset the WAL on <a href="#strace_2nd_txs">The <code>strace</code> output from the calls two calls to <code>write_to_page()</code> and the resetting of the WAL</a> and there is no need of that.</p>
</div>
<div id="strace_close_reopen" class="listingblock">
<div class="title">The <code>strace</code> output from closing and reopening the database with no transactions in the WAL</div>
<div class="content">
<pre class="highlight"><code>munmap(0x7f2b42ee0000, 4194304)         = 0
close(3)                                = 0
close(4)                                = 0
openat(AT_FDCWD, "/tmp/db/try", O_RDWR|O_CREAT|O_CLOEXEC, 0600) = 3
mmap(NULL, 4194304, PROT_READ, MAP_SHARED, 3, 0) = 0x7f2b42ee0000
openat(AT_FDCWD, "/tmp/db/try-a.wal",
              O_RDWR|O_CREAT|O_DSYNC|O_DIRECT|O_CLOEXEC, 0600) = 4
mmap(NULL, 131072, PROT_READ, MAP_SHARED, 4, 0) = 0x7f2b44cb0000
munmap(0x7f2b44cb0000, 131072)          = 0
munmap(0x7f2b42ee0000, 4194304)         = 0
close(3)                                = 0
close(4)                                = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might want to run <code>strace</code> on other tests and try to figure out what is going on in Gavran just from the system calls. That can be very helpful,
because it gives you a very different perspective of the way things work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit Tests</h3>
<div class="paragraph">
<p>This chapter has just a few unit tests, showing what happens when we close the database with an outstanding read transaction. That transaction
prevent us from writing to the data file, so we need to run recovery to get the data from the committed transactions.
We also have a test to check that the checkpoint process works and we don&#8217;t do any recovery after a checkpoint.</p>
</div>
<div class="paragraph">
<p>Testing the storage layer in this manner test to be hard, we&#8217;ll be doing a lot more with that using ALICE toward the end of the book, to make
sure that we are <em>properly</em> using the system and not leaving ourselves open to some rare alignment of the stars.</p>
</div>
<div class="paragraph">
<p>You can see the tests in <a href="#test_08"><code>test.c</code> - Unit testing WAL behavior</a>.</p>
</div>
<div id="test_08" class="listingblock">
<div class="title"><code>test.c</code> - Unit testing WAL behavior</div>
<div class="content">
<pre class="highlight"><code>describe(durability_tests) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("closing files does not commit pending transactions") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    txn_t rtx;
    assert(txn_create(&amp;db, TX_READ, &amp;rtx));
    assert(
        write_to_page(&amp;db, "Hello Gavran", strlen("Hello Gavran")));
    assert(db_close(&amp;db));

    // let's mmap the data file and check it all
    file_handle_t* handle;
    assert(pal_create_file("/tmp/db/try", &amp;handle,
                           pal_file_creation_flags_none));
    span_t span = {.size = options.minimum_size};
    assert(pal_mmap(handle, 0, &amp;span));
    defer(pal_unmap, span);
    defer(pal_close_file, handle);

    const char* needle = "Hello Gavran";
    void* found =
        memmem(span.address, span.size, needle, strlen(needle));
    assert(found == 0);
  }

  it("on reopen will recover committed transactions") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    txn_t rtx;
    assert(txn_create(&amp;db, TX_READ, &amp;rtx));
    assert(
        write_to_page(&amp;db, "Hello Gavran", strlen("Hello Gavran")));
    assert(db_close(&amp;db));

    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    // now verify that the data is back after recovery
    assert(txn_create(&amp;db, TX_READ, &amp;rtx));
    page_t p = {.page_num = 3};
    assert(txn_raw_get_page(&amp;rtx, &amp;p));
    assert(strcmp("Hello Gavran", p.address) == 0);
  }

  it("closing db with no active txs requires no recovery") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1024 * 1024,
                            .wal_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    // need to write multiple times to hit 50% WAL
    for (size_t i = 0; i &lt; 4; i++) {
      char rand[PAGE_SIZE];
      randombytes_buf(rand, PAGE_SIZE);
      assert(write_to_page(&amp;db, rand, PAGE_SIZE));
    }
    assert(db.state-&gt;wal_state.files[0].last_write_pos == 0);
    assert(db_close(&amp;db));

    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);
    assert(db.state-&gt;wal_state.files[0].last_write_pos == 0);
    assert(db.state-&gt;wal_state.files[0].last_tx_id == 0);
  }

  it("should avoid data loss after failure") {
    assert(data_loss("/tmp/db/try"));
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
  <ul style="list-style-type: none;">
    <li><a class="footer-text" href="../index.html">Table of contents</a></li>
    <li><a class="footer-text" href="./ch07.html">Previous chapter</a></li>
    <li><a class="footer-text" href="./ch09.html">Next chapter</a></li>
  </ul>
</div>
</body>
</html>