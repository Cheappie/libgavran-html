<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Page management</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_page_management">Page management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We now have a system that is capable of allocating disk space inside a file, work with individual pages and allocate and free pages dynamically.
There is a minor issue, the most that we can use is a single page at a time. That works if everything that we need to work with is 8KB or less,
but isn&#8217;t really a viable option to go on with.</p>
</div>
<div class="paragraph">
<p>We need to introduce the notion of an <em>overflow</em> page. This refers to a value that must reside on multiple pages (so it overflows the page boundary).
In <a href="#overflow_problem">Trying to set a value greater than 8Kb on a page</a> you can see what we want to achieve using the current code. As you can see, it is badly broken.</p>
</div>
<div id="overflow_problem" class="listingblock">
<div class="title">Trying to set a value greater than 8Kb on a page</div>
<div class="content">
<pre class="highlight"><code>txn_t tx;
ensure(tx_create(&amp;db, 0, &amp;tx));
defer(tx_close, &amp;tx);
page_t page = {0};
ensure(txn_allocate_page(&amp;tx, &amp;page));

// will write beyond the boundary of the page!!!
memcpy(page.address, buffer, 12 * 1024);

ensure(tx_commit(&amp;tx));
ensure(tx_close(&amp;tx));

ensure(tx_create(&amp;db, 0, &amp;tx));
ensure(txn_raw_get_page(&amp;tx, &amp;page));

char new_buf[ 12 * 1024];
// Again, reads past end of buffer
memcpy(new_buf, page.address, 12 * 1024);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The issue is that we are allocating a single page at a time, which won&#8217;t work. And worse, when we try to <em>read</em>, the <code>txn_raw_get_page()</code> will give us a single page because
it doesn&#8217;t understand that you can <em>have</em> multi pages in a single run. Right now, in order to handle this properly we&#8217;ll need to allocate two pages and do separate writes
and reads to get it. It seems obvious that we need to provide a mechanism at the database level to manage values that cross more than a single page. The way we&#8217;ll do that
is to allow to allocate pages in a group. So you can ask for a page, or three pages, etc.</p>
</div>
<div class="paragraph">
<p>In order to support this, we will use the <code>page_t</code> structure to pass the <code>number_of_pages</code> of the value that we intend to put in the page. We use a <code>uint64_t</code> here,
so the maximum size of a single value is effectively infinite. Note that we are passing the number of <em>pages</em> that we want. If we want to deal with values, which may be
of arbitrary size, we&#8217;ll need to store that somewhere. We&#8217;ll see exactly where we can <em>keep</em> this value this this chapter.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Value vs. page</div>
<div class="paragraph">
<p>I&#8217;m using two different terms here that may be confusing. A page (rather, pages) that form a consecutive set of pages that are managed as a single
unit by Gavran. The value I refer to here is the <em>user provided</em> value, which does not need to fit on a page boundary. If I want to persist a value
that is 10,000 bytes in size, I&#8217;ll need to use two pages for that.</p>
</div>
<div class="paragraph">
<p>When I&#8217;m reading it back using <code>txn_raw_get_page()</code>, we&#8217;ll read those two pages, but we need to provide the caller with the size of the that was previous stored
in those pages. When we use <code>txn_raw_modify_page()</code>, we must ensure that our copy covers both pages. That doesn&#8217;t sounds very "raw" to me though.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The actual issue is pretty simple, where are we going to put the size of the actual value we want to keep? (Those  10,000 bytes I mentioned earlier).
We need to put it <em>somewhere</em>, but we have no room for it. This isn&#8217;t information that goes into the page, it is information <em>about</em> the page. Where would it go?</p>
</div>
<div class="sect2">
<h3 id="_placement_of_pages_metadata">Placement of pages metadata</h3>
<div class="paragraph">
<p>The typical location for metadata information about a page in a header inside the page. The storage engine will reserve the first few bytes of a page to itself for its
own book keeping purposes. You can see how this looks in <a href="#page-common">A page with inlined metadata in the header</a>. This is how it works for LMDB and Voron, for example, among many others.</p>
</div>
<div id="page-common" class="imageblock">
<div class="content">
<img src="../imgs/page-common.png" alt="page common">
</div>
<div class="title">Figure 1. A page with inlined metadata in the header</div>
</div>
<div class="paragraph">
<p>Keeping the metadata in the page header has a number of useful properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keeping the metadata in page header is simple to explain and implement.</p>
</li>
<li>
<p>There is great locality of reference for the metadata.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also have an annoying downside, it means that you don&#8217;t actually have the full page available for the user. In Voron, the header size is 64 bytes and LMDB has a 16
bytes header. As you can see in  <a href="#page-common">A page with inlined metadata in the header</a>, that means that you are left with 8,128 bytes to work with in a page with Voron and 8,176 bytes in LMDB. That isn&#8217;t bad, per
se, but it does have a <em>very</em> important implication. The size of a value is <strong>never</strong> going to be a power of two if you are using page headers.</p>
</div>
<div class="paragraph">
<p>Consider how we&#8217;ll need to implement the free space bitmaps in the presence of page headers. It will make things much harder. Not <em>too</em> hard, admittedly, but this is a
very simple case. There are several data structures which assume that the data is going to be based on a power of 2. Two such examples are
<a href="https://roaringbitmap.org/">Roaring Bitmaps</a> and Extendible Hashing, both of which
are natural candidates for use in a storage engine.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Extensible hashing paper</div>
<div class="paragraph">
<p>The <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.93.4829&amp;rep=rep1&amp;type=pdf">Extendible Hashing</a> is from 1979 and is a joy to read. I highly recommend
going through it. There is also the Linear Hashing algorithm, from the same time period, but I found it to be both more complex and less approachable, with no
real redeeming features.</p>
</div>
<div class="paragraph">
<p>A <a href="https://shareok.org/bitstream/handle/11244/14203/Thesis-1989-R234p.pdf?sequence=1">performance comparison</a> of the two found that Extensible Hashing uses less
space but might be slower if the directory (a key element in the algorithm) cannot be kept in memory. That analysis in from 1990 and the code was run on a
<a href="http://www.1000bit.it/ad/bro/perkin/PerkinElmer-3230.pdf">Perkin-Elmer 3230</a> machine. That used to cost over 100,000 USD in 1980s dollars
(about 285,000 USD in today&#8217;s dollars). You can buy that machine (if you went all out) with a whopping 8 MB of RAM.</p>
</div>
<div class="paragraph">
<p>Even under <em>those</em> conditions, linear hashing was recommended only if you have memory pressure. I think that memory pressure in this context is no longer relevant
and you should always go with Extendible Hashing. We&#8217;ll be implementing the algorithm later in this book.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>I also want to create proper layering in the system. We have now a page based storage system that can manage, allocate and free pages, and we don&#8217;t have any constraint
on what is going on. That is a very desirable property in my opinion. So I want to avoid a page header.</p>
</div>
<div class="paragraph">
<p>If the page metadata isn&#8217;t on the page, where are we going to place it? Let&#8217;s assume that we need to keep 16 bytes of metadata per page. The obvious solution is to
go with the same route we did with the free space bitmap. We&#8217;ll put the pages metadata in the pages themselves. A look at <a href="#pages-recursive">Dedicated pages metadata page contain metadata for all pages, including themselves, the free space bitmap and the header</a> might help makes things clearer.</p>
</div>
<div class="paragraph">
<p>Assuming that we have 64 bytes of metadata per page, that means that we can fit 128 pages metadata in an 8Kb page. In other words, we use one 8Kb metadata page
for every MB of disk space we use. And each GB of disk space will require 2MB of metadata. Note that we were going to need to make use of this space <em>anyway</em>,
by the way. The issue is whatever this is internal use in a page or external with dedicated space.</p>
</div>
<div id="pages-recursive" class="imageblock">
<div class="content">
<img src="../imgs/pages-recursive.png" alt="pages recursive">
</div>
<div class="title">Figure 2. Dedicated pages metadata page contain metadata for all pages, including themselves, the free space bitmap and the header</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Using 64 bytes for page metadata</div>
<div class="paragraph">
<p>It is entirely possible to get away with using merely 16 bytes as the page header, which would allow us to pack 512 metadata entries into a single 8KB page.
Why go with 64 bytes, then?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remember the <code>crypto</code> field in the <code>page_metadata_t</code> structure, that alone takes 32 bytes. That is required to handle encryption of pages as well as store
cryptographic hash of the page. These will both be discussed at length on Chapter 11.</p>
</li>
<li>
<p>Having more space in the header (64 - 32 = 32 bytes) gives us a lot of options with regards to manage data about the pages. And given the fact that we are
already are greater than 32 bytes, we might as well go to 64 bits as the next logical stop.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In <a href="#pages-recursive">Dedicated pages metadata page contain metadata for all pages, including themselves, the free space bitmap and the header</a>, we place the metadata of the 3rd page in the file. That is easy to do and works well with the code that we have so far. However, that approach contains
an important flaw. What happens when the data file grows too large to fit all the metadata values in a single page. That isn&#8217;t a far off concern. It will happen as
soon as the file exceeds the 1MB mark.</p>
</div>
<div class="paragraph">
<p>With the free space bitmap, I didn&#8217;t concern myself with worrying about this. A 512GB file will use a total of 8Mb, so if we run out of space for the bitmap up,
the cost of moving the bitmap to another location is negligible. With the pages metadata, on the situation is different. A 512GB file will use 1Gb of disk space to
hold the metadata for the entire file. At that size, moving it when needed is&#8230;&#8203; prohibitive.</p>
</div>
<div class="paragraph">
<p>There are other issues that we have to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Placing all the pages metadata in one location means that a disk corruption in the pages metadata section will have a chance of impacting a <em>lot</em> of data at once.</p>
</li>
<li>
<p>We <em>must</em> be able to access a particular page&#8217;s metadata in O(1) access time. That is, we cannot afford to do any sort of search. In the same way that accessing
a page is done using pointer arithmetic and jumping directly to the memory mapped location, we need to have the same behavior for the pages metadata.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A good solution would be to place a metadata page at the start of each megabyte of disk space. That will give us a constant computation to figure out where a particular
page&#8217;s metadata is.  It will also ensure that a single bad block in the disk will not have a disastrous impact on the entire data file. However, if we choose this method,
we&#8217;ll run into  other issues. Let&#8217;s take a look at <a href="#pages-one-mb">Placing a metadata page at the start of each MB in the file</a> to see what would happen then.</p>
</div>
<div id="pages-one-mb" class="imageblock">
<div class="content">
<img src="../imgs/pages-one-mb.png" alt="pages one mb">
</div>
<div class="title">Figure 3. Placing a metadata page at the start of each MB in the file</div>
</div>
<div class="paragraph">
<p>Looking at <a href="#pages-one-mb">Placing a metadata page at the start of each MB in the file</a>, can you see what is the problem with this approach? There are a few. If you&#8217;ll compare to  <a href="#pages-recursive">Dedicated pages metadata page contain metadata for all pages, including themselves, the free space bitmap and the header</a>, you&#8217;ll note that we lost the header
page. It used to be located in the first page, but that is now a metadata page. We&#8217;ll need to figure that issue out, but before we come to the solutions, let&#8217;s
talk about the other issue.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dealing_with_large_values">Dealing with large values</h3>
<div class="paragraph">
<p>What if we want to do an allocation that is 1MB in size (or longer)? We <em>have</em> the free space for it. We just don&#8217;t have a continuous range of it. It would probably be
safe to accept this limitation. Having 1MB (actually, 1,016KB to be exact) max size limit for a single value isn&#8217;t typically a concern.
Even if you want to store large values, it usually make sense to break them to manageable pieces first. That said, I&#8217;m not happy with this approach.</p>
</div>
<div class="paragraph">
<p>If the value was limited to 4GB, I would be willing to accept this as a limit. That is big enough to either not care
ever about this limit (most cases) or knowing that you&#8217;ll have values in the tens / hundreds of GB (typically videos). At this point, you&#8217;re not going to be dealing
with the full data size anyway, so you can place it in multiple chunks.</p>
</div>
<div class="paragraph">
<p>That is actually a very important factor. It is rare to need to deal with a single buffer that is multiple GB in size. But we deal with multi megabytes buffers every
day. I just checked my phone and the last image I took and it was 2.5MB, I took a screen shot and it was over 1MB. Placing a limit as low as 1MB is not sustainable.
On the other hand, if we want users to be able to allocate 4GB of continuous space, the metadata pages needs to be at least 8Gb apart.</p>
</div>
<div class="paragraph">
<p>I started to go with that route, but it got a bit complex, too soon for my taste. Another advantage of having the pages metadata placed on every MB is that
it helps avoid an issue with a single disk location becoming corrupted and impacting the whole system. There is also greater data locality, which is
always desirable. We just need to be able to handle values that are larger than 1MB. How can we do that?</p>
</div>
<div class="paragraph">
<p>The solution is straightforward, we only need a page metadata if there are actually pages in range. If there aren&#8217;t any pages in that range
(because that entire range is used for values), we can re-purpose that space and use it for data. <a href="#pages-final">Allocating a value that is greater than 1 MB will span metadata locations and extend to the next full MB</a> shows how this will look like in practice.</p>
</div>
<div id="pages-final" class="imageblock">
<div class="content">
<img src="../imgs/pages-final.png" alt="pages final">
</div>
<div class="title">Figure 4. Allocating a value that is greater than 1 MB will span metadata locations and extend to the next full MB</div>
</div>
<div class="paragraph">
<p>You can see in <a href="#pages-final">Allocating a value that is greater than 1 MB will span metadata locations and extend to the next full MB</a> that we asked to allocate a value that requires 268 pages, but given the structure of the file at that time, we find an available
range for this request and place the end of the allocation on a 128 page boundary (1 MB), then take the space <em>backward</em>.
The idea is that we want to tie up as little extra space as possible. By moving the large allocation so it ends on a metadata page boundary, we ensure that
this is the case.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The location of the file header</div>
<div class="paragraph">
<p>In the previous chapter, we placed the file header in the first page. Now, that first page is the metadata page for the first MB in the data. What do we do
with the file header?</p>
</div>
<div class="paragraph">
<p>The answer is that we are going to keep it in just the same place. The <code>file_header_t</code> structure is actually just a <code>page_metadata_t</code> value that is going to
be stored in the right location to refer to itself. In other words, we&#8217;ll be able to put in inside the <em>metadata</em> for the first page, which is itself stored in the
first page. The whole thing is a bit recursive, but I believe that this would provide an elegant solution for this task.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There is one issue with this approach, however, if the allocation size is a multiple of 128 pages. In this case, we&#8217;ll add another extra page to the
allocation, ensuring that the first page will reside in a metadata page range that has a valid page.
This adds a bit of complication to large value allocations, but it isn&#8217;t a massively large issue, and there are many cases where having some extra allocated
space that we can immediately use is of great benefit, so we&#8217;ll go with this. It also means that at worst we waste 8KB for a 1 MB allocation, so it isn&#8217;t a
critical amount.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_structure_of_the_metadata">The structure of the metadata</h3>
<div class="paragraph">
<p>We need to decide what kind of information we are going to place in the page metadata. We already saw the <code>page_metadata_t</code> structure in the previous chapter.
The first part of which is made of the <code>crypto</code> segment that we&#8217;ll discuss in Chapter 11. The first byte of the second part of <code>page_metadata_t</code> is the
<code>page_flags</code>, telling us what kind of metadata we have. The other 31 bytes are free for us to use as we see fit. The first metadata entry is the <code>file_header</code>
and we also saw <code>free_space</code> for the free space bitmap. As we adds capabilities to Gavran, we can add additional metadata options to <code>page_metadata_t</code>.
<a href="#metadata_api"><code>txn.metadata.c</code> - The page metadata API we can use to get and manipulate pages metadata</a> shows the API we&#8217;ll use to work with the metadata of our pages.</p>
</div>
<div id="metadata_api" class="listingblock">
<div class="title"><code>txn.metadata.c</code> - The page metadata API we can use to get and manipulate pages metadata</div>
<div class="content">
<pre class="highlight"><code>static result_t get_metadata_entry(uint64_t page_num,
    page_t *metadata_page, page_metadata_t **metadata) {
  page_metadata_t *entries = metadata_page-&gt;address;
  page_flags_t expected    = metadata_page-&gt;page_num
                              ? page_flags_metadata
                              : page_flags_file_header;
  ensure(expected == entries-&gt;common.page_flags ||
             // can happen from txn_allocate_page
             page_flags_free == entries-&gt;common.page_flags,
      msg("Got invalid metadata page"), with(page_num, "%lu"));

  *metadata = &amp;entries[page_num &amp; ~PAGES_IN_METADATA_MASK];
  return success();
}

implementation_detail result_t txn_get_metadata(
    txn_t *tx, uint64_t page_num, page_metadata_t **metadata) {
  page_t metadata_page = {
      .page_num = page_num &amp; PAGES_IN_METADATA_MASK};
  ensure(txn_raw_get_page(tx, &amp;metadata_page));
  return get_metadata_entry(page_num, &amp;metadata_page, metadata);
}
implementation_detail result_t txn_modify_metadata(
    txn_t *tx, uint64_t page_num, page_metadata_t **metadata) {
  page_t metadata_page = {
      .page_num = page_num &amp; PAGES_IN_METADATA_MASK};
  ensure(txn_raw_modify_page(tx, &amp;metadata_page));
  return get_metadata_entry(page_num, &amp;metadata_page, metadata);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API in <a href="#metadata_api"><code>txn.metadata.c</code> - The page metadata API we can use to get and manipulate pages metadata</a> is built upon <code>txn_raw_get_page()</code> and <code>txn_raw_modify_page()</code> and provides us with a way to get or modify the metadata for a page. As you can see,
actually finding the metadata page is a matter of a division to find the right page and then a modulus operation to find the entry in the page. I&#8217;m actually using masking here
because that is much more efficient than division, but it is probably that the compiler will generate the same code for the mask and division cases.
Note that in both the get and modify cases, we validate that the page is already a metadata page, but who sets <em>this</em> up? We did that, in <code>db_init()</code>. The metadata API expects that the
metadata page flags will either be set to <code>page_flags_metadata</code> or <code>page_flags_file_header</code> (if this is the first page in the file).</p>
</div>
<div class="paragraph">
<p>That works for the first metadata page (the file header), but what about the others? How are they handled? We are going to handle that in a lazy fashion, as we allocate
pages, we&#8217;ll set up the appropriate metadata pages for them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_multi_page_allocations">Implementing multi page allocations</h3>
<div class="paragraph">
<p>The reason we <em>have</em> page metadata in the first place is to be able to allocate multiple pages at the same time as a single unit. Let&#8217;s take a look
at what we need to do in order to get it to work. We need to add this behavior in the following locations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Getting or modifying a page  - we need to figure out how to know whatever we are using a multi page value and get / clone all of the pages in the range.</p>
</li>
<li>
<p>In <code>txn_allocate_page</code> - we need to reserve enough pages as requested and remember the size requested.</p>
</li>
<li>
<p>In <code>txn_free_page</code> - we need to free all the pages involved and make sure that if all the pages in a metadata range are free, the metadata page will also be freed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I already prepared some of the ground for us. In both <code>txn_raw_get_page()</code> and <code>txn_raw_modify_page()</code>, we already respect the <code>number_of_pages</code> value that the caller provides.
We aren&#8217;t <em>using</em> it anywhere, though. Time to change this and introduce the non raw version of getting and modifying a page. You can see how that looks like in <a href="#txn_get_modify_page"><code>txn.c</code> - Getting or modifying a page in a transaction, the higher level API</a>.</p>
</div>
<div id="txn_get_modify_page" class="listingblock">
<div class="title"><code>txn.c</code> - Getting or modifying a page in a transaction, the higher level API</div>
<div class="content">
<pre class="highlight"><code>result_t txn_get_page(txn_t *tx, page_t *page) {
  page_metadata_t *mt;
  ensure(txn_get_metadata(tx, page-&gt;page_num, &amp;mt));
  ensure(txn_get_number_of_pages(mt, &amp;page-&gt;number_of_pages));
  ensure(txn_raw_get_page(tx, page));
  page-&gt;metadata = mt;
  return success();
}

result_t txn_modify_page(txn_t *tx, page_t *page) {
  page_metadata_t *metadata;
  ensure(txn_modify_metadata(tx, page-&gt;page_num, &amp;metadata));
  ensure(metadata-&gt;common.page_flags != page_flags_free,
      msg("Tried to modify a free page, need to allocate it first"));
  ensure(txn_get_number_of_pages(metadata, &amp;page-&gt;number_of_pages));
  ensure(txn_raw_modify_page(tx, page));
  page-&gt;metadata = metadata;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in <a href="#txn_get_modify_page"><code>txn.c</code> - Getting or modifying a page in a transaction, the higher level API</a> relies on the <code>txn_get_number_of_pages()</code> function, which uses the page&#8217;s metadata to figure out how many pages the lower level API should account for.
You can see the implementation in <a href="#txn_get_number_of_pages"><code>txn.c</code> - Computing the size of a page, based on its type and metadata</a>. An important feature of <code>txn_modify_page()</code> is that it is going to <em>validate</em> the pages we modify. You cannot modify a page
that is marked as free, for example. That blocks a certain set of errors from being possible.</p>
</div>
<div id="txn_get_number_of_pages" class="listingblock">
<div class="title"><code>txn.c</code> - Computing the size of a page, based on its type and metadata</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_get_number_of_pages(
    page_metadata_t *metadata, uint32_t *number_of_pages) {
  switch (metadata-&gt;common.page_flags) {
    case page_flags_file_header:
    case page_flags_free:
    case page_flags_metadata:
    case page_flags_container:
    case page_flags_hash:
    case page_flags_tree_branch:
    case page_flags_tree_leaf:
      *number_of_pages = 1;
      return success();
    case page_flags_hash_directory: {
      uint32_t buckets = metadata-&gt;hash_dir.number_of_buckets;
      *number_of_pages = TO_PAGES(buckets * sizeof(uint64_t));
      return success();
    }
    case page_flags_overflow:
      *number_of_pages = metadata-&gt;overflow.number_of_pages;
      return success();
    case page_flags_free_space_bitmap:
      *number_of_pages = metadata-&gt;free_space.number_of_pages;
      return success();
    default:
      failed(EINVAL,
          msg("Unable to get number of pages from unknown page type"),
          with(metadata-&gt;common.page_flags, "%d"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#txn_get_number_of_pages"><code>txn.c</code> - Computing the size of a page, based on its type and metadata</a> right now, all pages except for <code>page_flags_free_space_bitmap</code> and <code>page_flags_overflow</code> use a single page, but the free space bitmap or overflow pages may
be composed of multiple pages. We now can change the <code>txn_allocate_page()</code> and <code>txn_free_page()</code> to use <code>txn_get_page()</code> and <code>txn_modify_page()</code> instead of the raw API. That means that we
can now support free space bitmaps that are larger than a single page. Remember that the metadata for the free space bitmap is being setup as part of <code>db_init_free_space_bitmap()</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="title">Modifying the free space bitmap at scale</div>
<div class="paragraph">
<p>As things are currently set up, we have somewhat of a problem with the free space once we get to a large database size. When the database size is 512GB, the free space bitmap will be
8MB in size. That means that allocating or freeing a single page will cause us to modify the whole 8MB bitmap (and then commit it to disk) while we only need to flip a single bit.</p>
</div>
<div class="paragraph">
<p>I&#8217;m calling this out explicitly, because it is a weakness in the design. We&#8217;ll need to provide a better way to modify a single page of multiple pages value, but I&#8217;ll wait for the benchmarks to
show us the problem before addressing this issue.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next function to discuss is <code>txn_allocate_page()</code>. Here we need to take care of an additional concern. We may be allocating in a range that doesn&#8217;t <em>have</em>
an metadata page yet, so we have to check and reserve that page first. I&#8217;ve added a <code>txn_allocate_metadata_entry()</code> call at the end of <code>txn_allocate_page()</code>, you can see
how that is implemented in <a href="#txn_allocate_metadata_entry"><code>txn.alloc.c</code> - Allocating metadata for a page (and maybe allocating the metadata page itself)</a>.</p>
</div>
<div class="paragraph">
<p>In <code>txn_allocate_metadata_entry()</code> we first get the metadata page for the requested <code>page_num</code>. We have to deal with the possibility that this metadata page wasn&#8217;t setup previous, so we
may need to initialize the metadata page as part of allocating the metadata entry for the page. We do that by checking if the metadata page is marked as busy in the free space bitmap
or not. Because the page may not be allocated yet, we use <code>txn_raw_modify_page()</code> instead of <code>txn_modify_page()</code>. The later will refuse to modify a page that hasn&#8217;t been allocated yet,
after all.
The rest of the code in <code>txn_allocate_metadata_entry()</code> is just getting the right metadata entry and zeroing it before handing it back to the caller. It is important to understand that
the <em>caller</em> of <code>txn_allocate_page()</code> is responsible to setup the metadata after the call, so if there are multiple pages being used, the caller should register that in the metadata that
was returned from the <code>txn_allocate_page()</code> call.</p>
</div>
<div id="txn_allocate_metadata_entry" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Allocating metadata for a page (and maybe allocating the metadata page itself)</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_allocate_metadata_entry(
    txn_t *tx, uint64_t page_num, page_metadata_t **entry) {
  page_t meta_page = {.page_num = page_num &amp; PAGES_IN_METADATA_MASK};
  bool exists;
  ensure(txn_is_page_busy(tx, meta_page.page_num, &amp;exists));
  ensure(txn_raw_modify_page(tx, &amp;meta_page));
  page_metadata_t *self = meta_page.address;
  if (!exists) {
    // first time, need to allocate it all
    self-&gt;common.page_flags = page_flags_metadata;
    ensure(txn_free_space_mark_page(tx, meta_page.page_num, true));
  }
  page_flags_t expected = meta_page.page_num ? page_flags_metadata
                                             : page_flags_file_header;
  ensure(self-&gt;common.page_flags == expected,
      msg("Expected page to be metadata page, but wasn't"),
      with(page_num, "%lu"), with(self-&gt;common.page_flags, "%x"));

  page_metadata_t *metadata =
      &amp;self[page_num &amp; ~PAGES_IN_METADATA_MASK];
  ensure(!metadata-&gt;common.page_flags,
      msg("Expected metadata entry to be empty, but was in use"),
      with(page_num, "%lu"), with(metadata-&gt;common.page_flags, "%x"));

  memset(metadata, 0, sizeof(page_metadata_t));
  *entry = metadata;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is still an issue, however, with the code we have in <code>txn_allocate_page()</code>. As it current stands, the <code>bitmap_search()</code> is not aware of our actual limitations. That means
that it may very well suggest a free page on a 128 pages boundary (1 MB), which is where we want to place the metadata. It is also not aware about the manners in
which we need to allocate requests that are 128 or higher. Our next challenge is to implement this behavior.</p>
</div>
<div class="paragraph">
<p><a href="#txn_allocate_page_with_multiple_pages"><code>txn.alloc.c</code> - Allocating pages, now with multiple pages allocation support</a> shows the changed required for <code>txn_allocate_page()</code>.
There are also some changes that we must make to the bitmap search itself. These are isolated to the <code>bitmap_is_acceptable_match()</code>, which is called by the <code>bitmap_search_once()</code>.
The implementation of <code>bitmap_is_acceptable_match()</code> is shown in <a href="#bitmap_is_acceptable_match"><code>bitmap.range.c</code> - Determine if a range is an acceptable allocation</a>.</p>
</div>
<div class="paragraph">
<p>In <code>bitmap_is_acceptable_match()</code> we check if we need to allocate a large (greater than 128 pages) or a small range. We deal with those differently. A large range is handled by
<code>bitmap_is_acceptable_match()</code> directly. We know here that the large range cannot be a multiple of 128, so it must stride over a metadata page. We change the allocation so it
will <em>end</em> just before the <em>next</em>  metadata page.</p>
</div>
<div id="txn_allocate_page_with_multiple_pages" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Allocating pages, now with multiple pages allocation support</div>
<div class="content">
<pre class="highlight"><code>result_t txn_allocate_page(
    txn_t *tx, page_t *page, uint64_t nearby_hint) {
  page_t zero = {0};
  ensure(txn_get_page(tx, &amp;zero));
  uint64_t start = zero.metadata-&gt;file_header.free_space_bitmap_start;

  if (!page-&gt;number_of_pages) page-&gt;number_of_pages = 1;

  page_t bitmap_page = {.page_num = start};
  ensure(txn_get_page(tx, &amp;bitmap_page));
  bitmap_search_state_t search = {
      .input = {.bitmap = bitmap_page.address,
          .bitmap_size  = (bitmap_page.number_of_pages * PAGE_SIZE) /
                         sizeof(uint64_t),
          .space_required = page-&gt;number_of_pages,
          .near_position  = nearby_hint}};
  // <b class="conum">(1)</b>
  if ((search.input.space_required &amp; ~PAGES_IN_METADATA_MASK) == 0) {
    // we must use one more in this cases, so the first page
    // would "poke" into an existing range that has metadata pages
    search.input.space_required++;
  }
  if (bitmap_search(&amp;search)) {
    page-&gt;page_num = search.output.found_position;
    ensure(txn_raw_modify_page(tx, page));
    memset(page-&gt;address, 0, PAGE_SIZE * page-&gt;number_of_pages);
    for (size_t i = 0; i &lt; page-&gt;number_of_pages; i++) {
      ensure(txn_free_space_mark_page(
          tx, search.output.found_position + i, true));
    }
    // <b class="conum">(2)</b>
    ensure(txn_allocate_metadata_entry(
        tx, page-&gt;page_num, &amp;page-&gt;metadata));
    return success();
  }

  failed(ENOSPC, msg("No more room left in the file to allocate"),
      with(tx-&gt;state-&gt;db-&gt;handle-&gt;filename, "%s"));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We make sure that we never ask the <code>bitmap_search</code> for a value that is a multiple of 128 pages.</p>
</li>
<li>
<p>After we found the page, we allocate a metadata entry for it, as shown in <a href="#txn_allocate_metadata_entry"><code>txn.alloc.c</code> - Allocating metadata for a page (and maybe allocating the metadata page itself)</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s consider a file that is 4MB in side (512 pages), as part of <code>db_init()</code> we already allocated  2 pages manually (header page and the free space bitmap) at positions 0 and 1.
The rest of the pages are empty. Let&#8217;s play with some scenarios on how the allocations will behave.</p>
</div>
<div class="paragraph">
<p>Consider a request for an allocation for 268 pages. The bitmap finds us the first available range, pages <code>2 .. 511</code>. However, we can&#8217;t place the allocation
on page 2. If we were to do that, it would span from page 2 to page 270. And there is an metadata page on pages <code>0</code>, <code>128</code>, <code>256</code> and <code>384</code>. If we were
to place the allocation on page <code>2 .. 270</code>, it would cover metadata pages <code>128</code> and <code>256</code>. That would prevent use from using the metadata page in <code>256</code>
and render the pages from <code>256 .. 384</code> unusable.</p>
</div>
<div class="paragraph">
<p>Instead, we&#8217;ll allocate the page on page <code>116 .. 383</code>. In that matter, we leave open the range from <code>2 .. 115</code> open for other allocations and have no wasted
space.</p>
</div>
<div id="bitmap_is_acceptable_match" class="listingblock">
<div class="title"><code>bitmap.range.c</code> - Determine if a range is an acceptable allocation</div>
<div class="content">
<pre class="highlight"><code>implementation_detail bool bitmap_is_acceptable_match(
    bitmap_search_state_t *s) {
  if (s-&gt;input.space_required &gt; s-&gt;output.space_available_at_position)
    return false;
  if (s-&gt;input.space_required &lt; PAGES_IN_METADATA) {
    return bitmap_is_acceptable_small_match(s);
  }
  // large values here, size is guranteed to *not* be  128 multiple
  size_t size =
      (s-&gt;output.found_position + s-&gt;input.space_required + 1);
  if ((size % PAGES_IN_METADATA) == 0) {
    // nothing to do, already ends just before a metadata page
    return true;
  }

  uint64_t new_end =
      ((s-&gt;output.found_position + s-&gt;input.space_required) &amp;
          PAGES_IN_METADATA_MASK) +
      PAGES_IN_METADATA;
  if (new_end &gt; s-&gt;output.found_position +
                    s-&gt;output.space_available_at_position) {
    return false;  // not enough room to shift things
  }
  s-&gt;output.space_available_at_position -=
      new_end - s-&gt;output.found_position - s-&gt;input.space_required;
  s-&gt;output.found_position = new_end - s-&gt;input.space_required;
  return true;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how we are going to handle small requests, which are shown in <a href="#bitmap_is_acceptable_small_match"><code>bitmap.range.c</code> - Determine if a small range is an acceptable allocation</a>.</p>
</div>
<div class="paragraph">
<p>If the small allocation starts on a metadata page, we&#8217;ll try to shift it by one page and see if we have enough space available. We then check if the range
fall on the same metadata range (same MB in the file). If this is the case, we don&#8217;t have to do anything, this isn&#8217;t going to collide with anything.
However, if the range we got include another metadata page, we cannot allow it. We will try to move the allocation to the <em>next</em> metadata range (the next MB)
and see if we have enough space to manage there.</p>
</div>
<div class="paragraph">
<p>Going back to the 4MB file with 512 pages example. Consider the case when we need to allocate two 64 pages allocation requests. The first one will fit in <code>128</code>
pages range and will consume <code>2 .. 65</code> pages.
The second request, however, would need to cover pages <code>66 .. 129</code> covering the metadata page for the second MB range. Instead of putting it there, we shift
it forward to allocate the range from <code>129 .. 192</code> pages. That leave the <code>66 .. 127</code> range free, and a request to allocate 32 pages will be satisfied with
the range <code>66 .. 97</code>.</p>
</div>
<div id="bitmap_is_acceptable_small_match" class="listingblock">
<div class="title"><code>bitmap.range.c</code> - Determine if a small range is an acceptable allocation</div>
<div class="content">
<pre class="highlight"><code>static bool bitmap_is_acceptable_small_match(
    bitmap_search_state_t *s) {
  uint64_t pos = s-&gt;output.found_position + s-&gt;internal.search_offset;
  if (!(pos &amp; ~PAGES_IN_METADATA_MASK)) {
    // cannot use, falls on metadata page, try to shift it
    s-&gt;output.found_position++;
    s-&gt;output.space_available_at_position--;
    // may fail if there isn't enough room now
    return (s-&gt;input.space_required &gt;=
            s-&gt;output.space_available_at_position);
  }
  uint64_t start = pos &amp; PAGES_IN_METADATA_MASK;
  uint64_t end =
      (pos + s-&gt;input.space_required - 1) &amp; PAGES_IN_METADATA_MASK;
  if (start == end)  // on the same MB, nothing to do
    return true;
  // past the next metadata page
  uint64_t new_start = start + PAGES_IN_METADATA + 1;
  if (new_start + s-&gt;input.space_required &gt;
      pos + s-&gt;output.space_available_at_position) {
    // not enough space to shift things
    return false;
  }
  s-&gt;output.space_available_at_position -= (new_start - pos);
  s-&gt;output.found_position = new_start - s-&gt;internal.search_offset;
  return true;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_freeing_allocated_disk_space">Freeing allocated disk space</h3>
<div class="paragraph">
<p>I saved the biggest hurdle for the end. We now need to handle a bit of a tricky situation, how do we free pages using this scheme.
We need to take into account not just the fact that we are freeing multiple pages at the same time but also that we might need to free
the <em>metadata</em> for that particular range. You can see how I solved the issue in <a href="#txn_free_multiple_pages"><code>txn.alloc.c</code> - Freeing pages, including metadata entries and freeing related metadata pages</a>.</p>
</div>
<div class="paragraph">
<p>The most interesting new behavior in <code>txn_free_page()</code> is the fact that we&#8217;ll release the relevant metadata page when all the pages that belong to that metadata page
will are freed. We do the check using the <code>txn_free_space_bitmap_metadata_range_is_free()</code> function shown on <a href="#txn_free_space_bitmap_metadata_range_is_free"><code>txn.alloc.c</code> - Checking if the entire metadata page is free</a>.</p>
</div>
<div id="txn_free_multiple_pages" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Freeing pages, including metadata entries and freeing related metadata pages</div>
<div class="content">
<pre class="highlight"><code>result_t txn_free_page(txn_t *tx, page_t *page) {
  errors_assert_empty();

  if ((page-&gt;number_of_pages &amp; ~PAGES_IN_METADATA_MASK) == 0)
    page-&gt;number_of_pages++;  // allocations on 128 pages boundary
                              // have an extra page tacked on them

  ensure(txn_modify_page(tx, page));
  memset(page-&gt;address, 0, PAGE_SIZE * page-&gt;number_of_pages);

  for (size_t i = 0; i &lt; page-&gt;number_of_pages; i++) {
    ensure(txn_free_space_mark_page(tx, page-&gt;page_num + i, false));
  }

  // <b class="conum">(1)</b>
  uint64_t metadata_page_num =
      page-&gt;page_num &amp; PAGES_IN_METADATA_MASK;
  if (metadata_page_num != page-&gt;page_num &amp;&amp; page-&gt;page_num) {
    // <b class="conum">(2)</b>
    memset(page-&gt;metadata, 0, sizeof(page_metadata_t));

    bool is_free;
    ensure(txn_free_space_bitmap_metadata_range_is_free(
        tx, metadata_page_num, &amp;is_free));
    if (is_free) {
      page_t metadata_page = {.page_num = metadata_page_num};
      ensure(txn_free_page(tx, &amp;metadata_page));
    }
  }

  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If we aren&#8217;t freeing a metadata page, we check if the metadata page is the only remaining page in the MB range it owns. If that is the case, we free it as well.</p>
</li>
<li>
<p>When we release a page, we zero the matching metadata entry for the page. Note that if the page was composed of multiple pages, we only zero the first entry,
the others entries are not relevant.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>txn_free_space_bitmap_metadata_range_is_free()</code> looks strange, so let&#8217;s explain how it works. We are using a bitmap composed and rely on <code>uint64_t</code> values. That means
that a metadata range (1 MB) is covered by two <code>uint64_t</code> values. If the entire range is free, except for the metadata page, we&#8217;ll have the following bits pattern:
<code>1000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000</code>. That pattern has 128 bits and covers one MB
range. If we deal with it as <code>uint64_t</code>, we can simple compare the first part to <code>1</code> and the second to <code>0</code>. The result tells us if the range has only its metadata page marked
as busy, in quite an elegant manner.</p>
</div>
<div id="txn_free_space_bitmap_metadata_range_is_free" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Checking if the entire metadata page is free</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_free_space_bitmap_metadata_range_is_free(
    txn_t *tx, uint64_t page_num, bool *is_free) {
  page_t zero = {0};
  ensure(txn_get_page(tx, &amp;zero));

  uint64_t start = zero.metadata-&gt;file_header.free_space_bitmap_start;

  uint64_t relevant_free_space_bitmap_page =
      start + page_num / BITS_IN_PAGE;

  page_t bitmap_page = {.page_num = relevant_free_space_bitmap_page};
  ensure(txn_raw_get_page(tx, &amp;bitmap_page));
  uint64_t *bitmap = bitmap_page.address;
  size_t index     = (page_num % BITS_IN_PAGE) / 64;
  *is_free         = bitmap[index] == 1 &amp;&amp; bitmap[index + 1] == 0;
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is still a lurking issue in our system. We are able to allocate disk space that we have reserved from the system, but how are we going to be able to handle
running out of space entirely? How can we grow our file? These are great questions, but we won&#8217;t answer them immediately. I&#8217;m itching to get to grips with the
ACID properties of the transaction, so we&#8217;ll get to that next.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit tests</h3>
<div class="paragraph">
<p>There have been a <em>lot</em> of changes to the internals of the code and there is a lot more functionality to test. I have included scenarios that will test
our each of the options we have discussed in this chapter.</p>
</div>
<div class="paragraph">
<p>One thing to note about the tests, when we call <code>txn_free_page()</code> now, we <em>must</em> do so on a page that was <em>properly</em> setup. In other words, just calling <code>txn_allocate_page()</code>
isn&#8217;t enough. One of hte values that you&#8217;ll get from the function is a pointer to the metadata for the page. You must set at least the <code>page_flags</code> to something meaningful
and if you are using <code>page_flags_overflow</code>, as we do in the tests, you must also setup the <code>overflow</code> struct on the <code>page_metadata_t</code>.</p>
</div>
<div id="tests06" class="listingblock">
<div class="title"><code>test.c</code> - Testing the allocation API</div>
<div class="content">
<pre class="highlight"><code>describe(metadata_tests) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("can allocate multiple pages") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);

    page_t p1 = {.number_of_pages = 4};
    assert(txn_allocate_page(&amp;tx, &amp;p1, 0));
    assert(p1.page_num == FIRST_USABLE_PAGE);

    page_t p2 = {.number_of_pages = 4};
    assert(txn_allocate_page(&amp;tx, &amp;p2, 0));
    assert(p2.page_num == FIRST_USABLE_PAGE + 4);
  }

  it("will not allocate on metadata boundary (small)") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1028 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);

    page_t p1 = {.number_of_pages = 96};
    assert(txn_allocate_page(&amp;tx, &amp;p1, 0));
    assert(p1.page_num == FIRST_USABLE_PAGE);

    page_t p2 = {.number_of_pages = 32};
    assert(txn_allocate_page(&amp;tx, &amp;p2, 0));
    assert(p2.page_num == 129);
  }

  it("can allocate very large values") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1028 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);

    page_t p1 = {.number_of_pages = 268};
    assert(txn_allocate_page(&amp;tx, &amp;p1, 0));
    assert(p1.page_num == 116);

    page_t p2 = {.number_of_pages = 32};
    assert(txn_allocate_page(&amp;tx, &amp;p2, 0));
    assert(p2.page_num == FIRST_USABLE_PAGE);
  }

  it("after move to next range will still use existing range") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1028 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);

    page_t p1 = {.number_of_pages = 96};
    assert(txn_allocate_page(&amp;tx, &amp;p1, 0));
    assert(p1.page_num == FIRST_USABLE_PAGE);

    page_t p2 = {.number_of_pages = 32};
    assert(txn_allocate_page(&amp;tx, &amp;p2, 0));
    assert(p2.page_num == 129);

    page_t p3 = {.number_of_pages = 16};
    assert(txn_allocate_page(&amp;tx, &amp;p3, 0));
    assert(p3.page_num == FIRST_USABLE_PAGE + 96);
  }

  it("can free and reuse") {
    db_t db;
    db_options_t options = {.minimum_size = 4 * 1028 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);

    page_t p1 = {.number_of_pages = 96};
    assert(txn_allocate_page(&amp;tx, &amp;p1, 0));
    assert(p1.page_num == FIRST_USABLE_PAGE);

    page_t p2 = {.number_of_pages = 32};
    assert(txn_allocate_page(&amp;tx, &amp;p2, 0));
    p2.metadata-&gt;overflow.page_flags      = page_flags_overflow;
    p2.metadata-&gt;overflow.number_of_pages = 32;
    p2.metadata-&gt;overflow.size_of_value   = 32 * PAGE_SIZE;
    assert(p2.page_num == 129);
    assert(txn_free_page(&amp;tx, &amp;p2));

    page_t p3 = {.number_of_pages = 268};
    assert(txn_allocate_page(&amp;tx, &amp;p3, 0));
    assert(p3.page_num == 116);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
    <ul style="list-style-type: none;">
        <li><a class="footer-text" href="../index.html">Table of contents</a></li>
        <li><a class="footer-text" href="./ch05.html">Previous chapter</a></li>
        <li><a class="footer-text" href="./ch07.html">Next chapter</a></li>
    </ul>
</div>
</body>
</html>