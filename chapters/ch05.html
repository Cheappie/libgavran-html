<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Managing disk space allocations</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
.footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
.footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_managing_disk_space_allocations">Managing disk space allocations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter, we built up the transaction API and were able to modify a page and persist it back. At this point, the code we have makes absolutely no
assumptions about the data we have on disk. We operate on the data in page units and blindly. This cannot go on, because we can&#8217;t expect the users to know how to
manage the pages and their content by themselves.
We need to be able to allocate and free pages. Once we have that, we can build more sophisticated data structures.
The new API we want to have are shown in <a href="#tx_allocation"><code>gavran/db.h</code> - The new transaction API that we will to implement</a>.</p>
</div>
<div id="tx_allocation" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The new transaction API that we will to implement</div>
<div class="content">
<pre class="highlight"><code>result_t txn_allocate_page(
    txn_t *tx, page_t *page, uint64_t nearby_hint);
result_t txn_free_page(txn_t *tx, page_t *page);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let consider what we actually need to do in order to implement the ability to dynamically allocate and free pages. We need to persist somewhere that pages are taken or free.
We need to be able to search for a free page and we need to be able to mark a page as free. That means that we are going to store that information in the file itself. And that lead
to a bunch of questions. How are we going to do this? What would be the format of the data? How well will it play with future features?</p>
</div>
<div class="paragraph">
<p>We want to create a system that will serve for the foreseeable future, we want to ensure that it plays nicely with the API we created so far and that is doesn&#8217;t
require complex implementation. We are too low in the stack yet to be able to do truly interesting things. The whole point of this book is to build the features
one on top of the other.</p>
</div>
<div class="sect2">
<h3 id="_the_file_header">The file header</h3>
<div class="paragraph">
<p>Looking at the API above and how we can implement them, I think we&#8217;ll the following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The size of the file in pages - we need to store that information inside the data file because relying on the size of the file as reported by the operating
system cannot serve us for long. If we failed after the file size was extended but didn&#8217;t update our internal metadata, we&#8217;ll probably not enjoy the result.</p>
</li>
<li>
<p>A way to tell if a page is free or in used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Right now we need to keep track of only one piece of data about the file, its size in pages, but I&#8217;m sure that we&#8217;ll have more in the future. To handle that
we&#8217;ll create the following structure to serve as the header for the file and be the metadata location. You can see what this will look like in <a href="#file_header"><code>gavran/db.h</code> - The file header contains metadata about the whole file</a>.</p>
</div>
<div class="paragraph">
<p>The header in <a href="#file_header"><code>gavran/db.h</code> - The file header contains metadata about the whole file</a> has a <code>magic</code> field, which must be set to the <code>FILE_HEADER_MAGIC</code> value. This is how we&#8217;ll test if a file is a valid Gavran file or
something else. We already spoke about the <code>number_of_pages</code> and why we need it and the <code>version</code> field is future proofing. If we&#8217;ll need to modify the
layout of the data on disk, we can detect it from the header and react to it.
We are going to ignore the <code>last_tx_id</code> in this chapter, and we&#8217;ll get to <code>free_space_bitmap_start</code> later in this chapter.</p>
</div>
<div class="paragraph">
<p>The <code>page_size_power_of_two</code> is used to verify that we aren&#8217;t attempting to open a file whose page size is different from the <code>PAGE_SIZE</code> we are expecting.
We use the power of two mode because we want to reduce the number of bytes that we are using as much as possible. This is a <em>persistent</em> structure, which will be
stored on the disk. As such, we are going to start caring quite deeply about how big certain things are.</p>
</div>
<div id="file_header" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The file header contains metadata about the whole file</div>
<div class="content">
<pre class="highlight"><code>#define FILE_HEADER_MAGIC "GVRN!"

typedef struct file_header {
  page_flags_t page_flags;
  uint8_t version;
  uint8_t page_size_power_of_two;
  uint8_t magic[5];  // should be FILE_HEADER_MAGIC
  uint64_t number_of_pages;
  uint64_t free_space_bitmap_start;
  uint64_t last_tx_id;
} file_header_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next question to ask is where are we going to place this information. The obvious answer is in the header, no? It is right there in the name. Let&#8217;s see
what needs to be done to add this to our code. We need a higher level abstraction than the file, we need to now operate at the <em>database</em> level, instead.</p>
</div>
<div class="paragraph">
<p>This is why we have the <code>db_options_t</code> and the <code>db_create</code> function, which we saw in the previous chapter. In the last chapter, <code>db_create</code> would open a database
by validating its options, setting the size and creating the memory mapping. I mentioned there that we&#8217;ll do more work in <code>db_init()</code> in the future.
Well, the future has arrived, and now is the time to put some structure in our file. Take a look at <a href="#file-header">The physical layout of the header records in the first few page in the file</a>, which shows how where we&#8217;ll put the data in
the file.</p>
</div>
<div id="file-header" class="imageblock">
<div class="content">
<img src="../imgs/file-header.png" alt="file header">
</div>
<div class="title">Figure 1. The physical layout of the header records in the first few page in the file</div>
</div>
<div class="paragraph">
<p>In the last chapter, we saw that <code>db_create()</code> will ask the file system to allocate disk space for the file ahead of time, which will always be zero filled. In order
to check if the file is new or not, we can check the <code>page_flags</code> value on the first page. If the value is set to zero, we can assume that this is a new file and
set it up accordingly.</p>
</div>
<div class="paragraph">
<p>Note that this isn&#8217;t really a good idea in general. A single flipped byte may cause us to mistake a valid file as new and initialize it as an empty file. We&#8217;ll do
much better later on. In fact, you&#8217;ll start to see some hints on how we are about to approach this task from this chapter. For now, we&#8217;ll assume that checking the
<code>page_flags</code> value on the first page is sufficient.
The actual work is managed by the <code>db_init()</code>, which is called after <code>db_create()</code> setup the file, wired the memory map, etc.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Duplicating data for safety reasons</div>
<div class="paragraph">
<p>In many low level formats, you will often see intentionally duplicated data. You&#8217;ll have the file metadata at the beginning and the end of the file.
NTFS, for example, will write its MFT (Master File Table) at the start of the disk as well as the middle. The idea is that if there is something wrong in
the disk, there is another location to search for the data.</p>
</div>
<div class="paragraph">
<p>I decide to avoid doing this in Gavran, for several reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Old disks used to have platters and sectors and such. Almost all new disks will be SSDs based and use a very different format internally. In particular,
it is very common for SSD systems to coalesce writes that happened at the same time into the same block, even if they are meant to be far apart in the disk.
That renders attempts to keep a piece of data in sync in multiple locations for safety reasons mostly useless.</p>
</li>
<li>
<p>It adds complexity and time. Even if the actual work isn&#8217;t too hard, to make use of it, there is the need to write recovery code that would make use of
a potentially corrupted file. I have done this for the Voron files, and it isn&#8217;t much fun.</p>
</li>
<li>
<p>In many cases, this is already handled by lower layers, either at the file system or the drive layer.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In <a href="#db_init"><code>db.c</code> - Checking if the database already exists or is new and then setting it up</a> you can see that we first check if the file represent a new database or an existing one. The <code>db_is_new_file()</code> is a really interesting function
because it uses the <em>transaction</em> API to do its work. Why is that remarkable in any way, though?</p>
</div>
<div class="paragraph">
<p>Remember, at this point, we have to assume that we may be operating on:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A valid Gavran data file, created by a previous run on Gavran.</p>
</li>
<li>
<p>A zero filled file that was allocated by <code>db_create()</code> and which we&#8217;ll need to setup properly.</p>
</li>
<li>
<p>A file with data that isn&#8217;t a valid Gavran file. That can be:</p>
<div class="ulist">
<ul>
<li>
<p>A corrupted Gavran file (bug, disk error, etc).</p>
</li>
<li>
<p>A file that isn&#8217;t even a Gavran file, may be a zip file, a PNG, etc.</p>
</li>
<li>
<p>A malicious file that came from a non-trusted source.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>That is why the <code>txn_raw_get_page()</code> and <code>txn_raw_modify_page()</code> are considered <em>raw</em> API, they can make no assumption on the data that they operate on. The check
in <code>db_is_new_file()</code> isn&#8217;t actually a check on a single byte, instead we check that the whole <code>page_metadata_t</code> is set to zero. We&#8217;ll discuss what exactly that is
in just a little bit. If the first <code>page_metadata_t</code> is zeroed, we consider the file to be new and will call to <code>db_init_file_structure()</code> to perform the actual
initialization.</p>
</div>
<div class="paragraph">
<p>Regardless of whatever the file is new or not, we&#8217;ll validate its structure and initialize our in memory state from the file in <code>db_validate_file_on_startup()</code>.
That adds another layer of validation to protect us from bugs or disk issues.</p>
</div>
<div id="db_init" class="listingblock">
<div class="title"><code>db.c</code> - Checking if the database already exists or is new and then setting it up</div>
<div class="content">
<pre class="highlight"><code>static result_t db_is_new_file(db_t *db, bool *is_new) {
  txn_t tx;
  ensure(txn_create(db, TX_READ, &amp;tx));
  defer(txn_close, tx);

  page_t page = {.page_num = 0};
  ensure(txn_raw_get_page(&amp;tx, &amp;page));
  page_metadata_t zero;
  memset(&amp;zero, 0, sizeof(page_metadata_t));
  page_metadata_t *entry = page.address;
  *is_new                = memcmp(&amp;entry-&gt;file_header, &amp;zero,
                sizeof(page_metadata_t)) == 0;
  return success();
}

implementation_detail result_t db_init(db_t *db) {
  bool is_new;
  ensure(db_is_new_file(db, &amp;is_new));
  if (is_new) {
    ensure(db_init_file_structure(db));
  }
  ensure(db_validate_file_on_startup(db));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we understand how Gavran knows whatever the file is new or not, let&#8217;s look at how we are going to go about initializing the file startup.
You can see the behavior in <a href="#db_init_file_structure"><code>db.c</code> - Initializing the file on startup</a>, the code there is interesting for a very important reason. It is using a <em>transaction</em> to modify the data.
This is strange, because transactions right now aren&#8217;t really that fancy. Why wouldn&#8217;t we write to the data directly using <code>pages_write()</code> or <code>pal_write_file()</code>?
The reason is that we want Gavran to be a transactional storage engine.</p>
</div>
<div class="paragraph">
<p>That means that <em>all</em> the writes to the system must be durable and that means that we can&#8217;t sneak <em>any</em> writes to
the file under the radar. Our transactions will make sure that the data changes are valid, and they are the only way to write to the file.</p>
</div>
<div class="paragraph">
<p><a href="#db_init_file_structure"><code>db.c</code> - Initializing the file on startup</a> is the also first time that <em>Gavran</em> is actually starting to use its own API to implement real functionality. As part of starting up the database
we&#8217;ll create a transaction, modify the first page so we can write the headers and commit to the file. That is cool!
Another interesting thing about the <code>db_init_file_structure()</code> function is that it creates a transaction, and then pass it to other functions to do the actual work. The real
work is done by <code>db_init_file_header()</code> and <code>db_init_free_space_bitmap()</code>.</p>
</div>
<div class="paragraph">
<p>We already saw how <code>file_header_t</code> looks like in <a href="#file_header"><code>gavran/db.h</code> - The file header contains metadata about the whole file</a>, we should also look at the <code>page_metadata_t</code> structure, shown in <a href="#page_metadata_t"><code>gavran/db.h</code> - The page metadata structure</a>, to complete the full picture.
This is a <em>persistent</em> data structure, in the sense that we are going to write it to disk and use it quite often. As such, there are a number of of things that we should discuss about
this critical structure. We are using these structures to manipulate the persistent data on disk using C structures in a type safe manner, instead of manipulating the bits directly.</p>
</div>
<div id="db_init_file_structure" class="listingblock">
<div class="title"><code>db.c</code> - Initializing the file on startup</div>
<div class="content">
<pre class="highlight"><code>static result_t db_init_file_structure(db_t *db) {
  txn_t tx;
  ensure(txn_create(db, TX_WRITE, &amp;tx));
  defer(txn_close, tx);

  ensure(db_init_file_header(db, &amp;tx));
  ensure(db_init_free_space_bitmap(&amp;tx));

  ensure(txn_commit(&amp;tx));
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>page_metadata_t</code> is exactly 64 bytes in size. The first 32 bytes of the structure are taken by a <code>crypto</code> header. I&#8217;m going to spend the whole of Chapter 11 to discuss that, so
we&#8217;ll skip this for now. The rest of <code>page_metadata_t</code> is a union of the structures that may be part of the page metadata. We use the <code>page_metadata_common_t</code>, which define the
<code>page_flags</code> field to check what is the actual type of the page and then we can switch to the right union member and work with it directly. All the structures in the union <em>must</em>
have <code>page_flags</code> as their first field and be up to 32 bytes in size.</p>
</div>
<div class="paragraph">
<p>Now that we understand how we structure (pun intended) the data on disk, let&#8217;s see how we are actually making use of it. The database initialization is done on <a href="#db_validate_file_on_startup"><code>db.c</code> - Validating the file on startup</a>.
Although it might be a stretch to call it initialization at this point. Right now the only thing that we are going to do is to validate the on disk data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">What about alignment?</div>
<div class="paragraph">
<p>One of the dangers of casting between pointers between different structures is that we&#8217;ll hit undefined behavior. In this case, we got it covered because we are using a union
and making sure that the initial field match across all of the types that will be stored in the <code>page_metadata_t</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We start by creating a transaction, remember that we can&#8217;t read or modify any data from the file without a transaction. That is <em>important</em>. I know that I have talked about this previously
but it is well worth repeating. By making sure that there are no cheats, we are going to create a robust system. Using the read transaction we create, we access the first page and verify
that it is setup to be a file header page. We then validate that the header is valid in <a href="#db_validate_file_on_startup"><code>db.c</code> - Validating the file on startup</a>.</p>
</div>
<div class="paragraph">
<p>In <code>db_validate_file_on_startup()</code> we validate that the header match our expectation. The <code>page_size</code> and <code>version</code> are as expected and that we have the magic value in the right place. Note that
because the <code>page_metadata_t</code> has a <code>crypto</code> for its first 32 bytes, the actual <code>magic</code> field is located on bytes 36 - 41. That is not typically where you&#8217;ll put the string identifying your
file. Usually that is the very first bytes of the file. I&#8217;m doing it this way to make it (much) easier for me when we get to Chapter 11 and talk about the <code>crypto</code> part of the page metadata.</p>
</div>
<div id="page_metadata_t" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The page metadata structure</div>
<div class="content">
<pre class="highlight"><code>typedef struct page_metadata_common {
  page_flags_t page_flags;
  char padding[23];
  uint64_t last_tx_id;
} page_metadata_common_t;

typedef struct page_metadata {
  page_crypto_metadata_t cyrpto;

  union {
    page_metadata_common_t common;
    file_header_t file_header;
    free_space_bitmap_heart_t free_space;
    overflow_page_t overflow;
    container_page_t container;
    hash_page_t hash;
    hash_page_directory_t hash_dir;
    tree_page_t tree;
  };
} page_metadata_t;

_Static_assert(sizeof(page_crypto_metadata_t) == 32,
    "The size of page crypto must be 32 bytes");
_Static_assert(sizeof(page_metadata_t) == 64,
    "The size of page metadata must be 64 bytes");</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Why all the small functions?</div>
<div class="paragraph">
<p>You might have noticed that I&#8217;m using very small functions in the code. There are three reasons for this decision:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Shorter functions tend to be more readable and the using <code>defer</code> and <code>ensure</code> means that I don&#8217;t have so much visible plumbing.</p>
</li>
<li>
<p>I need to fit these functions into a book format, which means that I have a hard limit on how much code I can show on a single page. Aside from the unit tests, I want to avoid multi page
code listing. These are rather daunting and make it hard to explain exactly what is going on in the engine.</p>
</li>
<li>
<p>Small functions means that I can update a single function&#8217;s behavior and then show what changed there, without having to provide too much additional context. Here is the new version of
<code>do_something_small()</code> is so much better than trying to push a diff of a longer function, in terms of readability.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="db_validate_file_on_startup" class="listingblock">
<div class="title"><code>db.c</code> - Validating the file on startup</div>
<div class="content">
<pre class="highlight"><code>static result_t db_validate_file_on_startup(db_t *db) {
  txn_t tx;
  ensure(txn_create(db, TX_READ, &amp;tx));
  defer(txn_close, tx);
  page_t page = {.page_num = 0};
  ensure(txn_raw_get_page(&amp;tx, &amp;page));
  page_metadata_t *entry = page.address;

  ensure(!memcmp(FILE_HEADER_MAGIC, entry-&gt;file_header.magic, 5),
      msg("Unable to find valid file header magic value"),
      with(db-&gt;state-&gt;handle-&gt;filename, "%s"));

  ensure(GAVRAN_VERSION == entry-&gt;file_header.version,
      msg("Gavran version mismatch"), with(GAVRAN_VERSION, "%d"),
      with(entry-&gt;file_header.version, "%d"),
      with(db-&gt;state-&gt;handle-&gt;filename, "%s"));

  ensure(entry-&gt;file_header.number_of_pages * PAGE_SIZE &lt;=
             db-&gt;state-&gt;map.size,
      msg("The size of the file is smaller than the expected."),
      with(db-&gt;state-&gt;handle-&gt;filename, "%s"),
      with(db-&gt;state-&gt;map.size, "%lu"),
      with(entry-&gt;file_header.number_of_pages * PAGE_SIZE, "%lu"));

  ensure(
      PAGE_SIZE == pow(2, entry-&gt;file_header.page_size_power_of_two),
      msg("The file page size is invalid"),
      with(db-&gt;state-&gt;handle-&gt;filename, "%s"),
      with(pow(2, entry-&gt;file_header.page_size_power_of_two), "%f"),
      with(PAGE_SIZE, "%d"));

  return success();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_allocating_and_freeing_pages">Allocating and freeing pages</h3>
<div class="paragraph">
<p>Now that we have all of this setup properly, the question <em>why</em> raises itself. We want to implement <code>txn_free_page()</code> and <code>txn_allocate_page()</code>, how does this
help us? The answer is that in order to write those functions, we need to have a place to store metadata about the file. We now have a place to do this
setup: <code>db_init_free_space_bitmap()</code>, which is called from <code>db_init_file_structure()</code>.</p>
</div>
<div class="paragraph">
<p>The next step is deciding exactly how we&#8217;ll implement the free list. I want to reduce complexity as much as possible, so any complex data structure is going to be hard
to build at this point, without much infrastructure in place. The easiest way to manage the free space is to use a bitmap or a bit array for the free/in used marker.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s run some numbers and see how feasible this is? Let&#8217;s assume we have a file that is 512GB in size, using 8KB pages, that gives us
<code>67,108,864</code> pages to keep track of. In order to manage that using a bitmap, you&#8217;ll <code>8,388,608</code> bytes which is exactly 8MB. In other words using a bitmap
to store the free/busy mode means that we will use 1/65,536 of the data for the free list. That means that about 0.0015% of the disk space will be dedicated for
this purpose.</p>
</div>
<div class="paragraph">
<p>The bitmap approach has several advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple to implement and obvious how to get working.</p>
</li>
<li>
<p>Negligible amount of space overhead.</p>
</li>
<li>
<p>There are many ways to efficiently search a bitmap.</p>
</li>
<li>
<p>There is a fixed size for the free list, we don&#8217;t need to handle allocate / free of space except when we grow the actual file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This hits all the sweat spots, so let consider how we can go about implementing this? If you&#8217;ll recall <a href="#file-header">The physical layout of the header records in the first few page in the file</a>, we are using the first page of the file
as the location of the headers. Where would we put the free space bitmap?</p>
</div>
<div class="paragraph">
<p>As easy solution would be to place it as the second page, but that has an issue, how are we going to handle growing the file? A single page will give us
enough bits to manage a free list of a file up to 512MB. But what would you do next? You would need more space and it is best if we kept the free list
bitmap as a single consecutive buffer.</p>
</div>
<div class="paragraph">
<p>The answer is that we are going to manage this process <em>using</em> the free list itself. One of the responsibilities of the <code>db_init_file_structure()</code>
will be to setup the initial free list bitmap. Following this, when we need to increase the free list size, we&#8217;ll ask the free list itself where we
can place the increased list size and then free the old location.</p>
</div>
<div class="paragraph">
<p>Simple, at least as a concept. Let&#8217;s see what will happen when we sit down to actually implement this&#8230;&#8203; the full details are in <a href="#db_init_free_space_bitmap"><code>db.c</code> - Creating the initial free space bitmap</a>.</p>
</div>
<div class="paragraph">
<p>Similarity to <code>db_init_file_header()</code>, we are starting with using the transaction to get the first header page and grab the <code>number_of_pages</code> from the
file header (which was previously set up in <code>db_init_file_header()</code>, which is called before <code>db_init_free_space_bitmap()</code>). We setup the free space bitmap
as the <em>second</em> page, and register it in the metadata of the second entry in the first page on the file. This will become much clearer when we&#8217;ll discuss
how we handle pages metadata later on in the next chapter.</p>
</div>
<div class="paragraph">
<p>We compute how many pages we&#8217;ll need for the free space bitmap using <code>ROUND_UP</code> and <code>BITS_IN_PAGE</code>. A page is 8KB, so we have a total of <code>65,536</code> bits in
a page and the bitmap can handle 512MB of pages. Note that we store the page number where the free space bitmap in the file header, inside
<code>free_space_bitmap_start</code>. Initially, this is hard coded to the second page, but as we discuss, we may need to move it as the file size grow, and that field
will always let us know where to find it.</p>
</div>
<div class="paragraph">
<p>We use <code>txn_raw_modify_page()</code> to get the page&#8217;s buffer. Note that we pass a <code>size</code> value to <code>txn_raw_modify_page()</code>. This is used when we need to modify
multiple pages as a single buffer. The next step is to simply mark the busy pages in the file at this point. The first few pages are marked as busy, those
are the header page and the pages used by the free space bitmap itself. In most cases, when we initialize a file, the size will be less than 512MB and we&#8217;ll
use just a single free space bitmap page. I don&#8217;t like placing arbitrary limits on my code, so I&#8217;m handling initialization with any size of the file.</p>
</div>
<div id="db_init_free_space_bitmap" class="listingblock">
<div class="title"><code>db.c</code> - Creating the initial free space bitmap</div>
<div class="content">
<pre class="highlight"><code>static result_t db_init_free_space_bitmap(txn_t *tx) {
  page_t page = {.page_num = 0};
  ensure(txn_raw_modify_page(tx, &amp;page));
  page_metadata_t *entry                     = page.address;
  uint64_t free_space_start                  = 1;
  entry-&gt;file_header.free_space_bitmap_start = free_space_start;

  uint32_t pages = (uint32_t)ROUND_UP(
      entry-&gt;file_header.number_of_pages, BITS_IN_PAGE);

  entry[free_space_start].free_space.page_flags =
      page_flags_free_space_bitmap;
  entry[free_space_start].free_space.number_of_pages = pages;

  page_t p = {.page_num = 1, .number_of_pages = pages};
  ensure(txn_raw_modify_page(tx, &amp;p));
  // mark header &amp; free space pages as busy
  for (size_t i = 0; i &lt;= pages; i++) {
    bitmap_set(p.address, i, true);
  }
  // mark as busy the pages beyond the end of the file
  size_t end = entry-&gt;file_header.number_of_pages % BITS_IN_PAGE;
  for (size_t i = end; i &lt; BITS_IN_PAGE; i++) {
    bitmap_set(p.address, i, true);
  }
  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also mark the pages in the <em>end</em> as busy. Why is that? The free space bitmap operates in pages of 8KB, each of which contains 64K bits. If the size of the
file does not align on a 512MB boundary, we are bound to have more entries in the free space bitmap than we have pages in the file. We handle this scenario by
simply marking the pages beyond the end of the file as busy. We&#8217;ll need to address that when we&#8217;ll allow to increase the file size.</p>
</div>
<div class="paragraph">
<p>Using a bitmap for the free space management is simple and effective. It cuts down on the complexity of the system. LMDB, for example, uses its own
data structure (B+Tree) to manage the free list. That can lead to recursion where the free list needs to allocate or free a page while a free
list operation is ongoing. That can lead to&#8230;&#8203; issues and took a while to properly stabilize. This model, however, solve all those issues very
neatly.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ll look at the code in <code>db_init_free_space()</code>, we even handle cases where recording the pages of the free list itself as busy will take
more than one page. That can only happen once the database exceeded 4TB in size. Not something that I expect to be common, but it doesn&#8217;t take a lot
of code to handle this. We also used the <code>bitmap_set()</code> utility functions in <a href="#db_init_free_space_bitmap"><code>db.c</code> - Creating the initial free space bitmap</a>, you can see all the bit manipulations function in
<a href="#bit-manipulations"><code>gavran/db.h</code> - The page metadata structure</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Low level transaction API</div>
<div class="paragraph">
<p>Using the transaction API to manage the startup of our database is cool, but it comes at a cost. We are using the API at a time when we haven&#8217;t actually
done the setup. That means that there might be invariants that are broken. What <em>that</em> means is that the APIs that we are using
(<code>tx_create()</code>, <code>tx_raw_modify_page()</code> and <code>tx_commit()</code>) are going to have to be able to work with no setup at all from the rest of the system.</p>
</div>
<div class="paragraph">
<p>We need to be careful during initialization and many other functions that operate of transactions may not work at this point. For example, we cannot call
<code>txn_allocate_page()</code>, because the free space bitmap that would tell us <em>where</em> to allocate the page hasn&#8217;t been setup yet.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see in <a href="#file-layout-with-freepsace">Layout of the file on disk after adding the free space bitmap</a>, the second page is used for the free list and the first two bits there are marked as busy. The rest of the page is
filled with zeros, indicating free pages. Where did those zeros come from, however? We didn&#8217;t set them up.
These zeros are there because we create a new file. Even though we preallocated the size of the file, the operating system ensures that the
contents of the file are zeroed. Otherwise, you may get sensitive data from other files. We rely on this property here to avoid doing extra work.</p>
</div>
<div id="bit-manipulations" class="listingblock">
<div class="title"><code>gavran/db.h</code> - The page metadata structure</div>
<div class="content">
<pre class="highlight"><code>static inline void bitmap_set(
    uint64_t *buffer, uint64_t pos, bool val) {
  if (val)
    buffer[pos / 64] |= (1UL &lt;&lt; pos % 64);
  else
    buffer[pos / 64] ^= (1UL &lt;&lt; pos % 64);
}
static inline bool bitmap_is_set(uint64_t *buffer, uint64_t pos) {
  return (buffer[pos / 64] &amp; (1UL &lt;&lt; pos % 64)) != 0;
}</code></pre>
</div>
</div>
<div id="file-layout-with-freepsace" class="imageblock">
<div class="content">
<img src="../imgs/file-layout-with-freepsace.png" alt="file layout with freepsace">
</div>
<div class="title">Figure 2. Layout of the file on disk after adding the free space bitmap</div>
</div>
</div>
<div class="sect2">
<h3 id="_freeing_a_page">Freeing a page</h3>
<div class="paragraph">
<p>The act of freeing a page is a lot easier than allocating one using this model. That is typically <em>not</em> the case, so this feature of the system
architecture makes me very happy. Let&#8217;s look at <a href="#txn_free_page"><code>txn.alloc.c</code> - Freeing a page in a transaction</a> to see how this is done.</p>
</div>
<div id="txn_free_page" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Freeing a page in a transaction</div>
<div class="content">
<pre class="highlight"><code>result_t txn_free_page(txn_t *tx, page_t *page) {
  errors_assert_empty();

  ensure(txn_raw_modify_page(tx, page));
  memset(page-&gt;address, 0, PAGE_SIZE * page-&gt;number_of_pages);

  for (size_t i = 0; i &lt; page-&gt;number_of_pages; i++) {
    ensure(txn_free_space_mark_page(tx, page-&gt;page_num + i, false));
  }

  return success();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fact that there is so little to do here is quite impressive. Even I&#8217;m saying this about my own code.
The <code>txn_free_page()</code> in <a href="#txn_free_page"><code>txn.alloc.c</code> - Freeing a page in a transaction</a> is getting the page that we want to free and zero it as its first action. I&#8217;m doing that for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure that if you try to access a page that was freed, you&#8217;ll know about it straight away. More paranoid approach would be to physically <code>unmap()</code> the
page, ensuring that any access will result in a seg fault, but that is probably too much.</p>
</li>
<li>
<p>Scrub away the data the user indicated the they want to delete. This isn&#8217;t really a security feature, mind. You&#8217;ll usually work at a level
smaller than a page anyway&#8230;&#8203;</p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/oldnewthing/20161109-00/?p=94675">Zero page optimization</a> at the operating system level.</p>
</li>
<li>
<p>Enable us to use other optimizations down the line, because we can recognize zero filled pages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that aside from zeroing the page, we don&#8217;t do anything special with it. Given that we set it in the free space bitmap, it may be used again if
the transaction will allocate a new page. The only thing that matters is that the page is modified and will be written to disk. This bears repeating. A freed
page gets absolutely no special treatment. It is just another way to modify a page.</p>
</div>
<div class="paragraph">
<p>We also modify the bitmap to record that the page (or pages, if it spans multiple pages) is now free. We do that in a way that is blind to the fact that this is a free space page. We
simply apply the changes to the free space bitmap on a modified page that will be written to disk. So we don&#8217;t actually <em>need</em> to do anything special here. I&#8217;m really happy with
how this turned out.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_an_allocation_strategy">Building an allocation strategy</h3>
<div class="paragraph">
<p>Memory allocation (and this is what the <code>txn_allocate_page()</code> is all about) is a complex topic. There have been papers, books and dissertations written about
the topic. The oldest reference that I could find for a memory allocation algorithm is from <em>1963</em>. The latest I could find was this week, I&#8217;m pretty sure
that if you flex your Google muscles, you&#8217;ll be able to find one posted today. For whatever value of today you feel like choosing.</p>
</div>
<div class="paragraph">
<p>There are <a href="https://conf.researchr.org/track/ismm-2020/ismm-2020"><em>conferences</em> about memory management</a>. Just memory management, a whole conference. With
annual events that started in <em>1992</em> (and I didn&#8217;t search hard).</p>
</div>
<div class="paragraph">
<p>I&#8217;ll let that sink in for a while, because we have been doing that for over half a century and this is still a hot area of research.
I&#8217;m not going to try to win prizes with the allocation strategy I&#8217;m going to outline here, but at the same time, the <em>reason</em> that this is such a hot topic
is that this is a critical piece of functionality.</p>
</div>
<div class="paragraph">
<p>A good allocator should be fast to execute, of course, but it also has a host of other properties that we need to consider. Among them we have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Increased locality of reference. Having related data sit physically close can be a major performance boost.</p>
</li>
<li>
<p>Reduce fragmentation. Right now, we only request a single page at a time, so that is not an issue. We need to be prepared for when we&#8217;ll need to deal with
multi page allocations. In that case, we want to avoid internal fragmentation as much as possible.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We already know that the backing store of the allocation is the free space bitmap. A busy page is marked with <code>1</code> and a free with <code>0</code>. In essence, the allocator
needs to be able to find the position of a zero bit in the bitmap. The good news is that this is very cheap operation, usually. The bad news is that we need
to be able to answer the question not on a single bit but on a range as well.</p>
</div>
<div class="paragraph">
<p>The basis for my code is from <a href="https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/">Daniel Lemire&#8217;s work</a>, adapted to allow us to find a range
of values. We start from the declarations in <a href="#bitmap_search_decl"><code>gavran/internal.h</code> - Declarations to find free space range in bitmap</a>.</p>
</div>
<div class="paragraph">
<p>This function accepts the <code>bitmap_search_state_t</code> with the bitmap buffer and its size, the required size and the preferred location and returns the found position using the <code>found_position</code>
output value. As usual, we use the return value to indicate success or failure only. In this case, the function does no allocation and a failure here means that we couldn&#8217;t find a free range
to satisfy the required space.</p>
</div>
<div class="paragraph">
<p>We might also find <em>more</em> space than was asked for, so we report that to the caller so they can make an informed decision about what to do with the extra space.</p>
</div>
<div class="paragraph">
<p>The <code>bitmap_search_state_t</code> is a complex structure, meant for internal consumption only. The caller should zero initialize the structure except for the <code>input</code> nested structure. Then the
<code>bitmap_search()</code> will find a free range in the bitmap. It is a pretty complex piece of code, composed of multiple layers. I&#8217;m going to explain it from the bottom up.
Starting with the most basic step in the process, the <code>bitmap_search_word()</code> function. <a href="#bitmap_search_word"><code>bitmap.c</code> - Finding a range of free bits inside a single word</a> shows how <code>bitmap_search_word()</code> works.</p>
</div>
<div id="bitmap_search_decl" class="listingblock">
<div class="title"><code>gavran/internal.h</code> - Declarations to find free space range in bitmap</div>
<div class="content">
<pre class="highlight"><code>typedef struct bitmap_search_state {
  struct {
    uint64_t *bitmap;
    size_t bitmap_size;
    uint64_t space_required;
    uint64_t near_position;
  } input;
  struct {
    uint64_t found_position;
    uint64_t space_available_at_position;
  } output;
  struct {
    uint64_t index;
    uint64_t current_word;
    uint64_t current_set_bit;
    uint64_t previous_set_bit;
    size_t search_offset;
  } internal;

} bitmap_search_state_t;

implementation_detail bool bitmap_search(
    bitmap_search_state_t *search);
implementation_detail bool bitmap_is_acceptable_match(
    bitmap_search_state_t *search);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>bitmap_search_word()</code> operates on a <em>single</em> word (<code>uint64_t</code>). Each time it is called, it will go through up to 64 bits (thus, 64 pages or 512KB) to
find the next free range. If the entire word is set (all busy), we&#8217;ll return <code>false</code> and have the caller provide us with the next word to search.
If the entire word is zero, we will check if the current available space plus whatever we have from previous words is enough to satisfy the requested space.
This is done in the <code>bitmap_finalize_match()</code> function, shown in <a href="#bitmap_finalize_match"><code>bitmap.c</code> - Validating a potential range match</a>.</p>
</div>
<div class="paragraph">
<p>The most interesting part in <a href="#bitmap_search_word"><code>bitmap.c</code> - Finding a range of free bits inside a single word</a> is when we have a word that has a mix of set and cleared bits. Then we need to find if there are enough cleared consecutive bits
<em>inside</em> the word. We use the technique describe by Lemire to do so.</p>
</div>
<div class="paragraph">
<p>We measure this using <code>__builtin_ctzl</code> which is an operation that would count the trailing zeros on the value. We use that to compute the distance to the first set bit,
check whatever that gives us the right range or not. If we didn&#8217;t find the right range, we then clear the least significant bit using: <code>(x &amp; -x)</code>. This will
keep just the least significant bit in the number, and we then clear that from the current value. That allows us to count the distance to the set bit and then
remove that set bit and count again. We use that distance as a way to know where the cleared ranges are. To handle the case of the first bit being clear,
we also have an <em>intentional</em> overflow of the <code>previous_set_bit</code> field (unsigned value, so no undefined behavior here).</p>
</div>
<div class="paragraph">
<p>Finally, we call <code>bitmap_finalize_match()</code>, in one of two cases. If the entire word is zeroed or if we run through all the set bits and now we have a free range at the
end of the value.  We rely on <code>previous_set_bit</code> to be set to <code>ULONG_MAX</code> by the caller of <code>bitmap_search_word()</code> and then add one to it. If there have been no other set bits,
the value overflow and is set to 0, which is then used as the starting point of the current range. If there is a value in <code>previous_set_bit</code>, we move one
past the last filled bit and return that.</p>
</div>
<div id="bitmap_search_word" class="listingblock">
<div class="title"><code>bitmap.c</code> - Finding a range of free bits inside a single word</div>
<div class="content">
<pre class="highlight"><code>static bool bitmap_search_word(bitmap_search_state_t *search) {
  uint64_t bitset = search-&gt;internal.current_word;

  if (bitset == ULONG_MAX) {
    // all bits are set, can skip whole thing
    bitmap_finalize_match(search);
    search-&gt;internal.previous_set_bit =
        (search-&gt;internal.index + 1) * 64 - 1;
    return false;
  }

  if (bitset == 0) {
    search-&gt;internal.current_set_bit =
        (search-&gt;internal.index + 1) * 64;
    return bitmap_finalize_match(search);
  }

  while (bitset != 0) {
    int r = __builtin_ctzl(bitset);
    search-&gt;internal.current_set_bit =
        (search-&gt;internal.index) * 64 + (uint64_t)r;
    if (search-&gt;internal.current_set_bit &gt;
        search-&gt;internal.previous_set_bit +
            search-&gt;input.space_required) {
      // intentionally overflowing here
      search-&gt;output.found_position =
          search-&gt;internal.previous_set_bit + 1;
      search-&gt;output.space_available_at_position =
          (search-&gt;internal.current_set_bit -
              search-&gt;output.found_position);
      search-&gt;internal.previous_set_bit =
          search-&gt;internal.current_set_bit;
      return true;
    }
    search-&gt;internal.previous_set_bit =
        search-&gt;internal.current_set_bit;
    bitset ^= (bitset &amp; -bitset);
  }

  search-&gt;internal.current_set_bit =
      (search-&gt;internal.index + 1) * 64;
  return bitmap_finalize_match(search);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code is succinct, and I like how it turned out. It took several tries to get something that works and was maintainable
A part of what make this function challenging is that we are keeping track of the state <em>across</em> calls. For example, we may have a free range that strides a
word boundary. That will be handle in <em>two</em> calls to <code>bitmap_search_word()</code>.</p>
</div>
<div class="paragraph">
<p>It might be easier to understand if you take a peek at <a href="#bitmap-colored">Visualization of the bitmap 0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC</a>, which shows a bitmap in a visual manner for the bitmap:
 <code>{0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC}</code>.</p>
</div>
<div id="bitmap_finalize_match" class="listingblock">
<div class="title"><code>bitmap.c</code> - Validating a potential range match</div>
<div class="content">
<pre class="highlight"><code>static bool bitmap_finalize_match(bitmap_search_state_t *search) {
  if (search-&gt;internal.current_set_bit &gt;
      search-&gt;internal.previous_set_bit +
          search-&gt;input.space_required) {
    // intentionally overflowing here
    search-&gt;output.found_position =
        search-&gt;internal.previous_set_bit + 1;
    search-&gt;output.space_available_at_position =
        (search-&gt;internal.current_set_bit -
            search-&gt;output.found_position);
    return true;
  }
  return false;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#bitmap-colored">Visualization of the bitmap 0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC</a> has three types of cells:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Marked with <code>X</code> - busy.</p>
</li>
<li>
<p>Marked with <code>V</code> and colored - we&#8217;ll run a few sample queries on them, so I highlighted them for ease of identification.</p>
</li>
<li>
<p>Empty - free cells.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Look at the first row of cells in <a href="#bitmap-colored">Visualization of the bitmap 0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC</a>, if we want to allocate a page near the marked position (red), where would you put it? What if we wanted to
allocate two pages? In the middle of the image, there is another marked position (yellow), I want to get 4 pages near that location. And we want to get
7 pages near the last marked position (green).</p>
</div>
<div class="paragraph">
<p>The data in <a href="#bitmap-colored">Visualization of the bitmap 0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC</a> has multiple words to go through, let&#8217;s see how the code is handling it. We use the <code>bitmap_search_word()</code> to search a single word and
<code>bitmap_search_once()</code> to search the entire bitmap. The code for that function in in <a href="#bitmap_search_once"><code>bitmap.c</code> - Finding a range of free bits in the entire bitmap</a>.</p>
</div>
<div id="bitmap-colored" class="imageblock">
<div class="content">
<img src="../imgs/bitmap-colored.png" alt="bitmap colored">
</div>
<div class="title">Figure 3. Visualization of the bitmap 0x80520A27102E21, 0xE0000E00020, 0x1A40027F025802C8, 0xEE6ACAE56C6C3DCC</div>
</div>
<div class="paragraph">
<p>Because most of the work is done by <code>bitmap_search_word()</code>, the code for <code>bitmap_search_once()</code> mostly deals with orchestrating it. We try to find a range in the current word,
and if we can, we mask it so the next call will <em>not</em> find it. That is the core of how we iterate. If we run out of the current word, we&#8217;ll switch to the next one and
continue the search. Note that even if we found an appropriately sized range, if it is in the end of the current word, we&#8217;ll scan the next word at least
to find what the <em>size</em> of that range is.</p>
</div>
<div class="paragraph">
<p>We could use <code>bitmap_search_once()</code> to manage the task of allocating the next range, but that wouldn&#8217;t be ideal. Finding the first free range that fit our needs
is an allocations strategy that is called First Fit. I looked it up and here are
<a href="https://dl.acm.org/doi/pdf/10.1145/359436.359453">couple of papers from <em>1974</em></a> that discusses
<a href="https://www.researchgate.net/publication/220459885_Worst_Case_Fragmentation_of_First_Fit_and_Best_Fit_Storage_Allocation_Strategies">its usefulness</a>.
They are mostly here as a historical interest, they are testing this out on a PDP-11.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Why are we spending so much time with the allocator?</div>
<div class="paragraph">
<p>It may seems strange that I&#8217;m covering so much time right now for the implementation of the allocator. I just checked how it goes with Voron, RavenDB&#8217;s storage
engine, and I found that the last time anyone made a meaningful change there was in Oct of 2015 and most of the actual work was done in 2013. It has been
able to handle production loads for all this time without us really needing to pay it much attention.</p>
</div>
<div class="paragraph">
<p>However, it took <em>time</em> and a lot of hard work to get there. In Gavran, I&#8217;m trying to avoid that complexity pitfall by doing things properly from the get go.
I&#8217;m writing this in Jun of 2020, which means that five to eight years after the fact, I still remember how hard getting free space handling in Voron was to
get <em>right</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="bitmap_search_once" class="listingblock">
<div class="title"><code>bitmap.c</code> - Finding a range of free bits in the entire bitmap</div>
<div class="content">
<pre class="highlight"><code>static bool bitmap_search_once(bitmap_search_state_t *search) {
  uint64_t original_pos = search-&gt;output.found_position;
  do {
    if (bitmap_search_word(search)) {
      if (search-&gt;internal.current_set_bit % 64) {
        // mask the already found item
        uint64_t mask =
            ~(ULONG_MAX &lt;&lt; (search-&gt;internal.current_set_bit % 64));
        search-&gt;internal.current_word |= mask;
      } else {
        // run out current word, but maybe we have more in the next?
        uint64_t next = search-&gt;internal.index + 1;
        if (next &lt; search-&gt;input.bitmap_size &amp;&amp;
            (search-&gt;input.bitmap[next] &amp; 1) == 0) {
          search-&gt;internal.index++;
          search-&gt;internal.current_word =
              search-&gt;input.bitmap[search-&gt;internal.index];
          continue;
        } else {
          search-&gt;internal.current_word = ULONG_MAX;
        }
      }
      if (!bitmap_is_acceptable_match(search)) continue;
      return true;
    }
    if (original_pos != search-&gt;output.found_position &amp;&amp;
        bitmap_is_acceptable_match(search))
      return true;
    search-&gt;internal.index++;
    if (search-&gt;internal.index &gt;= search-&gt;input.bitmap_size)
      return false;
    search-&gt;internal.current_word =
        search-&gt;input.bitmap[search-&gt;internal.index];
  } while (true);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The core issue with first fit is that it can cause internal fragmentation. In other words, we allocate pages in such a pattern that even though we have the
the right number of pages free, we don&#8217;t have enough <em>consecutive</em> pages to answer the allocation. We can do better. The key to that is shown in <a href="#bitmap_search_smallest_nearby"><code>bitmap.c</code> - Finding the <em>best</em> free range for an allocation</a>.
 For such a short function there is a <em>lot</em> of functionality there.</p>
</div>
<div id="bitmap_search_smallest_nearby" class="listingblock">
<div class="title"><code>bitmap.c</code> - Finding the <em>best</em> free range for an allocation</div>
<div class="content">
<pre class="highlight"><code>#define MAX_SEARCH_DISTANCE 64
static bool bitmap_search_smallest_nearby(
    bitmap_search_state_t *search) {
  uint64_t current_pos  = 0;
  uint64_t current_size = ULONG_MAX;

  // the bigger the request range, the less we care about locality
  size_t boundary =
      (search-&gt;input.near_position + MAX_SEARCH_DISTANCE +
          search-&gt;input.space_required);
  while (bitmap_search_once(search)) {
    if (search-&gt;input.space_required ==
        search-&gt;output.space_available_at_position)
      return true;  // perfect match!
    if (current_size &gt; search-&gt;output.space_available_at_position) {
      current_size = search-&gt;output.space_available_at_position;
      current_pos  = search-&gt;output.found_position;
    }
    if (search-&gt;input.near_position &amp;&amp;
        search-&gt;output.found_position &gt; boundary) {
      // We have gone too far? Stop being choosy
      if (current_size &lt; search-&gt;output.space_available_at_position) {
        search-&gt;output.space_available_at_position = current_size;
        search-&gt;output.found_position              = current_pos;
      }
      return true;
    }
  }

  search-&gt;output.space_available_at_position = current_size;
  search-&gt;output.found_position              = current_pos;

  return current_size != ULONG_MAX;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What <code>bitmap_search_smallest_nearby()</code> does is to use <code>bitmap_search_once()</code> in a loop, trying to find the best match. In this case, we define best as the smallest
range that can fit the requested size. However, we also take locality of reference into account here. The code will try to find a range that starts
within roughly 64 pages (512Kb) from the requested position. If we can&#8217;t find such a range, we&#8217;ll try to either use a larger than necessary range from near
the requested location or the first suitable range of any size that we run into.</p>
</div>
<div class="paragraph">
<p>We can now look at <code>bitmap_search()</code> itself and see how it works, take a look at <a href="#bitmap_search"><code>bitmap.c</code> - Allocate a range from the bitmap</a>.</p>
</div>
<div id="bitmap_search" class="listingblock">
<div class="title"><code>bitmap.c</code> - Allocate a range from the bitmap</div>
<div class="content">
<pre class="highlight"><code>bool bitmap_search(bitmap_search_state_t *search) {
  if (!search-&gt;input.space_required ||
      search-&gt;input.near_position / 64 &gt;= search-&gt;input.bitmap_size)
    return false;

  search-&gt;internal.current_word     = search-&gt;input.bitmap[0];
  search-&gt;internal.previous_set_bit = ULONG_MAX;

  search-&gt;internal.search_offset = search-&gt;input.near_position / 64;

  void *old_bitmap  = search-&gt;input.bitmap;
  uint64_t old_size = search-&gt;input.bitmap_size;

  search-&gt;input.bitmap += search-&gt;internal.search_offset;
  search-&gt;input.bitmap_size -= search-&gt;internal.search_offset;
  search-&gt;internal.search_offset *= 64;  //  pages instead of words

  if (bitmap_search_smallest_nearby(search)) {
    search-&gt;output.found_position += search-&gt;internal.search_offset;
    return true;
  }
  if (!search-&gt;internal.search_offset) {
    return false;  // already scanned it all
  }

  search-&gt;input.bitmap        = old_bitmap;
  search-&gt;input.bitmap_size   = old_size;
  search-&gt;input.near_position = 0;  // search all
  return bitmap_search(search);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We call <code>bitmap_search_smallest_nearby()</code> from <code>bitmap_search()</code> with range that starts at the current location. In other words, we are skipping
looking at the pages that come before the requested location. We&#8217;ll look there only if we couldn&#8217;t find a range afterward. This is important because
it bias the allocations forward.</p>
</div>
<div class="paragraph">
<p>That is an intentional design decision. The idea is that you&#8217;ll call <code>bitmap_search()</code> with the location of an item you already have and
ask it to be placed nearby. As you&#8217;ll likely do that over a wide range of locations, that should balance things out. You can also pass <code>0</code> as the
starting location, in which case we&#8217;ll search for the <em>best</em> fit in the entire bitmap, without trying to find a nearby location.</p>
</div>
</div>
<div class="sect2">
<h3 id="_allocating_pages">Allocating pages</h3>
<div class="paragraph">
<p>Now that we have an allocator ready, let see what it takes to actually allocate a page, shall we? Without further ado, skip ahead to <a href="#txn_allocate_page"><code>txn.alloc.c</code> - Allocate a page in the transaction</a> to
see how it all comes together.</p>
</div>
<div id="txn_allocate_page" class="listingblock">
<div class="title"><code>txn.alloc.c</code> - Allocate a page in the transaction</div>
<div class="content">
<pre class="highlight"><code>result_t txn_allocate_page(
    txn_t *tx, page_t *page, uint64_t nearby_hint) {
  page_t p = {.page_num = 0};
  ensure(txn_raw_get_page(tx, &amp;p));
  page_metadata_t *file_header_metadata = p.address;
  uint64_t start =
      file_header_metadata-&gt;file_header.free_space_bitmap_start;

  if (!page-&gt;number_of_pages) page-&gt;number_of_pages = 1;

  // <b class="conum">(1)</b>
  page_t bitmap_page = {.page_num = start};
  ensure(txn_raw_get_page(tx, &amp;bitmap_page));
  bitmap_search_state_t search = {
      .input = {.bitmap = bitmap_page.address,
          .bitmap_size  = (bitmap_page.number_of_pages * PAGE_SIZE) /
                         sizeof(uint64_t),
          .space_required = page-&gt;number_of_pages,
          .near_position  = nearby_hint}};
  // <b class="conum">(2)</b>
  if (bitmap_search(&amp;search)) {
    page-&gt;page_num = search.output.found_position;
    // <b class="conum">(3)</b>
    ensure(txn_raw_modify_page(tx, page));
    memset(page-&gt;address, 0, PAGE_SIZE * page-&gt;number_of_pages);
    for (size_t i = 0; i &lt; page-&gt;number_of_pages; i++) {
      ensure(txn_free_space_mark_page(
          tx, search.output.found_position + i, true));
    }

    return success();
  }

  // <b class="conum">(4)</b>
  failed(ENOSPC, msg("No more room left in the file to allocate"),
      with(tx-&gt;state-&gt;db-&gt;handle-&gt;filename, "%s"));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the free space bitmap.</p>
</li>
<li>
<p>Perform the search for a range in the bitmap.</p>
</li>
<li>
<p>When we find an available page, we zero it (just to be on the safe side) mark it as busy in the bitmap and return.</p>
</li>
<li>
<p>Handling the case of no space left on the file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We are scanning through the free space bitmap, one page at a time, trying to find a free page. When we find the page, we call <code>txn_raw_modify_page()</code> on it. We then
zero it. This isn&#8217;t something that we <em>have</em> to do, we already zero pages when we free them and we know that we are getting zeroed pages from the file
system. I&#8217;m doing this to make doubly sure that we don&#8217;t end up with strange things in here. The rule is that if you asked for a new page, you&#8217;ll get it
free and clear.  While getting a new page from the OS is guaranteed to be zero, we may allocate a page that was previously used. We <em>are</em> zeroing it on free, but
better safe than sorry.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Worst case allocation performance</div>
<div class="paragraph">
<p>What is the worst case for allocating pages in Gavran? If the entire bitmap is full and there is no free space, or if there are no free spaces large enough for
the required allocation. The cost of that is iterating over the bitmap memory. For a 512GB database, that will require us to scan a bitmap of 8MB.
That isn&#8217;t going to break the bank, especially since the bitmap is a single run that we can scan through and the system will optimize this for us
automatically.</p>
</div>
<div class="paragraph">
<p>There are ways that to optimize this, we can remember where was the last location that we were able to find a free range, for example. As usual, further
performance optimizations will remain unimplemented unless a benchmark convince me otherwise.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, I need to mark the newly allocated page as busy. Note that I <em>cannot</em> just use <code>bitmap_page</code> here, I got that through <code>txn_raw_get_page()</code>, which returns a
read only copy. The actual setting of the page as busy is done in <a href="#txn_free_space_mark_page">Listing 5.12 - txn.c - Marking a page as busy in the free space bitmap</a>, where we are calling <code>txn_raw_modify_page()</code> to make sure that we
can modify the bitmap&#8217;s memory.</p>
</div>
<div class="paragraph">
<p>As it currently stand, the <code>txn_allocate_page()</code> will fail once we have run out of the internally allocated space. We&#8217;ll need to address that, we want to allow
the user to increase the file size as needed. We&#8217;ll deal with this issue as well in the next chapter.</p>
</div>
<div id="txn_free_space_mark_page" class="listingblock">
<div class="title">Listing 5.12 - txn.c - Marking a page as busy in the free space bitmap</div>
<div class="content">
<pre class="highlight"><code>static result_t txn_free_space_mark_page(
    txn_t *tx, uint64_t page_num, bool busy) {
  page_t p = {.page_num = 0};
  ensure(txn_raw_get_page(tx, &amp;p));
  page_metadata_t *metadata = p.address;
  uint64_t start = metadata-&gt;file_header.free_space_bitmap_start;

  uint64_t relevant_free_space_bitmap_page =
      start + page_num / BITS_IN_PAGE;

  page_t bitmap_page = {.page_num = relevant_free_space_bitmap_page};
  ensure(txn_raw_modify_page(tx, &amp;bitmap_page));
  bitmap_set(bitmap_page.address, page_num % BITS_IN_PAGE, busy);
  return success();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together">Putting it all together</h3>
<div class="paragraph">
<p>This chapter has gone on longer than I expected, but we are finally here. You can look at <a href="#allocate_page_and_use_it"><code>test.c</code> - Using the transaction allocation API</a> to see how we can use the new API.
The code in <code>allocate_page_and_use_it()</code> will test that the content of the newly allocated page is set to string "Hello Gavran".
You can run this multiple times to see how it allocates a new page on each run. Calls to <code>txn_free_page()</code> will make the page available for allocations again.
The next chapter will deal with issues such as allocating multiple pages and managing pages metadata.</p>
</div>
<div id="allocate_page_and_use_it" class="listingblock">
<div class="title"><code>test.c</code> - Using the transaction allocation API</div>
<div class="content">
<pre class="highlight"><code>static result_t allocate_page_and_use_it(const char* path) {
  // <b class="conum">(1)</b>
  db_t db;
  db_options_t options = {.minimum_size = 128 * 1024};
  ensure(db_create(path, &amp;options, &amp;db));
  defer(db_close, db);

  // <b class="conum">(2)</b>
  txn_t tx;
  ensure(txn_create(&amp;db, TX_WRITE, &amp;tx));
  defer(txn_close, tx);

  // <b class="conum">(3)</b>
  page_t page = {0};
  ensure(txn_allocate_page(&amp;tx, &amp;page, 0));

  // <b class="conum">(4)</b>
  strcpy(page.address, "Hello Gavran");

  // <b class="conum">(5)</b>
  ensure(txn_commit(&amp;tx));
  ensure(txn_close(&amp;tx));

  // <b class="conum">(6)</b>
  ensure(txn_create(&amp;db, TX_READ, &amp;tx));
  ensure(txn_raw_get_page(&amp;tx, &amp;page));

  ensure(strcmp("Hello Gavran", page.address) == 0);

  return success();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the database (and set close on function end via <code>defer()</code>).</p>
</li>
<li>
<p>Create a transaction (and close via <code>defer()</code>).</p>
</li>
<li>
<p>Allocate a new page using the free space bitmap</p>
</li>
<li>
<p>Copy data to the new page</p>
</li>
<li>
<p>Commit and close the transaction</p>
</li>
<li>
<p>Create a new transaction to read the data. Note that <em>this</em> transaction will be closed via the previous setup <code>defer()</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_unit_tests">Unit tests</h3>
<div class="paragraph">
<p>As usual, a chapter close means that we need to unit test our code. You can see how we are putting the allocation API through its paces in <a href="#tests"><code>test.c</code> - Testing the allocation API</a>.</p>
</div>
<div id="tests" class="listingblock">
<div class="title"><code>test.c</code> - Testing the allocation API</div>
<div class="content">
<pre class="highlight"><code>describe(allocation_tests) {
  before_each() {
    errors_clear();
    system("mkdir -p /tmp/db");
    system("rm -f /tmp/db/*");
  }

  it("can allocate, write and then read data") {
    assert(allocate_page_and_use_it("/tmp/db/try"));
  }

  it("can allocate pages") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);
    page_t p = {.number_of_pages = 1};
    assert(txn_allocate_page(&amp;tx, &amp;p, 0));
    assert(p.page_num == FIRST_USABLE_PAGE);
    assert(txn_allocate_page(&amp;tx, &amp;p, 0));
    assert(p.page_num == FIRST_USABLE_PAGE + 1);
  }

  it("can allocate until space runs out") {
    db_t db;
    db_options_t options = {
        .minimum_size = 128 * 1024, .maximum_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);
    for (size_t i = 0; i &lt; 16 - FIRST_USABLE_PAGE; i++) {
      page_t p = {.number_of_pages = 1};
      assert(txn_allocate_page(&amp;tx, &amp;p, 0));
    }

    {
      page_t p = {.number_of_pages = 1};
      assert(!txn_allocate_page(&amp;tx, &amp;p, 0));  // failed
      size_t count;
      int* codes = errors_get_codes(&amp;count);
      assert(count &gt; 0);
      bool found = false;
      for (size_t i = 0; i &lt; count; i++) {
        if (codes[i] == ENOSPC) {
          found = true;
          break;
        }
      }
      assert(found);
    }
  }

  it("can allocate, free and allocate again") {
    db_t db;
    db_options_t options = {.minimum_size = 128 * 1024};
    assert(db_create("/tmp/db/try", &amp;options, &amp;db));
    defer(db_close, db);

    txn_t tx;
    assert(txn_create(&amp;db, TX_WRITE, &amp;tx));
    defer(txn_close, tx);
    page_t p = {.number_of_pages = 1};
    assert(txn_allocate_page(&amp;tx, &amp;p, 0));
    if (p.metadata) {
      // not relevant for this chapter, will be in others
      p.metadata-&gt;overflow.page_flags      = page_flags_overflow;
      p.metadata-&gt;overflow.number_of_pages = 1;
      p.metadata-&gt;overflow.size_of_value   = 8000;
    }

    uint64_t page_num = p.page_num;

    assert(txn_free_page(&amp;tx, &amp;p));

    assert(txn_allocate_page(&amp;tx, &amp;p, 0));
    assert(p.page_num == page_num);  // page is reused
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
    <ul style="list-style-type: none;">
        <li><a class="footer-text" href="../index.html">Table of contents</a></li>
        <li><a class="footer-text" href="./ch04.html">Previous chapter</a></li>
        <li><a class="footer-text" href="./ch06.html">Next chapter</a></li>
    </ul>
</div>
</body>
</html>